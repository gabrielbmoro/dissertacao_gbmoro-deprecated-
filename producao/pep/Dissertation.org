#+TITLE:
#+AUTHOR: Gabriel Bronzatti Moro

#+STARTUP: overview indent
#+LANGUAGE: en
#+OPTIONS: H:3 creator:nil timestamp:nil skip:nil toc:nil num:t ^:nil ~:~
#+OPTIONS: author:nil title:nil date:nil
#+TAGS: noexport(n) deprecated(d) ignore(i)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

#+LATEX_CLASS: iiufrgs
#+LATEX_CLASS_OPTIONS: [ppgc,tc,brasilian]
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{subfigure}
#+LATEX_HEADER: \usepackage{tabulary}
#+LATEX_HEADER: \usepackage{tabularx}
#+LATEX_HEADER: \usepackage{mathtools}
#+LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{algorithmic}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \newcommand{\prettysmall}{\fontsize{6.5}{6.5}\selectfont}
#+LATEX_HEADER: \newcommand{\prettysmallbis}{\fontsize{7}{7}\selectfont}
#+LATEX_HEADER: \newcommand{\mtilde}{~}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{palatino}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{cleveref}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage[normalem]{ulem}
#+LATEX_HEADER: \usepackage{xspace}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \newcommand{\review}[1]{\textcolor[rgb]{1,0,0}{[Orientador: #1]}}
#+LATEX_HEADER: \newcommand{\Orientador}[1]{\textcolor[rgb]{0.2,0.2,0.7}{[Orientador: #1]}}
#+LATEX_HEADER: \newcommand{\source}{Source: Author}
#+LATEX_HEADER: \input{configuration.tex}

* Export to PDF (org-mode installation + emacnos configuration)    :noexport:

_org-mode installation_

Use the org-version =8.3.4=. To check, run M-x then type org-version,
then hit the enter key. You should see the current version. If your
version is older, or if the command you just type is unrecognized, you
have to install the latest version of org by following these steps:

#+BEGIN_SRC sh :results silent :exports none
git clone git://orgmode.org/org-mode.git; cd org-mode;
git checkout release_8.3.4; make
#+END_SRC

Then, edit the file =local.mk= changing the variable =prefix=. I
suggest you install in your HOME directory by putting something like:

=/home/schnorr/install/org-mode/=

For me, I have this (just an example):

#+BEGIN_EXAMPLE
prefix  = /home/schnorr/install/org-mode/
#+END_EXAMPLE

Finally, within the org-mode directory, just type:

#+BEGIN_SRC sh :results silent :exports none
make install
#+END_SRC

_Emacs configuration_

Now, you need to configure emacs.

Create a directory =.emacs.d= in your HOME directory.

Make sure your version of emacs is at least 24.4. Mine is:

#+begin_src sh :results output :session :exports both
emacs --version
#+end_src

#+RESULTS:
: GNU Emacs 24.4.1
: Copyright (C) 2014 Free Software Foundation, Inc.
: GNU Emacs comes with ABSOLUTELY NO WARRANTY.
: You may redistribute copies of Emacs
: under the terms of the GNU General Public License.
: For more information about these matters, see the file named COPYING.

Then, create (in =.emacs.d= directory) a =init.el= file with the following:

#+BEGIN_EXAMPLE
(add-to-list 'load-path "~/install/org-mode/emacs/site-lisp/org")
(mapc #'org-babel-load-file (directory-files dotfiles-dir t "\\.org$"))
#+END_EXAMPLE

To have the shortcuts and facilities I employ when coding in org, you
might want to put in the =.emacs.d= directory the contents described here:

http://mescal.imag.fr/membres/arnaud.legrand/misc/init.php

Or, just execute the following sequence of commands:

#+begin_src sh :results output :session :exports both
cd $HOME/.emacs.d/
wget http://mescal.imag.fr/membres/arnaud.legrand/misc/init.org -O mine.org
#+end_src

Note that the name has to be different from =init.org=, otherwise in the
first run of =emacs=, the initialization process will destroy the
configuration file you have just created. In this example, I have then
called the file =mine.org=.

Hope this helps.

* Front page preparation                                           :ignore:
#+BEGIN_LaTeX
\title{Plano de Ensino e Pesquisa}
\author{Bronzatti Moro}{Gabriel}
\advisor[Prof.~Dr.]{Mello Schnorr}{Lucas}

\date{Outubro}{2016}
\location{Porto Alegre}{RS}

% \renewcommand{\nominataReit}{Prof\textsuperscript{a}.~Wrana Maria Panizzi}
% \renewcommand{\nominataReitname}{Reitora}
% \renewcommand{\nominataPRE}{Prof.~Jos{\'e} Carlos Ferraz Hennemann}
% \renewcommand{\nominataPREname}{Pr{\'o}-Reitor de Ensino}
% \renewcommand{\nominataPRAPG}{Prof\textsuperscript{a}.~Joc{\'e}lia Grazia}
% \renewcommand{\nominataPRAPGname}{Pr{\'o}-Reitora Adjunta de P{\'o}s-Gradua{\c{c}}{\~a}o}
% \renewcommand{\nominataDir}{Prof.~Philippe Olivier Alexandre Navaux}
% \renewcommand{\nominataDirname}{Diretor do Instituto de Inform{\'a}tica}
% \renewcommand{\nominataCoord}{Prof.~Carlos Alberto Heuser}
% \renewcommand{\nominataCoordname}{Coordenador do PPGC}
% \renewcommand{\nominataBibchefe}{Beatriz Regina Bastos Haro}
% \renewcommand{\nominataBibchefename}{Bibliotec{\'a}ria-chefe do Instituto de Inform{\'a}tica}
% \renewcommand{\nominataChefeINA}{Prof.~Jos{\'e} Valdeni de Lima}
% \renewcommand{\nominataChefeINAname}{Chefe do \deptINA}
% \renewcommand{\nominataChefeINT}{Prof.~Leila Ribeiro}
% \renewcommand{\nominataChefeINTname}{Chefe do \deptINT}


%
% TODO: provide these keywords
%
%\keyword{HPC}
#+END_LaTeX

* Front page                                                       :ignore:
#+BEGIN_LaTeX
\maketitle
#+END_LaTeX

* Abstract                                                         :ignore:

#+BEGIN_LaTeX
\begin{abstract}
#+END_LaTeX
#+BEGIN_LaTeX
Abstract ...
\end{abstract}
#+END_LaTeX

* Lists                                                            :ignore:

#+BEGIN_LaTeX
%\listoffigures
%\listoftables

% lista de abreviaturas e siglas
% o parametro deve ser a abreviatura mais longa
%\begin{listofabbrv}{SPMD}
%   \item[ANTLR] Another Tool For Language Recognition
%   \item[CSV] Comma Separated Values
%   \item [DBMS] Database Management System    
%   \item[GC] Garbage Collector 
%   \item[HPC] High Performance Computing
%   \item[JDBC] Java Database Connectivity
%   \item[JVM] Java Virtual Machine
%\end{listofabbrv}


% idem para a lista de símbolos
% \begin{listofsymbols}{$\alpha\beta\pi\omega$}
%     \item[$\sum{\frac{a}{b}}$] Somatório do produtório
%     \item[$\alpha\beta\pi\omega$] Fator de inconstância do resultado
% \end{listofsymbols}
#+END_LaTeX

* Sumário                                                            :ignore:

#+BEGIN_LaTeX
\tableofcontents
#+END_LaTeX

* Configuring Emacs to correctly export to PDF                     :noexport:

Org mode is configured by default to export only the base classes.

See for details:
+ http://orgmode.org/worg/org-tutorials/org-latex-export.html

Execute the following code (with C-c C-c) prior to export this file to PDF.

#+BEGIN_SRC emacs-lisp :results silent :exports nones
(add-to-list 'load-path ".")
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
(add-to-list 'org-latex-classes
             '("iiufrgs"
               "\\documentclass{iiufrgs}"
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC
* 2016-03-18 First entry (proper emacs configuration file)   :noexport:Orientador:

I recommend you use Arnaud's emacs configuration file, available here:
+ http://mescal.imag.fr/membres/arnaud.legrand/misc/init.php

Download the file =init.org=:

#+begin_src sh :results output :session :exports both
wget http://mescal.imag.fr/membres/arnaud.legrand/misc/init.org
#+end_src

#+RESULTS:

* 2016-04-29 How to compile with _bibtex_ entries              :Orientador:noexport:

Do as follows:

1. Export as usual to latex
2. Then, type in the terminal
   #+begin_src sh :results output :session :exports both
   pdflatex Dissertation.tex
   bibtex Dissertation
   pdflatex Dissertation.tex
   pdflatex Dissertation.tex
   #+end_src

* Introdução
* Conceitos Básicos
\label{chapter.basic_concepts}

Este capítulo apresentará alguns conceitos que são fundamentais para a
compreensão da proposta do trabalho. Como o trabalho leva em
consideração o comportamento de aplicações paralelas, será abordado
nesse capítulo um pouco sobre os tipos de aplicações e suas
principais características, o que pode impactar diretamente no
comportamento de uma aplicação. 

** Tipos de Aplicações Paralelas

Existem vários modelos de aplicações paralelas para memória
compartilhada, dentre esses modelos, os tipos de aplicações utilizadas
nos experimentos desse trabalho podem ser classificadas em abordagens
de tipo: Fork-join, Stencil, Mapeamento e Redução.

*** Fork-join

O modelo Fork-join consiste em um processo que dispara várias threads
(fork), após essa divisão, geralmente ocorre um processamento
específico em cada thread (abordagem muito usada em Pthreads) ou um
processamento similar, sobre diferentes dados (abordagem mais usada em
OpenMP) \cite{pacheco2011introduction}. Algoritmos que utilizam a
abordagem de divisão e conquista, como por exemplo o algoritmo
Merge-sort, fazem uso do modelo Fork-Join. Na Figura
\ref{fig.fork-join} é possível visualizar um exemplo de fork-join, um
processo que inicializa duas threads.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Exemplo de Aplicação Fork-Join \cite{pacheco2011introduction}.}
\centering
\includegraphics[width=.85\linewidth]{./img/applicationFork-join.pdf}
\label{fig.fork-join} 
\end{figure}
#+END_LaTeX

*** Stencil

Aplicações do tipo Stencil realizam uma espécie de computação
matricial, aplicando cálculos sobre determinada célula da matriz,
levando em consideração suas células vizinhas \cite{Roth1997}. Muitas
dependências podem ocorrer nesse tipo de abordagem, o que torna esse
tipo de aplicação mais complexo do ponto de vista de implementação. A
Figura \ref{fig.stencil} apresenta o funcionamento básico desse tipo
de aplicação.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Exemplo de Aplicação Stencil.}
\centering
\includegraphics[width=.85\linewidth]{./img/applicationStencil.pdf}
\label{fig.stencil} 
\end{figure}
#+END_LaTeX

O exemplo da Figura \ref{fig.stencil} apresenta uma matriz, uma parte
dela é selecionada pelo algoritmo, nessa parte é realizado um cálculo
que leva em consideração os valores dos vizinhos da célula alvo. O
mesmo procedimento é realizado para todos os elementos da
matriz. Nesse exemplo é possível visualizar uma dependência muito
comum, quando a célula fizer parte de uma borda, faltará
alguns vizinhos para a mesma. Dependendo do cálculo que está sendo
realizado e do algoritmo, a solução para o problema das bordas pode
ser a duplicação das mesmas ou o preenchimento com um valor
constante.

Uma aplicação muito conhecida que implementa a abordagem Stencil é o
#+BEGIN_LaTeX
\textit{Heat Transfer}
#+END_LaTeX
, na qual utiliza-se uma matriz base para representar uma placa
metálica e outra matriz menor que pode ser chamada de matriz de
convolução. Essa matriz de convolução atua sobre cada elemento da
matriz base, a fim de calcular a sua temperatura. Esse procedimento é
realizado inúmeras vezes para cada célula, de acordo com o número de
iterações definido.

*** Mapeamento

Mapeamento é um tipo de aplicação paralela muito desenvolvida quando se
utiliza o padrão OpenMP, especialmente quando paraleliza-se laços
"for". Ao definir os "pragmas", indica-se ao compilador aonde iniciará
a divisão do fluxo principal de execução em vários fluxos de
processamento (threads). A seguir no código \ref{lst.mm} é apresentado
um exemplo da técnica de Mapeamento, utilizando a biblioteca OpenMP em um problema
de multiplicação de matrizes.

#+LaTeX: \lstset{language=C,caption={Multiplicação de matrizes usando Mapeamento \cite{Krause2016}.},label=lst.mm}
#+BEGIN_LaTeX
\begin{lstlisting}
/*Multiplicacao das matrizes matA e matB*/
int i,j,k;
double tmp=0.0;

#pragma omp parallel for private(i,j,k)
for(i=0;i < size; i++) {
  for(j=0;j < size; j++) {
	  tmp=0;
	  for(k=0; k < size; k++) {
	    tmp = tmp + A[i * size + k] * B[k * size + j];
    }
	    R[i * size + j] = tmp;
	}
}
\end{lstlisting}

#+END_LaTeX

A abordagem tradicional de multiplicação de matrizes utiliza três
laços aninhados, o primeiro que percorre as linhas da matriz, o mais
interno permite o deslocamento nas colunas e o terceiro laço permite
passar por cada elemento da linha e da coluna desejada. Na
implementação do exemplo \ref{lst.mm}, a diretiva "pragma omp parallel
for" sinaliza o momento em que ocorrerá o disparo das threads, aonde
cada thread receberá do processo principal "x" iterações do primeiro
laço, ou seja, a tarefa de percorrer "x" linhas da matriz. Cada thread
executará o mesmo código, mas o índice "i" será diferente para cada
thread para que elas realizem o mesmo trabalho em localizações
diferentes da matriz.

*** Redução

Geralmente esse tipo de implementação envolve a combinação de pequenas
soluções obtidas a partir do processamento de partes de uma coleção de
elementos de entrada. A saída desse tipo de implementação é um
resultado único, o qual foi calculado por processamentos
consecutivos. Na Figura \ref{fig.reduction} é possível visualizar um
exemplo para ilustrar essa abordagem.

#+BEGIN_LaTeX
\begin{figure}[!htb]
\caption{Exemplo de Redução.}
\centering
\includegraphics[width=.40\linewidth]{./img/applicationReduction.pdf}
\label{fig.reduction} 
\end{figure}
#+END_LaTeX

Um exemplo de algoritmo de redução é o algoritmo para calcular o
número de Fibonacci, utilizando tarefas em OpenMP, essa implementação
pode ser visualizada no código \ref{lst.fib}. Esse algoritmo apresenta
uma abordagem recursiva, na qual as duas soluções obtidas a cada etapa
da recursão são somadas em uma apenas. O recurso da diretiva "omp
task" permite que realizar uma concorrência daquela tarefa dentre as
threads, as quais realizam o trabalho e após isso concorrem pela
próxima tarefa. A diretiva de sincronização é simbolizada com o
"pragma omp taskwait", fazendo com que as threads que terminaram as
duas tarefas responsáveis por "x" e "y", esperem uma pela outra para
realizar o cálculo "x + y". 

#+LaTeX: \lstset{language=C,caption={Fibonacci implementado usando tarefas OpenMP \cite{addison2009openmp}.},label=lst.fib}
#+BEGIN_LaTeX
\begin{lstlisting}
int fib(int n) {
    int x, y;
    if (n < 2)
        return n;
    else {
        #pragma omp task shared(x)
            x = fib(n - 1);
        #pragma omp task shared(y)
            y = fib(n - 2);
        #pragma omp taskwait
            return x + y;
    }
}
\end{lstlisting}

#+END_LaTeX

** Balanceamento de Carga

\citeonline{Li2005} definem balanceamento de carga como uma ação que
permite dividir a carga de trabalho da aplicação para vários
processadores, máquinas ou threads, a fim de obter o aumento de
desempenho em uma aplicação paralela. A carga de trabalho nesse
contexto pode ser a divisão de dados ou tarefas, o que está
relacionado diretamente com o tipo de aplicação a ser paralelizada,
por exemplo, em uma aplicação Stencil, o balanceamento de carga pode
ser a divisão da matriz base utilizada pela aplicação, assim cada
processo/thread atuará sobre determinadas regiões da mesma matriz
base. Outra abordagem de balanceamento de carga para uma aplicação
Stencil, poderia ser a divisão das iterações realizadas sobre
determinado elemento da matriz. 

*** Balanceamento Estático

O balanceamento de carga estático leva em consideração um conhecimento
prévio da plataforma de execução (características de máquina) e da
aplicação. A divisão da carga de trabalho ocorre antes da computação,
fazendo com que esse tipo de técnica possua um baixo overhead, quando
comparada com o balanceamento dinâmico \cite{Li2005}. 

Para memória compartilhada, utilizando OpenMP é possível informar o
tipo de balanceamento que será realizado na aplicação. No código
\ref{lst.static} é possível visualizar um exemplo de algoritmo de
multiplicação de matrizes que utiliza um escalonamento estático. Como
a carga é conhecida, nesse problema é possível obter um bom desempenho
com esse tipo de escalonador, visto que cada thread receberá um número
de iterações a serem realizadas sobre determinadas partes da matriz,
as quais são configuradas pelas variáveis privadas em que cada thread
realizará o seu trabalho. 

#+LaTeX: \lstset{language=C,caption={Uso de escalonador estático com OpenMP.} ,label=lst.static}
#+BEGIN_LaTeX
\begin{lstlisting}
#pragma omp parallel for private(i,j,k,tmp) schedule(static)
    for(i=0;i < size; i++) {
		for(j=0;j < size; j++) {
			tmp=0;
			for(k=0; k < size; k++)
				tmp = tmp + A[i][k] * B[k][j];
			R[i][j] = tmp;
		}
	}
\end{lstlisting}


#+END_LaTeX

*** Balanceamento Dinâmico

Diferente do balanceamento de carga estático, aonde a carga é
homogênea e conhecida, no balanceamento de carga dinâmico a carga é
heterogênea e geralmente não conhecida. Isso exige um comportamento
adaptativo do escalonador, fazendo com que ele decida com base nas
mudanças da aplicação e da plataforma de execução, qual é a melhor
opção de balanceamento para melhorar o desempenho da aplicação
\cite{Li2005}. 

O conjunto de Mandelbrot é um exemplo de algoritmo onde ocorre um
balanceamento de carga dinâmico. Esse algoritmo consiste no cálculo de
quais pontos do plano fazem parte do conjunto de Mandelbrot, em cada
ponto do plano (imagem) são realizados vários cálculos, com várias
iterações, fazendo com que a carga seja desbalanceada entre as threads
\cite{chandra2001parallel}. 

** Comportamentos de Aplicações
*** Memory-bound
*** CPU-bound
*** IO-bound

#+BEGIN_LaTeX
%\begin{figure}[!htb]
%\caption{JavaCC's file generation flow}
%\centering
%\includegraphics[width=.85\linewidth]{./img/javaccex.pdf}
%\label{fig.javaccex} 
%\\\source
%\end{figure}
#+END_LaTeX

* Trabalhos Relacionados
\label{chapter.relatedwork}

A coleta dos trabalhos relacionados foi realizada utilizando a técnica
chamada mapeamento sistemático da literatura \cite{Kitchenham2007}. Essa 
técnica permite realizar um estudo prévio sobre a literatura com uma 
boa cobertura, tendo por base um protocolo de pesquisa para seleção 
dos artigos. O protocolo definido para investigar o estado da arte pode ser visualizado na Tabela \ref{table:protocoloDePesquisa}.

#+BEGIN_LaTeX
\begin{table}[!htb]
\centering
\caption{Protocolo de Pesquisa}\label{table:protocoloDePesquisa}
\vspace{0.5cm}
\begin{tabular}{|l|} 
\hline
\textbf{Critérios de Seleção} \\
\hline
- publicados acima de 2005 \\
- artigos de bases confiáveis, revistas, periódicos e conferências \\
- trabalho deve apresentar uma metodologia consistente, com uma \\ 
descrição detalhada dos experimentos \\
\hline
\textbf{Critério de Inclusão} \\
\hline
- trabalhos destinados a redução do consumo de energia de aplicações \\
paralelas, distribuídas e sequenciais \\
\hline
\textbf{Critérios de Exclusão} \\
\hline
- artigos com o número menor ou igual a 6 páginas \\
- artigos não escritos em inglês \\
\hline
\textbf{Palavras-chave} \\
\hline
``memory-bound'' + ``behavior'' + \\ 
``applications'' + ``power consumption'' + \\ 
``hpc'' \\
\hline
\textbf{Questão de Pesquisa} \\
\hline
- Quais são as abordagens/técnicas que permitem diminuir a redução de \\
energia de aplicações, levando em consideração o comportamento de aplicações? \\
\hline
\end{tabular}
\end{table}
#+END_LaTeX

Não existe uma solução definitiva para detectar se uma região de
código é mais memory-bound ou CPU-bound. Alguns trabalhos focam mais
na detecção de fases para aplicações sequenciais
\cite{spiliopoulos2012power}, outros se concentram mais na perspectiva
de aplicações distribuídas \cite{freeh2005exploring} e paralelas
\cite{laurenzano2011reducing, millani2016fr}. 

\citeonline{spiliopoulos2012power} apresentam uma ferramenta chamada
Power-Sleuth que é capaz de fornecer uma descrição detalhada do
comportamento de uma aplicação quando executada em determinada
frequência. Esse trabalho utiliza três técnicas fundamentais para
compreender o comportamento de um programa, detecção de fases, modelo DVFS (
#+BEGIN_LaTeX
\textit{Dynamic Voltage and Frequency Scaling}
#+END_LaTeX
) e modelos de correlação. A abordagem desenvolvida pelos autores
identificam as fases da aplicação utilizando uma biblioteca chamada
ScarPhase que utiliza o histórico de execução da
aplicação, agrupando em fases, as funções do programa que possuem um
comportamento similar (acessos a memória, taxa de misses, entre
outros). Esse artigo investiga apenas aplicações sequenciais, nessa
perspectiva a identificação de áreas de regiões memory-bound podem ser
obtidas em uma granularidade mais grosseira no intervalo entre
amostras. Já para aplicações paralelas, como são executadas sobre
diferentes fluxos de processamento, cada fluxo pode possuir um
comportamento distinto de acordo com o balanceamento da carga da
aplicação, até mesmo para mesmas regiões de código.

\citeonline{laurenzano2011reducing} definem uma
abordagem automatizada que permite selecionar a frequência mais
adequada de processador para determinado laço do programa. A
frequência do processador é escolhida utilizando como base uma análise
estática (realizada antes da execução) e outra análise realizada 
durante o tempo de execução da aplicação, utilizando os rastros
obtidos. Os autores utilizaram vários benchmarks, tendo como
base de execução o framework chamado pcubed (
#+BEGIN_LaTeX
\textit{PMaC's Performance and Power benchmark}
#+END_LaTeX
) que permite explorar diferentes comportamentos de laços de
interações, a fim de definir uma caracterização para a máquina alvo. A
caracterização da máquina define valores como consumo de potência,
desempenho, padrões de execução e frequências de processador. Os
resultados obtidos no experimento podem ser utilizados posteriormente
como base de conhecimento, assim é possível visualizar o comportamento
do consumo de energia quando se ajusta os fatores de caracterização da
máquina. Dentre os resultados obtidos pelo trabalho, o melhor foi a
redução de até 10,6% no consumo de energia. 

Diferente de \citeonline{laurenzano2011reducing},
\citeonline{freeh2005exploring} apresentam uma abordagem voltada à memória
distribuída para aplicações MPI. Essa abordagem encontra a melhor
frequência para cada nó, a frequência é definida por uma heurística
chamada ``gear'' que define um ganho entre consumo de energia e
desempenho. Com o trace obtido a partir de uma pré-execução, a
abordagem define blocos (
#+BEGIN_LaTeX
 \textit{Basic blocks}
#+END_LaTeX
) que realizam operações comuns, depois dessa classificação é obtido
as fases da aplicação que correspondem a junção desses blocos. Para
cada bloco é definido o ganho desejado. O ganho é a melhor
configuração encontrada (frequência de processador) entre consumo de
energia e desempenho para determinada fase da aplicação. Os resultados
apresentam um ganho considerável para mais da metade das aplicações
executadas, o melhor resultado obtido foi a redução do consumo de
energia em 9% e do tempo de execução em 1%.

Para aplicações paralelas escritas com OpenMP,
\citeonline{millani2016fr} apresentam uma abordagem que analisa as
regiões paralelas de um programa, utilizando uma análise detalhada com a técnica 
#+BEGIN_LaTeX
\textit{Design of Experiments}
#+END_LaTeX
 e 
#+BEGIN_LaTeX
\textit{Screening Design}.
#+END_LaTeX
Os autores realizaram experimentos com sete benchmarks, através das
execuções eles concluíram que é possível obter um ganho considerável
de energia e desempenho com a utilização da abordagem, dependendo das
características comportamentais da aplicação. A técnica consiste na
instrumentação manual de código para assinalar as regiões paralelas no
código fonte. Diferente disso, o foco desse trabalho é direcionado na
identificação automática dessas regiões paralelas, baseando-se em
contadores de hardware específicos.

** Detecção de Regiões Memory-bound	

Cada um dos trabalhos analisados utiliza uma abordagem diferenciada
para analisar o comportamento de uma aplicação, classificando trechos
de execução mais memory-bound, partes em
que a aplicação espera por IO (entrada ou saída de dados), entre
outros comportamentos. Como o alvo desse trabalho é a detecção de regiões
memory-bound de aplicações paralelas, para que seja possível reduzir o
consumo de energia de toda aplicação pelo uso da técnica DVFS. Nessa
seção será abordado as medidas utilizadas pelas técnicas, ao
definir o comportamento memory-bound de um programa. Na Tabela
\ref{table:comparativoDeTrabalhos} é possível visualizar um
comparativo entre as abordagens. 

#+BEGIN_LaTeX
\begin{table}[h]
\centering
\caption{Comparativo de trabalhos}\label{table:comparativoDeTrabalhos}
\vspace{0.5cm}
\begin{tabular}{rrr} 
\citeonline{laurenzano2011reducing} & \citeonline{spiliopoulos2012power} & \citeonline{freeh2005exploring} \\
\hline
Tamanho de Array & Miss na LLC & Miss na L2 \\
Stride & Cycles &  Operações por Miss \\
Taxa de Hit & Stall Cycles & -\\
Operações de Memória & Latência de Memória & - \\
Operações de FP & Tempo de Reorder Buffer & - \\
Instruções por Laço & - & - \\
\end{tabular}
\end{table}

%\begin{table}[h]
%\centering
%\caption{Comparativo de trabalhos}\label{table:comparativoDeTrabalhos}
%\vspace{0.5cm}
%\begin{tabular}{r|lr} 
%Trabalho & Medidas & Overhead \\
%\hline
%\citeonline{spiliopoulos2012power} & Miss na LLC \\ Cycles & 2% \\
% & Cycles &  \\
% & Stall Cycles & \\
% & Latência de Memória & \\
% & Tempo de Reorder Buffer & \\
%\citeonline{freeh2005exploring} & Operações por Miss & - \\
% & Miss na L2 &  \\
%\citeonline{laurenzano2011reducing} & Tamanho de Array & 4x mais lento \\
% & stride & \\
% & Taxa de hit & \\
% & Número de Operações de Memória & \\
% & Número de Operações de FP & \\
% & Instruções por Laço & \\
%\citeonline{millani2016fr} & - & - \\
%\end{tabular}
%\end{table}
#+END_LaTeX

Dentre os trabalhos, pode-se visualizar que
\citeonline{laurenzano2011reducing} utilizam mais medidas que as outras
técnicas, a fim de compreender o comportamento da aplicação em uma
granularidade mais fina, analisando além das fases da aplicação onde
ocorre mais processamento, também os padrões de acesso à memória. Já
\citeonline{spiliopoulos2012power} apresentam uma abordagem diferente,
analisando também o tempo em que o 
#+BEGIN_LaTeX
\textit{Reorder Buffer}
#+END_LaTeX
 leva para encher. A abordagem que utiliza menos medidas é a de
 \citeonline{freeh2005exploring}, a qual analisa apenas o índice de cache
 misses para o segundo nível de cache, já que em sua abordagem é
 levado em consideração uma aplicação distribuída, o grão é o próprio
 nó de processamento.

* Experimentos
\label{chapter.experiments} 


#+BEGIN_LaTeX
%\begin{table}[!htb]
%\caption{Experimental Units description}
%\label{tab.machines}
%\centering
%\begin{tabularx}{\linewidth}{lXXX}\toprule
%                        &   {\bf Luiza}         & {\bf Orion1}         & {\bf Guarani}    %\\\toprule
%Processor                &  Intel Core i7        & Xeon E5-2630         & Intel Core i5-2400   %\\
%CPU(s)                   &  1                    & 2                    & 1       \\
%Cores per CPU            &  4                    & 6                    & 4             \\
%Max. Freq.               &  2.7 GHz              & 2.30GHz              & 3.10GHz       \\
%L1d/L1i Cache            & 32/32KBytes           & 32/32KBytes          & 32/32KBytes  \\     
%L2 Cache                 & 256KBytes             & 256KBytes            & 256KBytes    \\
%L3 Cache                 & 6MBytes               & 15MBytes              & 6MBytes         \\
%Memory                   & 16GBytes              & 32GBytes             & 20GBytes      %\\\midrule
%OS                       & OSX 10.10.5           & Ubuntu 12.04.5       & Debian 4.3.5-1 \\
%\bottomrule\end{tabularx}
%\end{table}
#+END_LaTeX

#+LATEX: \bibliography{References}


\appendix
