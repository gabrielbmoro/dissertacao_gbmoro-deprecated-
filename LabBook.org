#+TITLE: LabBook
#+AUTHOR: Gabriel Bronzatti Moro and Lucas M. Schnorr
#+LATEX_HEADER: \usepackage[margin=2cm,a4paper]{geometry}
#+STARTUP: overview indent
#+TAGS: Gabriel(G) Lucas(L) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)
#+mode: org
#+coding: utf-8

Esse documento está em pt-br

* [00:18:39; 02.07.2016] Tarefas da Primeira Reunião com o Professor Lucas :Gabriel:
** Principais trabalhos relacionados - Artigo do Luis Felipe

|---------------------+---------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------|
| *Autores*             | *Título*                                                                                            | *Objetivo*                                                                                                                                                     | *Metodologia*                                                                                                                                                                                                                 | *Benchmark, Ferramenta ou Tecnologia*                                | *Resultados*                                                                                                                                                                                                              | *Observação*                                                                                                                                                                       | *Diferença do nosso trabalho*                                      |
|                     |                                                                                                   |                                                                                                                                                              |                                                                                                                                                                                                                             |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|                     |                                                                                                   |                                                                                                                                                              |                                                                                                                                                                                                                             |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|---------------------+---------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------|
| Laurenzano et al.   | =Reducing energy usage with memory and with memory and computation-aware dynamic frequency scaling= | - Abordagem que permite selecionar *por laço* a melhor frequência de clock. O critério de frequência mais adequado está entre desempenho e consumo de energia. | - Instrumentação realizada através da utilização da ferramenta PEBIL toolkit                                                                                                                                                | - Benchmark própio =pcubed= (PMaC's Performance and Power benchmark) | - Os principais resultados adquiridos pelos autores foi a economia de cerca de 7,6% de energia para a primeira plataforma de execução (Intel Xeon E5530) e para a segunda plataforma (AMD Opteron 8380) cerca de 10,6%. | - O autor não chega a definir, mas menciona que uma aplicação =memory-bound= depende primeiramente da proximidade, tamanho e do Speedup disponível com as operaçoes sob a memoria. | - Foco em aplicações paralelas\ (OpenMP)                         |
|                     |                                                                                                   |                                                                                                                                                              | - Uso da biblioteca cpu-freq para alterar a frequência do processador                                                                                                                                                       |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  | - Regiões paralelas dentro da abordagem fork-join                |
|                     |                                                                                                   |                                                                                                                                                              | - Experimento: os parâmentos levados em consideração para aplicação são: taxa de hit dos diferentes níveis de cache, operações de ponto-flutuante (FP) sob a memória e a media de computação de operações sob FP e inteiro. |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|                     |                                                                                                   |                                                                                                                                                              | - A plataforma de execução escolhida por eles *permite a alteração da frequência independentemente de cada core* (frequências avaliadas no experimento 1.6, 1.73, 1.86, 2, 2.13, 2.26, 2.39 e 2.40 GHz).                      |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|---------------------+---------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------|
| Freeh et al.        | =Using Multiple Energy Gears in MPI Programs on a Power-Scalable Cluster=                           | - Abordagem que tem por objetivo encontrar a *frequência adequada para cada fase da aplicação MPI*, de acordo com a heurística alvo (energia e/ou desempenho). | - A aplicação é dividida em n fases e diferentes gears (microprocessadores), para cada gear é executado as n fases da aplicação                                                                                             | - Benchmark do =NAS=                                                 | - Os resultados apresentam a partir da combinação adequada de frequências para os benchmarks executados é possível obter um bom ganho de energia caso fosse utilizado apenas a mesma frequência nos diferentes nós.     | - Os autores introduzem a métrica =OPM (Operations per Miss)=, a qual permite verificar a pressão de memória de uma aplicação ou de uma fase.                                      | - Foco em aplicações paralelas de memória compartilhada (OpenMP) |
|                     |                                                                                                   |                                                                                                                                                              | - Resultados obtidos de tempo e energia                                                                                                                                                                                     |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  | - Trabalho concentra-se em apenas um nó                          |
|                     |                                                                                                   |                                                                                                                                                              | - O cluster aonde foi executado os experimentos permitia a configuração de até 10 diferentes frequências.                                                                                                                   |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|                     |                                                                                                   |                                                                                                                                                              |                                                                                                                                                                                                                             |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|                     |                                                                                                   |                                                                                                                                                              |                                                                                                                                                                                                                             |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|                     |                                                                                                   |                                                                                                                                                              |                                                                                                                                                                                                                             |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|                     |                                                                                                   |                                                                                                                                                              |                                                                                                                                                                                                                             |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|---------------------+---------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------|
| Spiliopoulos et al. | =Power-Sleuth: A Tool for Investigating your Program's Power Behavior=                              | - Melhorar o desempenho e o consumo de energia alterando as frequências por fase da aplicação.                                                               | - Aplicação dividida em fases, durante a execução são coletadas informações sobre essas fases para estimar o consumo de energia de cada fase.                                                                               | - ScarPhase para caracterizar cada fase da aplicação               | - Os resultados do artigo permitem analisar apenas a acurácia da ferraemnta com as medidas de potência reais                                                                                                            |                                                                                                                                                                                  | - Foco em aplicações paralelas                                   |
|                     |                                                                                                   |                                                                                                                                                              | - Após a análise do comportamento da execução a ferramenta desenvolvida pelos autores é capaz de alternar a frequência de cada fase para melhorar o consumo de energia e o desempenho                                       |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  | - Nossa divisão do programa é em regiões e não fases             |
|                     |                                                                                                   |                                                                                                                                                              | - A abordagem utiliza um modelo de desempenho DVFS, um modelo de correlação de capacitânciae uma técnica para detectar as fases da aplicação.                                                                               |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|---------------------+---------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------|

- Alguns trabalhos possíveis: 

*** Caracterização de aplicações paralelas implementadas em OpenMP
	=Motivativação=: Análise do comportamento da aplicação paralela
	via contadores de hardware. A partir disso será possível
	visualizar o perfil de execução da aplicação pelos contadores
	de hardware. A técnica pode ser usada como uma pré-execução.

	=Metodologia=: Uso da abordagem =DoE= (Desing of Experiments) para
	projetar o experimento e analisar os resultados. Freeh et
	al. possui um trabalho similar, mas o diferencial do nosso
	trabalho é a metodologia e o uso da técnica DoE.
        
*** Modelagem de energia para aplicações híbridas OpenMP/MPI
	=Motivativação=: Contabilizar a energia gasta em cada regiÃ£o
	paralela, mas também a energia gasta dentro do nó (intra-node)
	e a comunicação dentro do nó (se existir) e a comunicação fora
	do nó. Esse trabalho se concentraria na estimativa da energia
	total gasta pela aplicação híbrida implementada em
	OpenMP/MPI.

	=Metodologia=: A metodologia pode ser a seguinte (uma abordagem
	button-up):
        a) Estimar a energia de cada região paralela (usando
           contadores de hardware em diferentes nós);
        b) Estimar a energia da aplicação (fora do limite fork-join);
        c) Estimar a energia da aplicação na comunicação intra-nó;
        d) Estimar a energia da comunicação inter-node (fora do nó).

  =Results=: O resultado seria a estimativa de energia da aplicação
  híbrida como um todo e também a energia gasta em cada nó. Isso pode
  oferecer uma estimativa correta de energia para essas aplicações, a
  partir da informação obtida o desenvolvedor poderá otimizar alguma
  parte da sua aplicação.
* [19:10:05; 05.07.2016] Reunião Semanal com o Professor Lucas :Gabriel:Lucas:
** Definição do assunto da dissertação
	=Objetivo=: Detectar as fases da aplicação utilizando contadores
	de hardware.

    =Ferramentas a serem investigadas=: ScoreP (com PAPI), ExtraE e
    TAU. Também procurar como realizar uma medição utilizando
    contadores de hardware along time.

    =Tarefas=: 
    	a) fazer os trabalhos relacionados direcionando-os na
    temática ``Parallel Application Phase Detection'';
    	b) implementar a detecção de fase usando contadores do PAPI +
           ScoreP;
       	    b.1) A parte =along_time=
		c) Definir as fases, aplicar conhecimento para reduzir energia
    
* [22:15:57; 08.07.2016] Configuração de Ambiente Scorep e PAPI     :Gabriel:
** Instalação do PAPI
#+begin_src sh :results output :exports both
cd $HOME/Downloads/
wget http://icl.cs.utk.edu/projects/papi/downloads/papi-5.4.3.tar.gz
tar -vzxf papi-5.4.3.tar.gz
cd papi-5.4.3/src/
./configure
make
sudo make install
#+end_src

- Verificando se a instalação foi realizada com sucesso

#+begin_src sh :results output :exports both
cd /usr/local/lib/
ls | grep -i libpapi
#+end_src

#+RESULTS:
: libpapi.a
: libpapi.so
: libpapi.so.5
: libpapi.so.5.4.3
: libpapi.so.5.4.3.0

#+begin_src sh :results output :exports both
cd /usr/local/include/
ls | grep -i papi.h
#+end_src

#+RESULTS:
: f77papi.h
: f90papi.h
: fpapi.h
: papi.h

** Instalação do Scorep

- Um dos pré-requisitos de instalação do Scorep e a instalação do
  =Qt_app=.

#+begin_src sh :results output :exports both
cd $HOME/Downloads/
wget http://download.qt.io/official_releases/online_installers/qt-unified-linux-x64-online.run
./qt-unified-linux-x64-online.run
#+end_src

#+RESULTS:

#+begin_src sh :results output :exports both
cd $HOME/Programs/
wget http://www.vi-hps.org/upload/packages/scorep/scorep-2.0.2.tar.gz
tar -vxf scorep-2.0.2.tar.gz
rm scorep-2.0.2.tar.gz
cd scorep-2.0.2/
./configure --prefix=$HOME/Programs/scorep-2.0.2/ --enable-papi  --with-papi-lib=/usr/local/lib/ --with-papi-header=/usr/local/include/
make
sudo make install
#+end_src

#+RESULTS:

#+BEGIN_EXAMPLE

#+END_EXAMPLE

- Compilando aplicação com OpenMP com Scorep

#+begin_src sh :results output :exports both
cd benchmarks/MM/
$HOME/Programs/scorep-2.0.2/bin/scorep gcc -fopenmp -O2 hpcelo.c continuos.c -o continuos_sp
ls
#+end_src

#+RESULTS:
#+begin_example
continuos.c
continuos_sp
continuosT.c
hpcelo.c
hpcelo.h
Makefile
normal.c
normalT.c
tiling.c
tilingT.c
#+end_example

- Habilitando o trace para a execução da aplicação:

#+begin_src sh :results output :exports both
cd benchmarks/MM/
export SCOREP_ENABLE_PROFILING=true
export SCOREP_ENABLE_TRACING=true
export SCOREP_TOTAL_MEMORY=2G
export SCOREP_METRIC_PAPI=
export SCOREP_METRIC_PAPI_PER_PROCESS=PAPI_L1_TCA,PAPI_L2_TCA
export SCOREP_METRIC_RUSAGE_PER_PROCESS=all
export SCOREP_MEMORY_RECORDING=true
export SCOREP_EXPERIMENT_DIRECTORY=continuosExecution 
./continuos_sp 1000
ls
#+end_src

#+RESULTS:
#+begin_example
HPCELO:1.065932
continuos.c
continuosExecution
continuos_sp
continuosT.c
hpcelo.c
hpcelo.h
Makefile
normal.c
normalT.c
tiling.c
tilingT.c
#+end_example
* [16:22:11; 14.07.2016] Conversa semanal com Gabriel         :Gabriel:Lucas:

Com relação a entrada:
- [[*DefiniÃ§Ã£o do assunto da dissertaÃ§Ã£o][Definição do assunto da dissertação]]

Rastreamento com scorep 2.0.2, configurado da seguinte maneira:

#+BEGIN_EXAMPLE
./configure --prefix=/home/schnorr/install/scorep-2.0.2/ --enable-papi  --with-papi-lib=/usr/local/lib/ --with-papi-header=/usr/local/include/
#+END_EXAMPLE

Na saída do config.log, temos:

#+BEGIN_EXAMPLE
(...)
    Score-P (backend):
      C99 compiler used:        gcc
      Pthread support:          yes, using gcc -pthread 
      compiler constructor:     yes, using attribute syntax
      TLS support:              yes, using __thread
      PAPI support:             yes
      metric perf support:      yes
      Unwinding support:        yes
        libunwind support:      yes, using -D_GNU_SOURCE -lunwind
      Sampling support:         yes, using -D_GNU_SOURCE, sa_sigaction
      getrusage support:        yes
      RUSAGE_THREAD support:    yes, using -D_GNU_SOURCE
      dlfcn support:            yes, using -ldl
(...)
#+END_EXAMPLE

Depois de configurar as seguintes variáveis de ambiente:

#+BEGIN_EXAMPLE
export SCOREP_ENABLE_TRACING=true
export SCOREP_METRIC_PAPI=PAPI_L1_TCM
#+END_EXAMPLE

O programa foi executado com =sudo -E=. O argumento =-E= foi importante
para que as variáveis de ambiente do shell corrente sejam transferidas
para o shell que o sudo criará para lançar a aplicação. Precisamos
utilizar =sudo= pois a aplicação necessita acessar contadores de
hardware que são capazes de ser lidos pelo superusuário. Uma forma
melhor de fazer isto é utilizar =setcap=.

Depois de executar o programa que foi compilado com =scorep gcc=,
podemos ver a evolução da métrica =PAPI_L1_TCM= ao longo do tempo
através do seguinte comando:
- a terceira coluna é o timestamp onde o valor da métrica foi
  observado
- o valor da métrica aparece depois do UINT64

No caso de =PAPI_L1_TCM= o valor da métrica é a quantidade de vezes que
ocorreu cache miss na cache L1.

#+BEGIN_EXAMPLE
schnorr@guarani:~/svn/hpcelo-gabriel/MM/src$ /home/schnorr/install/scorep-2.0.2/bin/otf2-print scorep-20160714_1559_2932482742715837/traces.otf2 | grep 12884901888 | grep METRIC
METRIC                           12884901888     2932482706525714  Metric: 0, 1 Values: ("PAPI_L1_TCM" <8>; UINT64; 571)
METRIC                           12884901888     2932482706534678  Metric: 0, 1 Values: ("PAPI_L1_TCM" <8>; UINT64; 776)
METRIC                           12884901888     2932482732253601  Metric: 0, 1 Values: ("PAPI_L1_TCM" <8>; UINT64; 930)
METRIC                           12884901888     2932482732318445  Metric: 0, 1 Values: ("PAPI_L1_TCM" <8>; UINT64; 1119)
METRIC                           12884901888     2932482732323234  Metric: 0, 1 Values: ("PAPI_L1_TCM" <8>; UINT64; 1181)
METRIC                           12884901888     2932482732325389  Metric: 0, 1 Values: ("PAPI_L1_TCM" <8>; UINT64; 1192)
...
#+END_EXAMPLE

Quais são os contadores que devem ser medidos?
- Difícil responder, primeiro precisamos investigar quais contadores
  poderiam (no caso de valores altos) representar uma aplicação
  CPU-bound e uma aplicação MEMORY-bound.
- Procurar na literatura artigos que consigam definir uma eventual
  relação que exista entre CPU-bound e determinados contadores de
  hardware (e o equivalente para algo MEMORY-bound)

Tarefas:
- Medir ao longo do tempo e com scorep o máximo possível de contadores
  - Eventualmente todos os contadores disponíveis
- Utilizar a aplicação de MM desenvolvida por ti
* [23:39:31; 14.07.2016] Execução do benchmark MM com PAPI via Scorep :Gabriel:

- Compilação, utilizando o make file com a diretiva =scorep gcc=:

#+begin_src sh :results output :exports both
cd benchmarks/MM/
make
ls
#+end_src

#+RESULTS:
#+begin_example
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o normal_seq.o -c normal.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o normal_seq hpcelo.c normal_seq.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o normal_par.o -c normal.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o normal_par hpcelo.c normal_par.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o continuos_seq.o -c continuos.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o continuos_seq hpcelo.c continuos_seq.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o continuos_par.o -c continuos.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o continuos_par hpcelo.c continuos_par.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o tiling_seq.o -c tiling.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o tiling_seq hpcelo.c tiling_seq.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o tiling_par.o -c tiling.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o tiling_par hpcelo.c tiling_par.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o normal_seqT.o -c normalT.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o normal_seqT hpcelo.c normal_seqT.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o normal_parT.o -c normalT.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o normal_parT hpcelo.c normal_parT.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o continuos_seqT.o -c continuosT.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o continuos_seqT hpcelo.c continuos_seqT.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o continuos_parT.o -c continuosT.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o continuos_parT hpcelo.c continuos_parT.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o tiling_seqT.o -c tilingT.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o tiling_seqT hpcelo.c tiling_seqT.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o tiling_parT.o -c tilingT.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o tiling_parT hpcelo.c tiling_parT.o
continuos.c
continuos_par
continuos_par.o
continuos_parT
continuos_parT.o
continuos_seq
continuos_seq.o
continuos_seqT
continuos_seqT.o
continuosT.c
hpcelo.c
hpcelo.h
Makefile
normal.c
normal_par
normal_par.o
normal_parT
normal_parT.o
normal_seq
normal_seq.o
normal_seqT
normal_seqT.o
normalT.c
tiling.c
tiling_par
tiling_par.o
tiling_parT
tiling_parT.o
tiling_seq
tiling_seq.o
tiling_seqT
tiling_seqT.o
tilingT.c
#+end_example

#+begin_src sh :results output :exports both
cd benchmarks/MM/
export SCOREP_ENABLE_TRACING=true
export SCOREP_TOTAL_MEMORY=2G
export SCOREP_METRIC_PAPI=PAPI_L1_DCM,PAPI_L1_ICM,PAPI_L2_DCM
export SCOREP_METRIC_RUSAGE=ru_utime,ru_stime
export SCOREP_EXPERIMENT_DIRECTORY=exec1
./normal_parT 100
cd exec1/
/$HOME/Programas/scorep-2.0.2/bin/otf2-print traces.otf2
#+end_src

#+RESULTS:
#+begin_example

=== OTF2-PRINT ===
=== Events =====================================================================
Event                               Location            Timestamp  Attributes
--------------------------------------------------------------------------------
METRIC                                     0       79633289900948  Metric: 0, 5 Values: ("PAPI_L1_DCM" <8>; UINT64; 2890), ("PAPI_L1_ICM" <9>; UINT64; 7001), ("PAPI_L2_DCM" <10>; UINT64; 1770), ("ru_utime" <11>; UINT64; 4000), ("ru_stime" <12>; UINT64; 12000)
ENTER                                      0       79633289900948  Region: "main" <16>

#+end_example

* DONE [09:25:09; 15.07.2016] Criação do script para execução do benchmark MM com PAPI via Scorep :Gabriel:

- State "DONE"       from "STARTED"    [2016-07-15 Sex 20:35]
- State "STARTED"    from              [2016-07-15 Sex 10:14]
#+begin_src sh :results output :exports both :tangle benchmarks/MM/scriptSimulation.bash
#!bin/bash

apps=( 
    "continuos_par" 
    "continuos_parT" 
    "normal_par" 
    "normal_parT" 
    "tiling_par" 
    "tiling_parT" 
)

inputSizes=( 
    50 
    60 
    80 
    100 
)

export SCOREP_ENABLE_TRACING=true
export SCOREP_METRIC_PAPI=PAPI_L1_DCM,PAPI_L1_ICM,PAPI_L1_TCM,PAPI_L2_DCM,PAPI_L2_ICM,PAPI_L2_TCM,PAPI_L2_ICA,PAPI_L3_ICA
export SCOREP_METRIC_RUSAGE=ru_utime,ru_stime


for j in ${apps[@]}
do 
  for i in ${inputSizes[@]}
  do
    echo "Running app: $j size: $i"
    export SCOREP_EXPERIMENT_DIRECTORY="exec_$jsize$i"
    sudo -E ./$j $i
  done
done

#+end_src

O script de execução está rodando corretamente, os contadores PAPI
utilizados foram escolhidos de acordo com a disponibilidade da minha
máquina pessoal. Estou com problemas apenas na execução do algoritmo
=tiling=, isso Ã© porque o mesmo utiliza muito a memória principal para
otimizar o uso da cache. O erro que está acontecendo com o SCOREP é o
seguinte:

#+BEGIN_EXAMPLE
Running app: tiling_par size: 60
[Score-P] Trace buffer flush on rank 0.
[Score-P] Increase SCOREP_TOTAL_MEMORY and try again.
[Score-P] Trace buffer flush on rank 0.
[Score-P] Increase SCOREP_TOTAL_MEMORY and try again.
[Score-P] Trace buffer flush on rank 0.
[Score-P] Increase SCOREP_TOTAL_MEMORY and try again.
[Score-P] Trace buffer flush on rank 0.
[Score-P] Increase SCOREP_TOTAL_MEMORY and try again.
[Score-P] Trace buffer flush on rank 0.
[Score-P] Increase SCOREP_TOTAL_MEMORY and try again.
HPCELO:0.462356
#+END_EXAMPLE

- Vou mudar o script para aumentar o =SCOREP_TOTAL_MEMORY=:

#+begin_src sh :results output :exports both :tangle benchmarks/MM/scriptSimulation2.bash
#!bin/bash

apps=( 
    "continuos_par" 
    "continuos_parT" 
    "normal_par" 
    "normal_parT" 
    "tiling_par" 
    "tiling_parT" 
)

inputSizes=( 
    50 
    60 
    80 
    100 
)

export SCOREP_ENABLE_TRACING=true
export SCOREP_TOTAL_MEMORY=3G
export SCOREP_PAGE_SIZE=800000
export SCOREP_METRIC_PAPI=PAPI_L1_DCM,PAPI_L1_ICM,PAPI_L1_TCM,PAPI_L2_DCM,PAPI_L2_ICM,PAPI_L2_TCM,PAPI_L2_ICA,PAPI_L3_ICA
export SCOREP_METRIC_RUSAGE=ru_utime,ru_stime


for j in ${apps[@]}
do 
  for i in ${inputSizes[@]}
  do
    echo "Running app: $j size: $i"
    export SCOREP_EXPERIMENT_DIRECTORY="exec_$jsize$i"
    sudo -E ./$j $i
  done
done

#+end_src

Executando o script com a modificação no =SCOREP_TOTAL_MEMORY= para 3
gigabytes, ocorreu o seguinte erro:

#+BEGIN_EXAMPLE
[Score-P] Please report this to support@score-p.org. Thank you.
[Score-P] Try also to preserve any generated core dumps.
^CRunning app: tiling_parT size: 60
[Score-P] src/measurement/SCOREP_Memory.c:106: Fatal: Bug '!allocator': Cannot create memory manager for SCOREP_TOTAL_MEMORY=3221225472 and SCOREP_PAGE_SIZE=800000
#+END_EXAMPLE

Esse erro de acordo com os fÃ³runs Ã© devido a minha limitaÃ§Ã£o de
memÃ³ria principal. 

- Vou modificar o script para executar todos os algoritmos de
  multiplicação de matriz, exceto o =tiling=.

#+begin_src sh :results output :exports both :tangle benchmarks/MM/scriptSimulation3.bash
#!bin/bash

apps=( "continuos_par" "continuos_parT" "normal_par" "normal_parT" )

inputSizes=( 50 60 80 100 )

export SCOREP_ENABLE_TRACING=true
export SCOREP_METRIC_PAPI=PAPI_L1_DCM,PAPI_L1_ICM,PAPI_L1_TCM,PAPI_L2_DCM,PAPI_L2_ICM,PAPI_L2_TCM,PAPI_L2_ICA,PAPI_L3_ICA
export SCOREP_METRIC_RUSAGE=ru_utime,ru_stime


for j in ${apps[@]}
do 
  for i in ${inputSizes[@]}
  do
          export SCOREP_EXPERIMENT_DIRECTORY="exec_$j$i"
	    echo "Running app: $j size: $i"
	    sudo -E ./$j $i
  done
done

#+end_src

As pastas geradas foram:

#+begin_src sh :results output :exports both
cd benchmarks/MM/
ls | grep -i exec
#+end_src

#+RESULTS:
#+begin_example
exec_continuos_par100
exec_continuos_par50
exec_continuos_par60
exec_continuos_par80
exec_continuos_parT100
exec_continuos_parT50
exec_continuos_parT60
exec_continuos_parT80
exec_normal_par100
exec_normal_par50
exec_normal_par60
exec_normal_par80
exec_normal_parT100
exec_normal_parT50
exec_normal_parT60
exec_normal_parT80
#+end_example

O próximo passo é fazer um script para analisar esses dados e a partir
deles gerar um arquivo csv. Esse script deverá utilizar a saída da
ferramenta =otf2print= disponibilizada pelo =scorep=.
* WAITING [00:09:15; 16.07.2016] Análise dos resultados do experimento com PAPI - benchmark MM :Gabriel:
- State "WAITING"    from "STARTED"    [2016-07-18 Seg 12:07]
- State "STARTED"    from              [2016-07-16 SÃ¡b 14:24]

** Exportando o arquivo csv por thread
Primeiramente vou fazer um script teste para gerar o csv do arquivo
gerado na execução da versão =normal_par= com =80= de entrada. O script
vai ser criado em python, porque como são muitos dado

#+begin_src sh :results output :exports both
cd benchmarks/MM/exec_normal_par80/
/home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | awk '{ print $1,$2,$3,$4,$5,$8,$11,$12,$15,$16,$19,$20,$21,$24,$27,$28,$31 }' >> t.csv
#+end_src

#+RESULTS:

#+begin_src sh :results output :exports both
cd benchmarks/MM/exec_normal_par80/
sudo /home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | awk '{ print $1,$2,$3,$4,$5,$8,$11,$12,$15,$16,$19,$20,$21,$24,$27,$28,$31 }' >> t.csv
#+end_src

#+RESULTS:
|sh: 2: cannot create t.csv: Permission denied|

#+begin_src sh :results output :exports both
cd benchmarks/MM/
chmod 777 exec*
#+end_src

#+RESULTS:

- Vou tentar novamente com as permissões alteradas

#+begin_src sh :results output :exports both
cd benchmarks/MM/exec_normal_par80/
 /home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | sed 's/(//g' | sed 's/)//g' | sed 's/\"P/P/g' | sed 's/\"/,/g' | sed 's/C[[:space:]]/C,/g' | sed 's/[[:space:]]M/,M/g' | sed 's/[[:space:]]R/,R/g'  | sed 's/AVE[[:space:]]/AVE,/g' | sed 's/ER[[:space:]]/ER,/g' | awk '{ print $1,$3,$4,$5,$8,$11,$16,$19,$24,$27,$28,$31 }' >> ../execNormal80.csv
#+end_src

- Dessa maneira funcionou

O script vai funcionar da seguinte forma primeiramente vou filtrar
pela palavra thread, a fim de conhecer o identificador respectivo de
cada thread, da seguinte maneira:

#+begin_src sh :results output :exports both
cd exec_normal_par80/
/home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | awk '{ print $1,$2,$3,$4,$5,$8,$11,$16,$19,$24,$27,$28,$31 }' | grep -i thread

#+end_src

#+RESULTS:
#+begin_example
THREAD_FORK 0 148300136098648 Model: "OpenMP" Requested       
THREAD_TEAM_BEGIN 8589934592 148300136631927 Thread Team:        
THREAD_TEAM_BEGIN 12884901888 148300136632116 Thread Team:        
THREAD_TEAM_BEGIN 4294967296 148300136632125 Thread Team:        
THREAD_TEAM_BEGIN 0 148300136632758 Thread Team:        
THREAD_TEAM_END 4294967296 148300137791884 Thread Team:        
THREAD_TEAM_END 0 148300137794262 Thread Team:        
THREAD_TEAM_END 8589934592 148300137794587 Thread Team:        
THREAD_TEAM_END 12884901888 148300137827954 Thread Team:        
THREAD_JOIN 0 148300137838547 Model: "OpenMP"        
#+end_example

A partir dessa saída é possível visualizar o momento em que o fork
inicia e termina. Além disso é possível visualizar o identificador de
cada thread.

#+begin_src sh :results output :exports both :tangle benchmarks/MM/scriptAnalyseTest.sh
cd exec_normal_par80/
array=$(/home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | awk '{ print $1,$2,$3,$4,$5,$8,$11,$16,$19,$24,$27,$28,$31 }' | grep -i THREAD_TEAM_BEGIN | awk ' { print $2 } ')

threads=4

x=1

while [ $x -le $threads ];
do
      echo $array | cut -d ' ' -f$x
	x=$((x+1))
done

#+end_src

#+RESULTS:
: 8589934592
: 12884901888
: 4294967296
: 0

Agora vou utilizar um desses identificadores de thread para recuperar
as medidas obtidas pelos =contadores de hardware= para as regiões de
código daquela thread.

#+begin_src sh :results output :exports both
cd benchmarks/MM/exec_normal_par80/
/home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | sed 's/(//g' | sed 's/)//g' | sed 's/\"P/P/g' | sed 's/\"/,/g' | sed 's/C[[:space:]]/C,/g' | sed 's/[[:space:]]M/,M/g' | sed 's/[[:space:]]R/,R/g'  | sed 's/AVE[[:space:]]/AVE,/g' | sed 's/ER[[:space:]]/ER,/g' | awk '{ print $1,$2,$3,$4,$5,$8,$11,$16,$19,$24,$27,$28,$31 }' | grep -i 8589934592
#+end_src

#+RESULTS:
#+begin_example
THREAD_TEAM_BEGIN 8589934592 148300136631927 Thread Team:        
METRIC, 8589934592 148300137337967 ,Metric: 0, PAPI_L1_DCM, 135, PAPI_L1_TCM, 550, PAPI_L2_ICM, 278, PAPI_L2_TCM, 367,
ENTER, 8589934592 148300137337967 ,Region: ,!$omp <3>       
METRIC, 8589934592 148300137347440 ,Metric: 0, PAPI_L1_DCM, 188, PAPI_L1_TCM, 831, PAPI_L2_ICM, 344, PAPI_L2_TCM, 458,
ENTER, 8589934592 148300137347440 ,Region: ,!$omp <4>       
METRIC, 8589934592 148300137764567 ,Metric: 0, PAPI_L1_DCM, 16509, PAPI_L1_TCM, 17407, PAPI_L2_ICM, 402, PAPI_L2_TCM, 1044,
ENTER, 8589934592 148300137764567 ,Region: ,!$omp @normal.c:51,       
METRIC, 8589934592 148300137775434 ,Metric: 0, PAPI_L1_DCM, 16596, PAPI_L1_TCM, 17558, PAPI_L2_ICM, 418, PAPI_L2_TCM, 1090,
LEAVE, 8589934592 148300137775434 ,Region: ,!$omp @normal.c:51,       
METRIC, 8589934592 148300137781926 ,Metric: 0, PAPI_L1_DCM, 16615, PAPI_L1_TCM, 17612, PAPI_L2_ICM, 430, PAPI_L2_TCM, 1104,
LEAVE, 8589934592 148300137781926 ,Region: ,!$omp <4>       
METRIC, 8589934592 148300137788125 ,Metric: 0, PAPI_L1_DCM, 16636, PAPI_L1_TCM, 17644, PAPI_L2_ICM, 430, PAPI_L2_TCM, 1105,
LEAVE, 8589934592 148300137788125 ,Region: ,!$omp <3>       
THREAD_TEAM_END 8589934592 148300137794587 Thread Team:        
#+end_example

- O script final para gerar os arquivos =csv= para análise será criado a
  partir dos fragmentos de script anteriores

#+begin_src sh :results output :exports both :tangle benchmarks/MM/scriptCSVExporter.sh

scorepFolders=$( ls | grep -i "exec_")

threads=4

for i in ${scorepFolders[@]};
do
      cd $i
      
      array=$(/home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | awk '{ print $1,$2,$3,$4,$5,$8,$11,$16,$19,$24,$27,$28,$31 }' | grep -i THREAD_TEAM_BEGIN | awk ' { print $2 } ')

	x=1
	
	echo "Folder: $i"
	while [ $x -le $threads ];
	do
		echo "Thread visited: $x"
    		idTmp=$(echo $array | cut -d ' ' -f$x)
		/home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | sed 's/(//g' | sed 's/)//g' | sed 's/\"P/P/g' | sed 's/\"/,/g' | sed 's/C[[:space:]]/C,/g' | sed 's/[[:space:]]M/,M/g' | sed 's/[[:space:]]R/,R/g'  | sed 's/AVE[[:space:]]/AVE,/g' | sed 's/ER[[:space:]]/ER,/g' | awk '{ print $1,$2,$3,$4,$5,$8,$11,$16,$19,$24,$27,$28,$31 }' | grep -i $idTmp >> thread_$idTmp.csv
		x=$((x+1))
	done
	cd ..
done

#+end_src

#+RESULTS:
| Folder: exec_continuos_par100  |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_par50   |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_par60   |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_par80   |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_parT100 |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_parT50  |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_parT60  |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_parT80  |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_par100     |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_par50      |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_par60      |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_par80      |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_parT100    |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_parT50     |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_parT60     |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_parT80     |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
|                                |

** Analizando resultados obtidos

- O caso escolhido para ser o primeiro a ser analisado e plotado em
  gráfico é o algoritmo normal de entrada igual a 80. Seus rastros
  estão disponíveis na pasta:

#+begin_src sh :results output :exports both :tangle benchmarks/MM/exec_normal_par80/scriptOfGraph.sh
#path: benchmarks/MM/exec_normal_par80/

threadsFiles=$(ls | grep -i thre)
count=0;

for x in ${threadsFiles[@]};
do
	array=$(cat $x | awk '{ print $6 $7"\n"$8 $9"\n"$10 $11"\n"$12 $13}' | sed 's/(//g' | sed 's/)//g' | sed 's/\"/,/g' | sed 's/,,/,/g')
	idThread=$(echo $x | sed 's/.csv//g'| sed 's/thread_//g')
	let count=$count+1
	for i in ${array[@]};
	do
    	if [[ $i =~ .*@.* || $i =~ .*\<.* || $i =~ .*Threads.* || $i =~ .*Request*. ]]; then
	   		continue	    
		else
		    	echo "$count,$i" >> threadAnalyse.csv
		fi
	done
done

echo "thread,hardwareCounter,value" >> threadAnalyseOutput.csv
cat threadAnalyse.csv | sed 's/,,/,/g' |  sed 's/,*$//' >> threadAnalyseOutput.csv
rm threadAnalyse.csv 

#+end_src

#+RESULTS:

- Vou gerar um gráfico para visualizarmos o comportamento das threads
  nessa aplicação, através dos 4 contadores analisados.

#+begin_src R :results output graphics :file "graph.pdf" :exports both :session *Mnormalpar80*  :tangle benchmarks/MM/exec_normal_par80/plotScript.r
library(dplyr);
df <- read.csv("threadAnalyseOutput.csv");
k <- df %>% select(thread,hardwareCounter,value) %>%
     group_by(thread,hardwareCounter) %>%
     as.data.frame();

library(ggplot2);
ggplot(k, aes(x=as.factor(thread), y=value, color=hardwareCounter)) +
  geom_line(aes(group=thread)) +
  theme_bw() + scale_y_log10() +
  facet_wrap(~hardwareCounter);
#+end_src

#+RESULTS:
[[file:graph.pdf]]

* [2016-07-18 Mon 23:57] Retorno sobre as entradas anteriores         :Lucas:

Não consegui gerar a data desta entrada no formato visto nas seções
anteriores. Usei o atalho C-u C-c ! de acordo com o texto:
- http://orgmode.org/manual/Creating-timestamps.html

Reviso aqui o gráfico gerado na seção (veja seção imediatamente anterior):
- [[*Analizando resultados obtidos][Analizando resultados obtidos]]

Vamos olhar os dados (note o caminho relativo a raiz do repositório):

#+begin_src R :results output :session :exports both
df <- read.csv("benchmarks/MM/exec_normal_par80/threadAnalyseOutput.csv");
head(df);
#+end_src

#+RESULTS:
:   thread hardwareCounter value
: 1      1     PAPI_L1_DCM  4103
: 2      1     PAPI_L1_TCM 11234
: 3      1     PAPI_L2_ICM  4492
: 4      1     PAPI_L2_TCM  7141
: 5      1     PAPI_L1_DCM  4412
: 6      1     PAPI_L1_TCM 12150

O tempo desapareceu das medidas (imagino que ele deveria ser
mantido). Para tentar entender melhor o que foi feito, vamos olhar
para apenas uma thread e uma única métrica.

#+begin_src R :results output :session :exports both
head(df[df$thread == 1 & df$hardwareCounter == "PAPI_L1_DCM",]);
#+end_src

#+RESULTS:
:    thread hardwareCounter value
: 1       1     PAPI_L1_DCM  4103
: 5       1     PAPI_L1_DCM  4412
: 9       1     PAPI_L1_DCM  4523
: 13      1     PAPI_L1_DCM  4560
: 17      1     PAPI_L1_DCM  4589
: 21      1     PAPI_L1_DCM  4610

Parece estar tudo bem, o valor vai sempre aumentando.

Olhando o script =scriptOfGraph.sh=, parece-me que estás tirando fora a
informação de tempo. Não entendi também de onde tiraste a
informação das threads, pois olhando o arquivo =execNormal80.csv= (que
parece ser a origem dos dados), não tem dados sobre threads nas linhas
com as métricas. Veja:

#+begin_src sh :results output :session :exports both
ls -hl benchmarks/MM/execNormal80.csv
head benchmarks/MM/execNormal80.csv | grep METRIC
#+end_src

#+RESULTS:
: -rw-r--r-- 1 schnorr schnorr 6.3M Jul 18 23:42 benchmarks/MM/execNormal80.csv
: METRIC, 148299959479341 ,Metric: 0, PAPI_L1_DCM, 4103, PAPI_L1_TCM, 11234, PAPI_L2_ICM, 4492, PAPI_L2_TCM, 7141,
: METRIC, 148299959647641 ,Metric: 0, PAPI_L1_DCM, 4412, PAPI_L1_TCM, 12150, PAPI_L2_ICM, 4795, PAPI_L2_TCM, 7592,
: METRIC, 148299959668347 ,Metric: 0, PAPI_L1_DCM, 4523, PAPI_L1_TCM, 12576, PAPI_L2_ICM, 4846, PAPI_L2_TCM, 7690,

Olhando para o gráfico (e o código que o gerou):
[[file:benchmarks/MM/exec_normal_par80/graph.pdf]]

Alguns equívocos sobre o gráfico:
- estás desenhando com linha, quando deverias usar =geom_point()=
- evitar _sempre_ escalas logaritmicas, prefira escalas lineares

Existem alguns equívocos sobre os dados também. Por exemplo, após
agrupar com =group_by= nenhuma transformação nos dados é feita. Além
disso, entendo que como os valores dos contadores apenas aumentam
(veja acima), o ideal seria subtrair o maior valor do contador pelo
menor valor do mesmo contador. Isso permitiria tu obteres o valor
correto global para cada thread. Vejamos:

#+begin_src R :results output :session :exports both
k <- df[df$thread == 1 & df$hardwareCounter == "PAPI_L1_DCM",];
nrow(k);
#+end_src

#+RESULTS:
: [1] 76884

Existem várias medidas, vamos ver a diferença:

#+begin_src R :results output :session :exports both
head(k);
tail(k);
#+end_src

#+RESULTS:
#+begin_example
   thread hardwareCounter value
1       1     PAPI_L1_DCM  4103
5       1     PAPI_L1_DCM  4412
9       1     PAPI_L1_DCM  4523
13      1     PAPI_L1_DCM  4560
17      1     PAPI_L1_DCM  4589
21      1     PAPI_L1_DCM  4610
       thread hardwareCounter  value
307513      1     PAPI_L1_DCM 339304
307517      1     PAPI_L1_DCM 339321
307521      1     PAPI_L1_DCM 339494
307525      1     PAPI_L1_DCM 339497
307529      1     PAPI_L1_DCM 339595
307533      1     PAPI_L1_DCM 339604
#+end_example

Como não temos a coluna do tempo (foi removida desse CSV pelo script
mencionado acima), vamos plotar este valor em função da ordem das
medições. Mas primeiro, adicionar uma nova coluna com um identificador
de cada medição:

#+begin_src R :results output :session :exports both
k$seq = seq(1,nrow(k));
head(k);
tail(k);
#+end_src

#+RESULTS:
#+begin_example
   thread hardwareCounter value seq
1       1     PAPI_L1_DCM  4103   1
5       1     PAPI_L1_DCM  4412   2
9       1     PAPI_L1_DCM  4523   3
13      1     PAPI_L1_DCM  4560   4
17      1     PAPI_L1_DCM  4589   5
21      1     PAPI_L1_DCM  4610   6
       thread hardwareCounter  value   seq
307513      1     PAPI_L1_DCM 339304 76879
307517      1     PAPI_L1_DCM 339321 76880
307521      1     PAPI_L1_DCM 339494 76881
307525      1     PAPI_L1_DCM 339497 76882
307529      1     PAPI_L1_DCM 339595 76883
307533      1     PAPI_L1_DCM 339604 76884
#+end_example

Ótimo, agora vamos ao gráfico:

#+begin_src R :results output graphics :file (org-babel-temp-file "figure" ".png") :exports both :width 600 :height 400 :session
library(ggplot2);
ggplot(k, aes(x=seq, y=value)) + geom_point() + theme_bw();
#+end_src

#+RESULTS:
[[file:/tmp/babel-10319ASZ/figure10319Cnl.png]]

Veja já que grave, o contador bate no limite e volta para 0. Isso é um
problema pois não podemos simplesmente considerar a diferenças entre o
valor máximo e o mínimo para ter um sumário do valor para cada thread.

Qual seria a solução para isso?

Veja o momento onde isso acontece.

#+begin_src R :results output :session :exports both
head(k[k$seq > 38439,]);
#+end_src

#+RESULTS:
:        thread hardwareCounter  value   seq
: 153757      1     PAPI_L1_DCM 339497 38440
: 153761      1     PAPI_L1_DCM 339595 38441
: 153765      1     PAPI_L1_DCM 339604 38442
: 153769      1     PAPI_L1_DCM   4103 38443
: 153773      1     PAPI_L1_DCM   4412 38444
: 153777      1     PAPI_L1_DCM   4523 38445

Isso é relativamente simples de detectar no momento do
rastreamento. Não há nenhum evento do Score-P que informa que houve
uma quebra do contador (pelo seu tamanho limitado)?

Isso deve ser resolvido antes de qualquer coisa.

_Tarefas_:
- adicionar uma coluna de tempo ao CSV
- tentar detectar a quebra do contador no Score-p

A ferramenta ReDFST parece que rastrea alguns contadores (não tenho
total certeza), e me parece também que ela detectaria. Mas os valores
de contadores obtidos são sempre globais. O que queremos é a evolução
do valor dos contadores _ao longo do tempo_.
* [13:44:21; 04.08.2016] Reexecução do benchmark MM com PAPI via Scorep - Contadores principais :Gabriel:
- Os principais contadores para visualizarmos o comportamento da
  aplicação via PAPI são: =PAPI_L1_DCH=, =PAPI_L2_DCH=, =PAPI_L3_TCM=,
  =PAPI_L1_DCA=, =PAPI_L2_DCA=, =PAPI_L3_DCA= e =PAPI_FP_OPS=.

Primeiramente vamos visualizar quais contadores temos disponíveis na
  máquina =beagle1= (terceira coluna é a disponibilidade do contador) :

#+begin_src sh :results output :exports both
sudo papi_avail | grep -i DCH
#+end_src

#+RESULTS:
| PAPI_L3_DCH  0x8000001d  No    No   Level 3 data cache hits |
| PAPI_L1_DCH  0x8000003e  No    No   Level 1 data cache hits |
| PAPI_L2_DCH  0x8000003f  Yes   Yes  Level 2 data cache hits |

#+begin_src sh :results output :exports both
sudo papi_avail | grep -i TCM
#+end_src

#+RESULTS:
| PAPI_L1_TCM  0x80000006  Yes   Yes  Level 1 cache misses |
| PAPI_L2_TCM  0x80000007  Yes   No   Level 2 cache misses |
| PAPI_L3_TCM  0x80000008  Yes   No   Level 3 cache misses |

#+begin_src sh :results output :exports both
sudo papi_avail | grep -i DCA
#+end_src

#+RESULTS:
| PAPI_L1_DCA  0x80000040  No    No   Level 1 data cache accesses |
| PAPI_L2_DCA  0x80000041  Yes   No   Level 2 data cache accesses |
| PAPI_L3_DCA  0x80000042  Yes   Yes  Level 3 data cache accesses |

#+begin_src sh :results output :exports both
sudo papi_avail | grep -i OPS
#+end_src

#+RESULTS:
| PAPI_FP_OPS  0x80000066  Yes   Yes  Floating point operations                                                               |
| PAPI_SP_OPS  0x80000067  Yes   Yes  Floating point operations; optimized to count scaled single precision vector operations |
| PAPI_DP_OPS  0x80000068  Yes   Yes  Floating point operations; optimized to count scaled double precision vector operations |

- Todos os contadores que serão utilizados no experimento são
  disponíveis na =beagle1=.
  
** Experimento
*** Projeto do Experimento

- Definição do projeto do experimento a ser realizado:

#+begin_src R :results output :session *experiment* :exports both
require(DoE.base);
  expDesign_MM <- fac.design (
           nfactors=2,
           replications=5,
           repeat.only=FALSE,
           blocks=1,
           randomize=TRUE,
           seed=10373,
           nlevels=c(6,2),
           factor.names=list(
               app=c("normal_par","continuos_par","tiling_par","normal_parT","continuos_parT","tiling_parT"),
			size=c(50,80)));

  export.design(expDesign_MM,
                path=".",
                filename=NULL,
                type="csv",
                replace=TRUE,
                response.names=c("timeOfExecution","thread_region","idThread","PAPI_L2_DCH",
"PAPI_L2_DCA","PAPI_L1_TCM","PAPI_L2_TCM",
"PAPI_L3_TCM","PAPI_FP_OPS"));

#+end_src

#+RESULTS:
#+begin_example
Loading required package: DoE.base
Loading required package: grid
Loading required package: conf.design

Attaching package: ‘DoE.base’

The following objects are masked from ‘package:stats’:

    aov, lm

The following object is masked from ‘package:graphics’:

    plot.design

The following object is masked from ‘package:base’:

    lengths
 creating full factorial with 12 runs ...
#+end_example

- O full factorial pode ser visualizado na imagem gerada pelo seguinte
  script:

#+begin_src R :results output graphics :file "imagens/fullFactorialExpMM.png") :exports both :width 600 :height 400 :session *R* 
library(SixSigma)
library(grid)

effect<-"Hit, Misses das Caches e Operações FP"
causes.gr<-c("Versão", "Tamanho", "Threads")
causes<-vector(mode="list", length=length(causes.gr))

causes[1]<-list(c("normal_par","normal_parT", "continuos_par", "continuos_parT", "tiling_par", "tiling_parT"))
causes[2]<-list(c(50,80))
causes[3]<-list(c(32))

ss.ceDiag(effect, causes.gr, causes, sub="Experiment")

#+end_src

#+RESULTS:
[[file:imagens/fullFactorialExpMM.png]]

*** Plataforma de Execução

- As principais características da =beagle1= são:

#+begin_src sh :results output :exports both
lscpu
#+end_src

#+RESULTS:
| Architecture:          x86_64                                      |    |
| CPU op-mode(s):        32-bit, 64-bit                             |    |
| Byte Order:            Little Endian                              |    |
| CPU(s):                32                                         |    |
| On-line CPU(s) list:   0-                                         | 31 |
| Thread(s) per core:    2                                          |    |
| Core(s) per socket:    8                                          |    |
| Socket(s):             2                                          |    |
| NUMA node(s):          2                                          |    |
| Vendor ID:             GenuineIntel                               |    |
| CPU family:            6                                          |    |
| Model:                 45                                         |    |
| Stepping:              7                                          |    |
| CPU MHz:               2000.141                                   |    |
| BogoMIPS:              4001.23                                    |    |
| Virtualization:        VT-x                                       |    |
| L1d cache:             32K                                        |    |
| L1i cache:             32K                                        |    |
| L2 cache:              256K                                       |    |
| L3 cache:              20480K                                     |    |
| NUMA node0 CPU(s):     0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30 |    |
| NUMA node1 CPU(s):     1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31 |    |

*** Script de simulação do experimento

#+begin_src sh :results output :exports :tangle dados/scriptOfSimulationExpMM.sh
#!bin/bash


function toClear() {
	sudo rm -rf tmp tmp2 tmp.csv tmp2.csv Results_expMM.csv
}

function toExport() {
	export SCOREP_ENABLE_TRACING=true
	export SCOREP_METRIC_RUSAGE=ru_utime,ru_stime
	export SCOREP_TOTAL_MEMORY=3G
}

function execute() {
	scorepPath=/home/aulapinroot/Programs/scorep-2.0.2/bin

	cat expDesign_MM.csv | head -1 >> Results_expMM.csv

	lines=$(cat expDesign_MM.csv)

	h=0
	for i in ${lines[@]}; do

		if [ $h -gt 1 ]; then
		    
			echo "definindo variáveis de ambiente"
			echo "exportando as variáveis utilizadas pelo scorep"

			toExport

			name=$(echo $i | cut -d ',' -f1)
			runNoInStdOrder=$(echo $i | cut -d ',' -f2)
			runNo=$(echo $i | cut -d ',' -f3)
			runRP=$(echo $i | cut -d ',' -f4)
			app=$(echo $i | cut -d ',' -f5 | sed 's/\"//g')
			size=$(echo $i | cut -d ',' -f6 | sed 's/\"//g')

			echo "Executando -- $app"

			export SCOREP_METRIC_PAPI=PAPI_L2_DCH,PAPI_L2_DCA,PAPI_L1_TCM
			export SCOREP_EXPERIMENT_DIRECTORY="tmp"

			timeOfExecution=$(sudo -E ./$app $size | sed 's/HPCELO://g')
			
			$scorepPath/otf2-print tmp/traces.otf2 | awk ' { print $1,$3,$11,$15,$19,$20} ' | sed 's/[\")(,]//g' | sed 's/\ /,/g' | sed 's/,,,,//g' | sed 's/,ru_utime//g' >> tmp.csv
			
			toExport

			export SCOREP_METRIC_PAPI=PAPI_L2_TCM,PAPI_L3_TCM,PAPI_FP_OPS
			export SCOREP_EXPERIMENT_DIRECTORY="tmp2"

			sudo -E ./$app $size
			
			$scorepPath/otf2-print tmp2/traces.otf2 | awk ' { print $1,$3,$11,$15,$19,$20} ' | sed 's/[\")(,]//g' | sed 's/\ /,/g' | sed 's/,,,,//g' | sed 's/,ru_utime//g' >> tmp2.csv 


			paste tmp.csv tmp2.csv > tmpR.csv
			
			sed -i 's/\t/,/g' tmpR.csv

			res=$(cat tmpR.csv)

			for count in ${res[@]}; do
				echo "$name,$runNoInStdOrder,$runNo,$runRP,$app,$size,$timeOfExecution,$count" >> Results_expMM.csv
			done;

			
			sudo rm -rf tmp tmp2 tmp.csv tmp2.csv tmpR.csv 
		fi

		let h=$h+1;
		echo "interation $h"
	done
}

toClear

execute
#+end_src

* 2016-08-10 Attempt to understand scorep hardware counters metrics   :Lucas:

#+begin_src sh :results output
otf2-print scorep-20160810_1601_8543111267115196/traces.otf2 | grep METRIC | awk '{ print "Thread", "Timestamp", $8, $12, $16 }' | tr -d '(\"' | sed "s/ /,/g" | head -n1 > x.csv
otf2-print scorep-20160810_1601_8543111267115196/traces.otf2  | grep ^METRIC | awk '{ print $2, $3, $11, $15, $19 }' | tr -d ")," | sed "s/ /,/g" >> x.csv
#+end_src

#+begin_src R :results output :session :exports both
df <- read.csv("artigos/2016_wsppd/idgraf_2016_08_10.csv");
df$Timestamp <- df$Timestamp - min(df$Timestamp); #obtain a zero
df$Timestamp <- df$Timestamp/1000000000; #in seconds now
library(reshape);
df <- melt(df, id=c("Thread", "Timestamp"));

head(df);
#+end_src

#+RESULTS:
:       Thread Timestamp    variable  value
: 1          0  0.000000 PAPI_L2_DCH    219
: 2          0  1.461988 PAPI_L2_DCH 177452
: 3          0  1.462043 PAPI_L2_DCH 177463
: 4          0  1.466827 PAPI_L2_DCH 179331
: 5          0  1.466844 PAPI_L2_DCH 179357
: 6 8589934592  1.493765 PAPI_L2_DCH    121

#+begin_src R :results output graphics :file "imagens/analiseProfLucas.png" :exports both :width 1200 :height 800 :session
library(ggplot2);
ggplot(df, aes(x=Timestamp, y=value, color=variable)) + geom_line() + theme_bw() + facet_grid(Thread~variable);
#+end_src

#+RESULTS:
[[file:imagens/analiseProfLucas.png]]

Data is clearly missing. There is no measurements from timestamp 0 to
more than 200s. It might be some issue related to tracing. Let's check
the dataframe textually, for thread 0:

#+begin_src R :results output :session :exports both
df[df$Thread == 0 & df$variable == "PAPI_L2_DCH",];
#+end_src

#+RESULTS:
#+begin_example
    Thread  Timestamp    variable      value
1        0   0.000000 PAPI_L2_DCH        219
2        0   1.461988 PAPI_L2_DCH     177452
3        0   1.462043 PAPI_L2_DCH     177463
4        0   1.466827 PAPI_L2_DCH     179331
5        0   1.466844 PAPI_L2_DCH     179357
52       0   2.126407 PAPI_L2_DCH    1072592
119      0   2.228808 PAPI_L2_DCH    1072636
137      0   2.228837 PAPI_L2_DCH    1072636
146      0   2.228846 PAPI_L2_DCH    1072636
148      0   2.228958 PAPI_L2_DCH    1072677
190      0   2.228974 PAPI_L2_DCH    1072686
204      0 240.032126 PAPI_L2_DCH 7164116273
233      0 267.039035 PAPI_L2_DCH 7164116324
250      0 267.039065 PAPI_L2_DCH 7164116324
264      0 267.039075 PAPI_L2_DCH 7164116324
292      0 267.046954 PAPI_L2_DCH 7164116352
293      0 267.046964 PAPI_L2_DCH 7164116361
294      0 267.499745 PAPI_L2_DCH 7164116381
#+end_example

We should get a much finer granularity when measuring. I believe
scorep is only measuring the metrics when something is actually traced
(from the application level). That's very bad, since in the meantime
(from 2.228974 to 240.032126) we got nothing.

* STARTED [23:58:15; 10.08.2016] Script protótipo para coletar em diferentes time stamps usando abordagem manual com Intel PCM :Gabriel:
- State "STARTED"    from              [2016-08-11 Qui 16:40]
- O script deve inicializar o programa-alvo, em X interações deverá
  coletar os hardwares counters específicos para gerar o rastro de
  execução. Essas interações terão como condição de parada o término
  do processo, o time stamp será definido de acordo com o tempo gasto
  pela aplicação como um todo, por isso deverá ser informado por
  parâmetro.

#+begin_src sh :results output :exports both :tangle scripts/scriptPCMexp1.bash
pathOfIntelPCM=/home/aulapinroot/Programs/IntelPerformanceCounterMonitor-V2.11

app=normal_par

size=6000

flag=0

timeOfCollet=0.002 #em segundos
timeAcc=0.0

echo "The application $app is being executed..."
#disparando a aplicação alvo
./$app $size &

#cabeçalho do arquivo
echo "TimeStamp,L3miss,L2miss,L3hit,L2hit" >> Results.csv

while [ $flag -eq 0 ]; do
	echo "Time stamp - $timeAcc"

	#recuperando o estado do processo para ver se o mesmo está executando
	stateOfProcess=$(ps ux | grep -i $app | head -1 | awk ' { print $8 } ')

	#pegar a quantidade de Rs nesse fluxo de caracteres
	amountOfR=$(echo $stateOfProcess | grep R | wc -l | bc)	

	#se existir um R, então o processo está execuntando
	if [ $amountOfR == 1 ]; then
		flag=0;
	else
	    	flag=1;
	fi

	#aqui executo algum processo leve
	sudo -E $pathOfIntelPCM/pcm.x --noJKTWA -r --external-program clean >> tmp.log

	l3miss=$(cat tmp.log | grep -i "TOTAL *" | head -1 | awk ' { print $7,$8 } ')
	l3miss=$(echo $l3miss | sed -e 's/[[:space:]]K/*1024/g')
	l3miss=$(echo $l3miss | sed -e 's/[[:space:]]M/*1024*1024/g')
	l3miss=$(echo $l3miss | sed -e 's/[[:space:]]G/*1024*1024*1024/g')
	l3miss=$(echo $l3miss | bc)

	l2miss=$(cat tmp.log | grep -i "TOTAL *" | head -1 | awk ' { print $9,$10 } ')
	l2miss=$(echo $l2miss | sed -e 's/[[:space:]]K/*1024/g')
	l2miss=$(echo $l2miss | sed -e 's/[[:space:]]M/*1024*1024/g')
	l2miss=$(echo $l2miss | sed -e 's/[[:space:]]G/*1024*1024*1024/g')
	l2miss=$(echo $l2miss | bc)

	l3hit=$(cat tmp.log | grep -i "TOTAL *" | head -1 | awk ' { print $11 } ')
	l2hit=$(cat tmp.log | grep -i "TOTAL *" | head -1 | awk ' { print $12 } ')

	echo "$timeAcc,$l3miss,$l2miss,$l3hit,$l2hit" >> Results.csv

	#sleep $timeOfCollet

	#timeAcc=$(echo "$timeAcc+$timeOfCollet" | bc)
	timeAcc=$(echo "$timeAcc+1" | bc);
	rm tmp.log
done
#+end_src

#+RESULTS:
#+begin_example
TimeStamp,L3miss,L2miss,L3hit,L2hit
0.0,46080,51200,0.10,0.13
1.0,1057792,10485760,0.90,0.01
2.0,833536,6281216,0.87,0.01
3.0,5718016,35651584,0.84,0.01
4.0,459776,2722816,0.83,0.01
5.0,4577280,27262976,0.83,0.00
6.0,4392960,26214400,0.83,0.01
7.0,189440,324608,0.42,0.21
8.0,6773760,34603008,0.80,0.00
9.0,1221632,6487040,0.81,0.01
10.0,6791168,34603008,0.80,0.00
11.0,5078016,27262976,0.81,0.00
12.0,6463488,34603008,0.81,0.00
13.0,1232896,6567936,0.81,0.00
14.0,7702528,37748736,0.79,0.01
15.0,7273472,33554432,0.78,0.00
16.0,59392,87040,0.32,0.29
17.0,143360,484352,0.70,0.17
18.0,1398784,7318528,0.81,0.03
19.0,625664,3027968,0.79,0.00
20.0,8224768,38797312,0.79,0.01
21.0,7543808,37748736,0.80,0.00
22.0,5612544,27262976,0.79,0.00
23.0,8998912,39845888,0.77,0.00
24.0,7250944,33554432,0.78,0.01
25.0,7941120,35651584,0.78,0.01
26.0,1517568,6606848,0.77,0.00
27.0,5953536,27262976,0.78,0.00
28.0,7496704,35651584,0.79,0.01
29.0,8685568,38797312,0.77,0.00
30.0,6930432,33554432,0.79,0.00
31.0,7645184,35651584,0.79,0.00
32.0,8279040,36700160,0.77,0.00
33.0,8115200,37748736,0.78,0.01
34.0,7917568,35651584,0.77,0.00
35.0,7739392,36700160,0.78,0.00
36.0,6269952,30408704,0.79,0.00
37.0,8169472,37748736,0.78,0.00
38.0,7809024,36700160,0.78,0.00
39.0,5847040,27262976,0.78,0.00
40.0,6980608,33554432,0.79,0.00
41.0,7785472,35651584,0.78,0.00
42.0,7525376,35651584,0.79,0.00
43.0,7630848,35651584,0.79,0.00
44.0,7728128,35651584,0.78,0.00
45.0,1514496,6580224,0.77,0.00
46.0,6475776,30408704,0.78,0.00
47.0,7690240,35651584,0.78,0.00
48.0,7632896,35651584,0.78,0.00
49.0,6664192,29360128,0.77,0.00
50.0,5654528,26214400,0.78,0.00
51.0,7553024,34603008,0.78,0.00
52.0,8286208,36700160,0.77,0.01
53.0,8539136,37748736,0.77,0.00
54.0,7943168,36700160,0.78,0.00
55.0,7463936,34603008,0.79,0.00
56.0,122880,507904,0.76,0.03
57.0,1378304,6400000,0.78,0.00
58.0,1399808,6425600,0.78,0.00
59.0,7431168,34603008,0.79,0.00
60.0,978944,4717568,0.79,0.00
61.0,8198144,37748736,0.78,0.01
62.0,7841792,37748736,0.79,0.00
63.0,1347584,6467584,0.79,0.00
64.0,5840896,27262976,0.78,0.01
65.0,6465536,31457280,0.79,0.00
66.0,1381376,6492160,0.79,0.00
67.0,1492992,6633472,0.77,0.00
68.0,1515520,6874112,0.78,0.00
69.0,1356800,6226944,0.78,0.00
70.0,8104960,37748736,0.78,0.00
71.0,2725888,11534336,0.78,0.00
72.0,6637568,30408704,0.78,0.00
73.0,5969920,26214400,0.77,0.00
74.0,2094080,9460736,0.78,0.05
75.0,7837696,36700160,0.79,0.00
76.0,7556096,35651584,0.79,0.00
77.0,7766016,35651584,0.78,0.01
78.0,1206272,5321728,0.77,0.00
79.0,8000512,34603008,0.76,0.02
80.0,7604224,35651584,0.78,0.01
81.0,8060928,36700160,0.78,0.00
82.0,1316864,6294528,0.79,0.00
83.0,7443456,36700160,0.79,0.00
84.0,4930560,22020096,0.77,0.00
85.0,7490560,36700160,0.79,0.00
86.0,1433600,6588416,0.78,0.00
87.0,7649280,37748736,0.79,0.00
88.0,2052096,9309184,0.78,0.00
89.0,7557120,34603008,0.78,0.00
90.0,7642112,39845888,0.80,0.00
91.0,6752256,32505856,0.79,0.00
92.0,7240704,35651584,0.79,0.00
93.0,8536064,42991616,0.80,0.00
94.0,490496,1898496,0.74,0.06
95.0,8374272,42991616,0.80,0.00
96.0,121856,559104,0.78,0.02
97.0,8514560,45088768,0.81,0.00
98.0,9328640,48234496,0.80,0.00
99.0,112640,582656,0.81,0.02
100.0,8974336,47185920,0.81,0.00
101.0,9147392,50331648,0.81,0.00
102.0,6796288,33554432,0.80,0.00
103.0,9434112,50331648,0.81,0.00
104.0,10485760,52428800,0.80,0.00
105.0,7735296,39845888,0.81,0.00
106.0,2095104,10121216,0.79,0.00
107.0,10485760,51380224,0.79,0.00
108.0,2019328,9956352,0.80,0.01
109.0,7443456,38797312,0.81,0.00
110.0,10485760,54525952,0.80,0.00
111.0,1870848,9511936,0.80,0.00
112.0,10485760,55574528,0.81,0.00
113.0,10485760,54525952,0.81,0.00
114.0,11534336,65011712,0.81,0.00
115.0,12582912,63963136,0.80,0.01
116.0,8701952,48234496,0.82,0.00
117.0,10038272,59768832,0.83,0.00
118.0,10485760,59768832,0.83,0.00
119.0,9673728,50331648,0.81,0.01
120.0,7840768,45088768,0.82,0.00
121.0,2877440,13631488,0.80,0.00
122.0,9346048,48234496,0.80,0.00
123.0,167936,839680,0.80,0.02
124.0,173056,975872,0.82,0.02
125.0,8958976,51380224,0.82,0.00
126.0,8354816,50331648,0.83,0.00
127.0,1104896,6454272,0.83,0.00
128.0,11264,18432,0.34,0.23

#+end_example

- Análise dos resultados:

#+begin_src R :results output graphics :file "imagens/l3missgraph_exp1.png" :exports both :width 800 :height 600 :session *R* 
df <- read.csv("dados/exp1_manualPCM.csv");

library(ggplot2);
ggplot(df, aes(x=TimeStamp,y=L3miss)) +
geom_line(color='blue');
#+end_src

#+RESULTS:
[[file:imagens/l3missgraph_exp1.png]]


#+begin_src R :results output graphics :file "imagens/l2missgraph_exp1.png" :exports both :width 800 :height 600 :session *R* 
df <- read.csv("dados/exp1_manualPCM.csv");

library(ggplot2);
ggplot(df, aes(x=TimeStamp,y=L2miss)) +
geom_line(color='red');
#+end_src

#+RESULTS:
[[file:imagens/l2missgraph_exp1.png]]

- Vou pesquisar uma forma de gerar no mesmo gráfico todos os dados do
  =.csv= 

* STARTED [21:21:52; 11.08.2016] Experimentando a ferramenta =likwid= :Gabriel:
- State "STARTED"    from              [2016-08-12 Sex 16:07]
- Instalando a ferramenta na =beagle1=

#+begin_src sh :results output :exports both
cd $HOME/Programs/
git clone https://github.com/RRZE-HPC/likwid.git
cd likwid
make
sudo make install
#+end_src

#+RESULTS:

- Testando o seu recurso de medição =full node=:

#+begin_src sh :results output :exports both
sudo likwid-perfctr -f -c N:0-31 -g MEM ./tiling_par 100 > ../../dados/outOfLikwid_exp1.txt
#+end_src 

#+begin_src sh :results output :exports both
cd dados/
cat outOfLikwid_exp1.txt
#+end_src

#+RESULTS:
#+begin_example
--------------------------------------------------------------------------------
CPU name:	Intel(R) Xeon(R) CPU E5-2650 0 @ 2.00GHz
CPU type:	Intel Xeon SandyBridge EN/EP processor
CPU clock:	2.00 GHz
--------------------------------------------------------------------------------
HPCELO:0.075840
--------------------------------------------------------------------------------
Group 1: MEM
+-----------------------+---------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+---------+-----------+----------+----------+-----------+----------+-----------+-----------+-----------+----------+----------+----------+-----------+
|         Event         | Counter |   Core 0  |   Core 2  |   Core 4  |   Core 6  |   Core 8  |  Core 10  |  Core 12  |  Core 14  |   Core 1  |   Core 3  |   Core 5  |   Core 7  |   Core 9  |  Core 11  |  Core 13  |  Core 15  |  Core 16  |  Core 18  |  Core 20  | Core 22 |  Core 24  |  Core 26 |  Core 28 |  Core 30  |  Core 17 |  Core 19  |  Core 21  |  Core 23  |  Core 25 |  Core 27 |  Core 29 |  Core 31  |
+-----------------------+---------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+---------+-----------+----------+----------+-----------+----------+-----------+-----------+-----------+----------+----------+----------+-----------+
|   INSTR_RETIRED_ANY   |  FIXC0  |  48374458 |  45352262 |  36603520 |  41002247 |  36810725 |  38621003 |  37999593 |  39003498 |  50476207 |  35306169 |  37374151 |  36669360 |  35951123 |  37092138 |  36058105 |  35282321 |  34828385 |  47770845 |  48482726 |  124634 |  33572988 | 13443606 | 13199540 |  37346267 | 14746667 |  42418624 |  51831212 |  35226940 | 14775707 | 13433452 | 26212555 |  33148044 |
| CPU_CLK_UNHALTED_CORE |  FIXC1  | 167198929 | 163088008 | 131974702 | 118476831 | 129738287 | 121648201 | 120054153 | 138735328 | 158162029 | 126651687 | 135462851 | 132224211 | 116138645 | 115708107 | 121735191 | 126890935 | 128065707 | 169991275 | 166806068 |  941625 | 119189618 | 49059442 | 48697186 | 132159474 | 55340498 | 147496129 | 176997990 | 128285818 | 55329326 | 49087123 | 94191829 | 120429844 |
|  CPU_CLK_UNHALTED_REF |  FIXC2  | 138774100 | 135281160 | 109781300 |  98536960 | 108096520 | 101341080 | 100032120 | 115362600 | 131797460 | 105543140 | 112864920 | 110181080 |  96776680 |  96416600 | 101428560 | 105733160 | 106671300 | 141188020 | 138622220 |  784680 |  99307180 | 40874440 | 40578960 | 110079020 | 46112880 | 122904360 | 147476480 | 106888900 | 46104360 | 40901700 | 78488300 | 100351520 |
|      CAS_COUNT_RD     | MBOX0C0 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_WR     | MBOX0C1 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_RD     | MBOX1C0 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_WR     | MBOX1C1 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_RD     | MBOX2C0 |   90067   |     0     |     0     |     0     |     0     |     0     |     0     |     0     |   28899   |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_WR     | MBOX2C1 |   47797   |     0     |     0     |     0     |     0     |     0     |     0     |     0     |   17154   |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_RD     | MBOX3C0 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_WR     | MBOX3C1 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
+-----------------------+---------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+---------+-----------+----------+----------+-----------+----------+-----------+-----------+-----------+----------+----------+----------+-----------+

+----------------------------+---------+------------+--------+-----------+--------------+
|            Event           | Counter |     Sum    |   Min  |    Max    |      Avg     |
+----------------------------+---------+------------+--------+-----------+--------------+
|   INSTR_RETIRED_ANY STAT   |  FIXC0  | 1088539072 | 124634 |  51831212 |   34016846   |
| CPU_CLK_UNHALTED_CORE STAT |  FIXC1  | 3765957047 | 941625 | 176997990 | 1.176862e+08 |
|  CPU_CLK_UNHALTED_REF STAT |  FIXC2  | 3135281760 | 784680 | 147476480 |   97977555   |
|      CAS_COUNT_RD STAT     | MBOX0C0 |      0     |    0   |     0     |       0      |
|      CAS_COUNT_WR STAT     | MBOX0C1 |      0     |    0   |     0     |       0      |
|      CAS_COUNT_RD STAT     | MBOX1C0 |      0     |    0   |     0     |       0      |
|      CAS_COUNT_WR STAT     | MBOX1C1 |      0     |    0   |     0     |       0      |
|      CAS_COUNT_RD STAT     | MBOX2C0 |   118966   |    0   |   90067   |   3717.6875  |
|      CAS_COUNT_WR STAT     | MBOX2C1 |    64951   |    0   |   47797   |   2029.7188  |
|      CAS_COUNT_RD STAT     | MBOX3C0 |      0     |    0   |     0     |       0      |
|      CAS_COUNT_WR STAT     | MBOX3C1 |      0     |    0   |     0     |       0      |
+----------------------------+---------+------------+--------+-----------+--------------+

+-----------------------------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+
|               Metric              |   Core 0  |   Core 2  |   Core 4  |   Core 6  |   Core 8  |  Core 10  |  Core 12  |  Core 14  |   Core 1  |   Core 3  |   Core 5  |   Core 7  |   Core 9  |  Core 11  |  Core 13  |  Core 15  |  Core 16  |  Core 18  |  Core 20  |  Core 22  |  Core 24  |  Core 26  |  Core 28  |  Core 30  |  Core 17  |  Core 19  |  Core 21  |  Core 23  |  Core 25  |  Core 27  |  Core 29  |  Core 31  |
+-----------------------------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+
|        Runtime (RDTSC) [s]        |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |
|        Runtime unhalted [s]       |   0.0836  |   0.0815  |   0.0660  |   0.0592  |   0.0649  |   0.0608  |   0.0600  |   0.0694  |   0.0791  |   0.0633  |   0.0677  |   0.0661  |   0.0581  |   0.0579  |   0.0609  |   0.0634  |   0.0640  |   0.0850  |   0.0834  |   0.0005  |   0.0596  |   0.0245  |   0.0243  |   0.0661  |   0.0277  |   0.0738  |   0.0885  |   0.0641  |   0.0277  |   0.0245  |   0.0471  |   0.0602  |
|            Clock [MHz]            | 2409.5581 | 2410.9991 | 2404.2225 | 2404.6208 | 2400.3180 | 2400.6702 | 2400.2145 | 2405.1068 | 2399.9795 | 2399.9009 | 2400.3445 | 2400.0279 | 2400.0394 | 2400.0722 | 2400.3149 | 2400.1132 | 2401.0301 | 2407.9148 | 2406.5303 | 2399.9254 | 2400.3254 | 2400.3973 | 2400.0224 | 2401.0770 | 2400.1211 | 2400.0797 | 2400.2579 | 2400.2605 | 2400.0800 | 2400.1510 | 2400.0520 | 2400.0623 |
|                CPI                |   3.4563  |   3.5960  |   3.6055  |   2.8895  |   3.5245  |   3.1498  |   3.1594  |   3.5570  |   3.1334  |   3.5872  |   3.6245  |   3.6058  |   3.2305  |   3.1195  |   3.3761  |   3.5964  |   3.6770  |   3.5585  |   3.4405  |   7.5551  |   3.5502  |   3.6493  |   3.6893  |   3.5388  |   3.7527  |   3.4772  |   3.4149  |   3.6417  |   3.7446  |   3.6541  |   3.5934  |   3.6331  |
|  Memory read bandwidth [MBytes/s] |  73.0360  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |  23.4344  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |
|  Memory read data volume [GBytes] |   0.0058  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |   0.0018  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |
| Memory write bandwidth [MBytes/s] |  38.7589  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |  13.9103  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |
| Memory write data volume [GBytes] |   0.0031  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |   0.0011  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |
|    Memory bandwidth [MBytes/s]    |  111.7949 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |  37.3447  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |
|    Memory data volume [GBytes]    |   0.0088  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |   0.0029  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |
+-----------------------------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+

+----------------------------------------+------------+-----------+-----------+-----------+
|                 Metric                 |     Sum    |    Min    |    Max    |    Avg    |
+----------------------------------------+------------+-----------+-----------+-----------+
|        Runtime (RDTSC) [s] STAT        |   2.5248   |   0.0789  |   0.0789  |   0.0789  |
|        Runtime unhalted [s] STAT       |   1.8829   |   0.0005  |   0.0885  |   0.0588  |
|            Clock [MHz] STAT            | 76854.7897 | 2399.9009 | 2410.9991 | 2401.7122 |
|                CPI STAT                |  115.7818  |   2.8895  |   7.5551  |   3.6182  |
|  Memory read bandwidth [MBytes/s] STAT |   96.4704  |     0     |  73.0360  |   3.0147  |
|  Memory read data volume [GBytes] STAT |   0.0076   |     0     |   0.0058  |   0.0002  |
| Memory write bandwidth [MBytes/s] STAT |   52.6692  |     0     |  38.7589  |   1.6459  |
| Memory write data volume [GBytes] STAT |   0.0042   |     0     |   0.0031  |   0.0001  |
|    Memory bandwidth [MBytes/s] STAT    |  149.1396  |     0     |  111.7949 |   4.6606  |
|    Memory data volume [GBytes] STAT    |   0.0117   |     0     |   0.0088  |   0.0004  |
+----------------------------------------+------------+-----------+-----------+-----------+

#+end_example

- Pelo que eu percebi de acordo com esses resultados é que a
  ferramenta possui um funcionamento parecido com perf, oferecendo a
  somatória total dos eventos, não funcionando como uma ferramenta
  monitora coletando diferentes valores a cada =time stamp=. Posso estar
  errado, por isso vou continuar investigando seus recursos.

- O caminho se utilizarmos essa ferramenta é usar algo parecido com
  esse comando:

#+begin_example
sudo likwid-perfctr -t 20ms -f -c N:0-31 -g L2 -g L3 -g MEM ./tiling_par 1500 >> saida1.csv 2>> saida2.csv 
#+end_example


- A apartir do parâmetro =t= é possível definir a frequência em que será
  realizado a coleta dos contadores de hardware, os quais são
  respectivos para o grupo informado no parâmetro =g=. O grupo =MEM=
  disponibiliza uma série de eventos para compreender o comportamento
  da memória, existem outros grupos de evento, como =L2CACHE= (todos
  eventos na l2).

- Agora vou tentar compreender quais eventos posso utilizar no trace,
  porque preciso retirar eventos que necessito para minha análise.

#+begin_src sh :results output :exports both
sudo likwid-perfctr -e | grep -i cache
#+end_src

#+RESULTS:
#+begin_example
L3_LAT_CACHE_REFERENCE, 0x2E, 0x4F, PMC
L3_LAT_CACHE_MISS, 0x2E, 0x41, PMC
CACHE_LOCK_CYCLES_SPLIT_LOCK_UC_LOCK_DURATION, 0x63, 0x1, PMC
CACHE_LOCK_CYCLES_CACHE_LOCK_DURATION, 0x63, 0x2, PMC
ICACHE_HITS, 0x80, 0x1, PMC
ICACHE_MISSES, 0x80, 0x2, PMC
ICACHE_ACCESSES, 0x80, 0x3, PMC
ICACHE_IFETCH_STALL, 0x80, 0x4, PMC
TXT_INSERTS_AD_CACHE, 0x2, 0x1, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
TXT_INSERTS_AK_CACHE, 0x2, 0x2, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
TXT_INSERTS_BL_CACHE, 0x2, 0x4, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
TXT_INSERTS_IV_CACHE, 0x2, 0x8, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
TXR_BL_DRS_CACHE, 0x10, 0x1, BBOX
#+end_example

#+begin_src sh :results output :exports both
sudo likwid-perfctr -e | grep -i HIT
#+end_src

#+RESULTS:
#+begin_example
This architecture has 97 counters.
This architecture has 727 events.
L2_RQSTS_ALL_DEM_AND_DATA_RD_HIT, 0x24, 0x1, PMC
L2_RQSTS_RFO_HITS, 0x24, 0x4, PMC
L2_RQSTS_CODE_RD_HITS, 0x24, 0x10, PMC
L2_RQSTS_PF_HIT, 0x24, 0x40, PMC
L2_STORE_LOCK_RQSTS_HIT_E, 0x27, 0x4, PMC
L2_STORE_LOCK_RQSTS_HIT_M, 0x27, 0x8, PMC
L1D_WB_RQST_HIT_E, 0x28, 0x4, PMC
L1D_WB_RQST_HIT_M, 0x28, 0x8, PMC
DTLB_STORE_MISSES_STLB_HIT, 0x49, 0x10, PMC
LOAD_HIT_PRE_SW_PF, 0x4C, 0x1, PMC
LOAD_HIT_PRE_HW_PF, 0x4C, 0x2, PMC
ICACHE_HITS, 0x80, 0x1, PMC
ITLB_MISSES_STLB_HIT, 0x85, 0x10, PMC
MEM_LOAD_UOPS_RETIRED_L1_HIT, 0xD1, 0x1, PMC
MEM_LOAD_UOPS_RETIRED_L2_HIT, 0xD1, 0x2, PMC
MEM_LOAD_UOPS_RETIRED_L3_HIT, 0xD1, 0x4, PMC
MEM_LOAD_UOPS_RETIRED_HIT_LFB, 0xD1, 0x40, PMC
MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_MISS, 0xD2, 0x1, PMC
MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_HIT, 0xD2, 0x2, PMC
MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_HITM, 0xD2, 0x4, PMC
MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_NONE, 0xD2, 0x8, PMC
CBOX_MISC_RFO_HIT_S, 0x39, 0x8, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
WPQ_READ_HIT, 0x23, 0x0, MBOX
WPQ_WRITE_HIT, 0x24, 0x0, MBOX
#+end_example


#+begin_src sh :results output :exports both
sudo likwid-perfctr -e | grep -i miss
#+end_src

#+RESULTS:
#+begin_example
DTLB_LOAD_MISSES_CAUSES_A_WALK, 0x8, 0x1, PMC
DTLB_LOAD_MISSES_WALK_COMPLETED, 0x8, 0x2, PMC
DTLB_LOAD_MISSES_WALK_DURATION, 0x8, 0x4, PMC
L2_RQSTS_ALL_DEM_AND_DATA_RD_MISS, 0x24, 0x2, PMC
L2_RQSTS_RFO_MISS, 0x24, 0x8, PMC
L2_RQSTS_CODE_RD_MISS, 0x24, 0x20, PMC
L2_RQSTS_PF_MISS, 0x24, 0x80, PMC
L2_RQSTS_MISS, 0x24, 0xAA, PMC
L2_STORE_LOCK_RQSTS_MISS, 0x27, 0x1, PMC
L3_LAT_CACHE_MISS, 0x2E, 0x41, PMC
L1D_PEND_MISS_PENDING, 0x48, 0x1, PMC1
DTLB_STORE_MISSES_CAUSES_A_WALK, 0x49, 0x1, PMC
DTLB_STORE_MISSES_WALK_COMPLETED, 0x49, 0x2, PMC
DTLB_STORE_MISSES_WALK_DURATION, 0x49, 0x4, PMC
DTLB_STORE_MISSES_STLB_HIT, 0x49, 0x10, PMC
HW_PRE_REQ_DL1_MISS, 0x4E, 0x2, PMC
ICACHE_MISSES, 0x80, 0x2, PMC
ITLB_MISSES_CAUSES_A_WALK, 0x85, 0x1, PMC
ITLB_MISSES_WALK_COMPLETED, 0x85, 0x2, PMC
ITLB_MISSES_WALK_DURATION, 0x85, 0x4, PMC
ITLB_MISSES_STLB_HIT, 0x85, 0x10, PMC
OTHER_ASSISTS_ITLB_MISS_RETIRED, 0xC1, 0x2, PMC
MEM_UOPS_RETIRED_LOADS_STLB_MISS, 0xD0, 0x11, PMC
MEM_UOPS_RETIRED_STORES_STLB_MISS, 0xD0, 0x12, PMC
MEM_LOAD_UOPS_RETIRED_L1_MISS, 0xD1, 0x8, PMC
MEM_LOAD_UOPS_RETIRED_L2_MISS, 0xD1, 0x10, PMC
MEM_LOAD_UOPS_RETIRED_L3_MISS, 0xD1, 0x20, PMC
MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_MISS, 0xD2, 0x1, PMC
MEM_LOAD_UOPS_MISC_RETIRED_LLC_MISS, 0xD4, 0x2, PMC
ISMQ_DRD_MISS_OCC, 0x21, 0x0, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
LLC_VICTIMS_MISS, 0x37, 0x8, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
LLC_VICTIMS_NID_MISSES, 0x37, 0x41, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1, NID|
TOR_INSERTS_MISS_OPCODE, 0x35, 0x3, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1, OPCODE|
TOR_INSERTS_MISS_ALL, 0x35, 0xA, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
TOR_INSERTS_NID_MISS_OPCODE, 0x35, 0x43, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1, OPCODE|NID|
TOR_INSERTS_NID_MISS_ALL, 0x35, 0x4A, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
TOR_OCCUPANCY_MISS_OPCODE, 0x36, 0x3, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0, OPCODE|
TOR_OCCUPANCY_MISS_ALL, 0x36, 0xA, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0
TOR_OCCUPANCY_NID_MISS_OPCODE, 0x36, 0x43, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0, OPCODE|NID|
TOR_OCCUPANCY_NID_MISS_ALL, 0x36, 0x4A, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0, NID|
PRE_COUNT_PAGE_MISS, 0x2, 0x1, MBOX
#+end_example

- Um dos problemas é que não achei uma maneira de usa um evento
  individual com a ferramenta, só dar pra usar um ou mais grupos
  específicos de eventos. Por exemplo para o grupo L2, temos cerca de:

#+begin_src sh :results output :exports both
sudo likwid-perfctr -E L2 | wc -l
#+end_src

#+RESULTS:
#+begin_example
46
#+end_example

- Se executamos uma aplicação qualquer coletando os eventos do grupo
  L2, chegaremos no seguinte resultado para a primeira linha do
  trace, teremos o número de colunas igual a:

#+begin_src sh :results output :exports both
sudo likwid-perfctr -t 20ms -f -c N:0-31 -g L2 ./tiling_par 1500 >> saida1.csv 2>> saida2.csv 
#contando quantas colunas a primeira linha da tabela gerada possui
cat saida2.csv | head -3 | grep -i 1[[:space:]]10 | 
sed 's/[[:space:]]/_/g' | grep -o "_" | wc -l
#+end_src

#+RESULTS:
#+begin_example
320
#+end_example

- O que pode estar ocorrendo é que para cada core foram realizadas =10
  medidas= nesse time stamp, as quais pertencem ao grupo L2. O grupo L2
  disponibiliza cerca de 45 events.

#+begin_src sh :results output :exports both
sudo likwid-perfctr -E L2 | head -1
#+end_src

#+RESULTS:
#+begin_example
Found 45 event(s) with search key L2:
#+end_example

- O tempo total de execução da aplicação foi aproximadamente de 2 segundos e o tempo
  de cada amostragem foi realizado de acordo com o intervalo de 20ms
  (o que representa 0,02 segundos), corresponderia a =100 medidas= e
  pelos valores apresentarem o mesmo tipo, essa alternativa também
  não explica rastro gerado.

#+begin_src sh :results output :exports both
cat saida2.csv | head -4
#+end_src

#+RESULTS:
#+begin_example
# CORES: 0|2|4|6|8|10|12|14|1|3|5|7|9|11|13|15|16|18|20|22|24|26|28|30|17|19|21|23|25|27|29|31
1 10 32 0.020565900340284 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 6.4515176738843e-05 0.0 0.0001469359025298 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.011959422262748 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.1932560084084e-05 0.0 0.0 0.0 0.0 0.0 0.0 2399.212467893 0.0 2397.7659509024 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2400.0290461965 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2400.9239098063 0.0 0.0 0.0 0.0 0.0 0.0 5.7336473515819 0.0 4.1062934913227 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.58535669192174 0.0 0.0 0.0 0.0 0.0 0.0 0.0 19.920526793824 0.0 0.0 0.0 0.0 0.0 0.0 3.404802846571 0.0 8.8820943823592 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 267.84449059692 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.28990169164644 0.0 0.0 0.0 0.0 0.0 0.0 7.0656e-05 0.0 0.00018432 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.005558272 0.0 0.0 0.0 0.0 0.0 0.0 0.0 6.016e-06 0.0 0.0 0.0 0.0 0.0 0.0 0.83886446944503 0.0 1.6623086361429 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 231.35080211551 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.086353695384047 0.0 0.0 0.0 0.0 0.0 0.0 1.7408e-05 0.0 3.4496e-05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.00480096 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.792e-06 0.0 0.0 0.0 0.0 0.0 0.0 13.779582534854 0.0 29.977068540462 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 512.12059047509 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.99306749691655 0.0 0.0 0.0 0.0 0.0 0.0 0.000285952 0.0 0.00062208 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.010627456 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0608e-05 0.0 0.0 0.0 0.0 0.0 0.0
1 10 32 0.052882378871277 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.010691572789483 0.0020462021055553 0.018534346274703 0.016790309496927 0.0087798075522169 0.0089623325522428 0.0012850935205041 0.0014472769648044 0.017818854314618 0.018055624963249 0.018252697503128 0.018400905909144 0.013262310332 0.013484195939854 0.013694852516946 0.013936062677739 0.0 0.030057526842369 0.0 0.0 0.0 0.0 0.0 0.0002432716664409 0.0 0.024131956109313 0.013494352467677 0.013751853173099 0.013994558837989 0.014225544470772 0.014449581084519 0.01465725865345 2399.9798445053 2399.9987033006 2399.9850731856 2399.9944972654 2399.9921951233 2399.9966386715 2399.9896900871 2399.9950835058 2399.997398544 2399.9907003085 2399.9949373242 2399.9928382905 2399.9879963119 2399.9932472319 2399.9946519569 2399.9942001861 0.0 2399.9762183369 0.0 0.0 0.0 0.0 0.0 2401.3655156302 0.0 2399.9920328742 2399.99618193 2399.9947341332 2399.9935109656 2399.9930034416 2399.9963318802 2399.9951445039 1.8530922327127 6.9445810488161 0.74169923571061 2.1212525705097 1.6547947919044 1.6414444434473 1.8235766987343 2.6656689944661 2.3406562999204 4.9804609682778 4.3610016472638 4.3927487445439 5.4649123981763 5.4263224643841 5.4851839954628 5.5035852619806 0.0 1.3760982767871 0.0 0.0 0.0 0.0 0.0 4.8004222822977 0.0 4.8483234512698 6.8474819194727 6.6684602860755 6.8964428757107 6.8182144102454 6.9271475857645 6.9372478795018 3910.9793322531 249.80878251538 4155.6510456273 4176.3294882079 4271.9723346873 4352.5361215074 562.57078760839 459.78900843437 3919.7565613537 1113.3750162358 1160.3829018767 1185.731611335 1189.4413427856 1260.1686184454 1237.5893031856 1245.9378821307 0.0 3833.6046128203 0.0 0.0 0.0 0.0 0.0 27.435854194559 0.0 1513.947464443 1541.2239774803 1673.1113266379 1582.7424480406 1597.877613741 1590.1821091166 1608.5018537211 0.111531072 0.007123904 0.11850848 0.119098176 0.121825664 0.124123136 0.016043072 0.013112 0.111781376 0.031750592 0.033091136 0.033814016 0.033919808 0.035936768 0.035292864 0.035530944 0.0 0.109324544 0.0 0.0 0.0 0.0 0.0 0.0007824 0.0 0.043173888 0.043951744 0.047712832 0.045135744 0.04556736 0.045347904 0.045870336 11.97078497127 0.64858583740102 36.222060261773 12.161545511682 12.379236951917 12.596928392152 1.8492551211711 29.794552170713 11.526425124193 3.6087405762659 5.2739678819806 4.4772620955538 3.7209526588612 4.5311238951995 4.111450706293 4.2461052054074 0.0 130.16601581059 0.0 0.0 0.0 0.0 0.0 2.2823937599891 0.0 5.4175993477026 4.591718419801 5.8619591947802 5.5477653635132 5.1550230744296 5.8148301200901 5.5836732299437 0.000341376 1.8496e-05 0.00103296 0.000346816 0.000353024 0.000359232 5.2736e-05 0.000849664 0.000328704 0.000102912 0.0001504 0.00012768 0.000106112 0.000129216 0.000117248 0.000121088 0.0 0.003712 0.0 0.0 0.0 0.0 0.0 6.5088e-05 0.0 0.000154496 0.000130944 0.000167168 0.000158208 0.000147008 0.000165824 0.000159232 3932.5218078698 250.51123015243 4425.8285653754 4188.8860202504 4284.4368528219 4365.2632159154 565.1135134 489.90448716131 3931.778963883 1117.300194885 1166.1730453386 1190.5544866449 1193.3642771931 1264.8994798476 1241.8960029156 1250.3882133264 0.0 3971.3628981393 0.0 0.0 0.0 0.0 0.0 43.863703086515 0.0 1520.0248708364 1545.8448710416 1679.0877421569 1588.3149000622 1603.0573234736 1596.0373355864 1614.1236790592 0.112145408 0.007143936 0.126213248 0.119456256 0.12218112 0.12448608 0.016115584 0.013970816 0.112124224 0.031862528 0.033256256 0.033951552 0.03403168 0.03607168 0.03541568 0.035657856 0.0 0.113253056 0.0 0.0 0.0 0.0 0.0 0.00125088 0.0 0.0433472 0.04408352 0.047883264 0.045294656 0.045715072 0.04551488 0.04
#+end_example


- Na minha visão, as medidas atribuídas ao =core 0=
  são:

#+begin_src sh :results output :exports both
cat saida2.csv | awk ' { print $1,$2,$3,$4,$5,$6,$7,$8, $9, $10 } '
#+end_src

#+RESULTS:
#+begin_example
# CORES: 0|2|4|6|8|10|12|14|1|3|5|7|9|11|13|15|16|18|20|22|24|26|28|30|17|19|21|23|25|27|29|31              

1 10 32 0.020565900340284 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727
1 10 32 0.052882378871277 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494
1 10 32 0.09635633496818 0.037663742679823 0.037663742679823 0.037663742679823 0.037663742679823 0.037663742679823 0.037663742679823
1 10 32 0.14175093632669 0.038175362581406 0.038175362581406 0.038175362581406 0.038175362581406 0.038175362581406 0.038175362581406
1 10 32 0.19055983303866 0.037408529480667 0.037408529480667 0.037408529480667 0.037408529480667 0.037408529480667 0.037408529480667
1 10 32 0.23373419581483 0.035995958110927 0.035995958110927 0.035995958110927 0.035995958110927 0.035995958110927 0.035995958110927
1 10 32 0.2707095811089 0.031250161109816 0.031250161109816 0.031250161109816 0.031250161109816 0.031250161109816 0.031250161109816
1 10 32 0.30574692159369 0.030901274154041 0.030901274154041 0.030901274154041 0.030901274154041 0.030901274154041 0.030901274154041
1 10 32 0.34345025038196 0.034008777167045 0.034008777167045 0.034008777167045 0.034008777167045 0.034008777167045 0.034008777167045
1 10 32 0.38945874792224 0.038910133594311 0.038910133594311 0.038910133594311 0.038910133594311 0.038910133594311 0.038910133594311
1 10 32 0.45076335586621 0.054312018287774 0.054312018287774 0.054312018287774 0.054312018287774 0.054312018287774 0.054312018287774
1 10 32 0.50110384527398 0.043193507828615 0.043193507828615 0.043193507828615 0.043193507828615 0.043193507828615 0.043193507828615
1 10 32 0.54653061972063 0.038292795903114 0.038292795903114 0.038292795903114 0.038292795903114 0.038292795903114 0.038292795903114
1 10 32 0.58794866868538 0.034191524667682 0.034191524667682 0.034191524667682 0.034191524667682 0.034191524667682 0.034191524667682
1 10 32 0.62532758108491 0.031971041584668 0.031971041584668 0.031971041584668 0.031971041584668 0.031971041584668 0.031971041584668
1 10 32 0.69713587080372 0.054595953565615 0.054595953565615 0.054595953565615 0.054595953565615 0.054595953565615 0.054595953565615
1 10 32 0.75864096929694 0.054518049352196 0.054518049352196 0.054518049352196 0.054518049352196 0.054518049352196 0.054518049352196
1 10 32 0.81967775350721 0.053879670103356 0.053879670103356 0.053879670103356 0.053879670103356 0.053879670103356 0.053879670103356
1 10 32 0.86361384387013 0.038013580638204 0.038013580638204 0.038013580638204 0.038013580638204 0.038013580638204 0.038013580638204
1 10 32 0.90010770384505 0.032637677910919 0.032637677910919 0.032637677910919 0.032637677910919 0.032637677910919 0.032637677910919
1 10 32 0.96178581031223 0.054615402118894 0.054615402118894 0.054615402118894 0.054615402118894 0.054615402118894 0.054615402118894
1 10 32 1.0234256361745 0.054492634782573 0.054492634782573 0.054492634782573 0.054492634782573 0.054492634782573 0.054492634782573
1 10 32 1.068888123719 0.038391344673089 0.038391344673089 0.038391344673089 0.038391344673089 0.038391344673089 0.038391344673089
1 10 32 1.114830458078 0.038656629899838 0.038656629899838 0.038656629899838 0.038656629899838 0.038656629899838 0.038656629899838
1 10 32 1.1528937623525 0.0314080670424 0.0314080670424 0.0314080670424 0.0314080670424 0.0314080670424 0.0314080670424
1 10 32 1.1882726477729 0.031378069960223 0.031378069960223 0.031378069960223 0.031378069960223 0.031378069960223 0.031378069960223
1 10 32 1.2501763858582 0.054638963683441 0.054638963683441 0.054638963683441 0.054638963683441 0.054638963683441 0.054638963683441
1 10 32 1.3122447273944 0.054866458306663 0.054866458306663 0.054866458306663 0.054866458306663 0.054866458306663 0.054866458306663
1 10 32 1.374278135835 0.054689566322067 0.054689566322067 0.054689566322067 0.054689566322067 0.054689566322067 0.054689566322067
1 10 32 1.4203290264914 0.038867854478487 0.038867854478487 0.038867854478487 0.038867854478487 0.038867854478487 0.038867854478487
1 10 32 1.4630186349396 0.035465177156853 0.035465177156853 0.035465177156853 0.035465177156853 0.035465177156853 0.035465177156853
1 10 32 1.5008432540601 0.034009647169428 0.034009647169428 0.034009647169428 0.034009647169428 0.034009647169428 0.034009647169428
1 10 32 1.54686985015 0.038571888167688 0.038571888167688 0.038571888167688 0.038571888167688 0.038571888167688 0.038571888167688
1 10 32 1.5906067714673 0.038611618276528 0.038611618276528 0.038611618276528 0.038611618276528 0.038611618276528 0.038611618276528
1 10 32 1.6511031856972 0.055176146655054 0.055176146655054 0.055176146655054 0.055176146655054 0.055176146655054 0.055176146655054
1 10 32 1.6933346513903 0.036808871837904 0.036808871837904 0.036808871837904 0.036808871837904 0.036808871837904 0.036808871837904
1 10 32 1.7293196254711 0.031210933502352 0.031210933502352 0.031210933502352 0.031210933502352 0.031210933502352 0.031210933502352
1 10 32 1.7643075513205 0.03045094742037 0.03045094742037 0.03045094742037 0.03045094742037 0.03045094742037 0.03045094742037
1 10 32 1.824618709543 0.054997413165413 0.054997413165413 0.054997413165413 0.054997413165413 0.054997413165413 0.054997413165413
1 10 32 1.8849542533322 0.054928345976204 0.054928345976204 0.054928345976204 0.054928345976204 0.054928345976204 0.054928345976204
1 10 32 1.945161144269 0.054922520460245 0.054922520460245 0.054922520460245 0.054922520460245 0.054922520460245 0.054922520460245
1 10 32 1.9889136441289 0.038486636434141 0.038486636434141 0.038486636434141 0.038486636434141 0.038486636434141 0.038486636434141
1 10 32 2.0305064550724 0.036600271766445 0.036600271766445 0.036600271766445 0.036600271766445 0.036600271766445 0.036600271766445
1 10 32 2.0688733331785 0.033605387561959 0.033605387561959 0.033605387561959 0.033605387561959 0.033605387561959 0.033605387561959
1 10 32 2.1128902892629 0.038715660061551 0.038715660061551 0.038715660061551 0.038715660061551 0.038715660061551 0.038715660061551
1 10 32 2.1727482732439 0.054482756255511 0.054482756255511 0.054482756255511 0.054482756255511 0.054482756255511 0.054482756255511
1 10 32 2.2246024697985 0.046505758902527 0.046505758902527 0.046505758902527 0.046505758902527 0.046505758902527 0.046505758902527
1 10 32 2.2703944237455 0.038628239822063 0.038628239822063 0.038628239822063 0.038628239822063 0.038628239822063 0.038628239822063
1 10 32 2.3078289247973 0.033431525585664 0.033431525585664 0.033431525585664 0.033431525585664 0.033431525585664 0.033431525585664
1 10 32 2.3536088117113 0.038578614186114 0.038578614186114 0.038578614186114 0.038578614186114 0.038578614186114 0.038578614186114
1 10 32 2.4153674908992 0.054461493197261 0.054461493197261 0.054461493197261 0.054461493197261 0.054461493197261 0.054461493197261
1 10 32 2.4596523962177 0.037190238882659 0.037190238882659 0.037190238882659 0.037190238882659 0.037190238882659 0.037190238882659
1 10 32 2.50484396302 0.038172488573532 0.038172488573532 0.038172488573532 0.038172488573532 0.038172488573532 0.038172488573532
1 10 32 2.5401693267939 0.031285784207406 0.031285784207406 0.031285784207406 0.031285784207406 0.031285784207406 0.031285784207406
#+end_example


- E para calcular a quantidade de amostras obtidas nessa execução,
  basta analisar a quantidade de linhas do rastro.

#+begin_src sh :results output :exports both
cat saida2.csv | awk ' { print $1,$2,$3,$4,$5,$6,$7,$8, $9, $10 } ' | wc -l
#+end_src

#+RESULTS:
#+begin_example
56
#+end_example

- Mas ainda não tenho certeza se estou interpretando da maneira
  correta esses dados. Vou pesquisar a fundo para ver se compreendo
  melhor, para poder quem sabe utilizar no trabalho. A única certeza
  que tenho, é que essa ferramenta é capaz de obter valores de
  hardware counters em determinados time stamps com intervalo definido
  em sua chamada.

- Minha nova hipótese é compreender o rastro executado sem a flag =-t=,
  o qual vai dar os valores gerais da aplicação. Para facilitar vou
  usar apenas 3 cores da máquina com a flag =g= L2CACHE.

#+begin_src sh :results output :exports both
sudo likwid-perfctr -f -c N:0-2 -g L2CACHE ./tiling_par 1000
#+end_src

#+RESULTS:
#+begin_example
--------------------------------------------------------------------------------
CPU name:	Intel(R) Xeon(R) CPU E5-2650 0 @ 2.00GHz
CPU type:	Intel Xeon SandyBridge EN/EP processor
CPU clock:	2.00 GHz
--------------------------------------------------------------------------------
HPCELO:0.754494
--------------------------------------------------------------------------------
Group 1: L2CACHE
+-----------------------+---------+------------+------------+------------+
|         Event         | Counter |   Core 0   |   Core 2   |   Core 4   |
+-----------------------+---------+------------+------------+------------+
|   INSTR_RETIRED_ANY   |  FIXC0  |  259597918 |  227622878 |  228575555 |
| CPU_CLK_UNHALTED_CORE |  FIXC1  | 1545967853 | 1495134372 | 1369348491 |
|  CPU_CLK_UNHALTED_REF |  FIXC2  | 1280368520 | 1240280360 | 1136446600 |
| L2_TRANS_ALL_REQUESTS |   PMC0  |  45267891  |  41824466  |  40804495  |
|     L2_RQSTS_MISS     |   PMC1  |   3155817  |   3057749  |   3013421  |
+-----------------------+---------+------------+------------+------------+

+----------------------------+---------+------------+------------+------------+--------------+
|            Event           | Counter |     Sum    |     Min    |     Max    |      Avg     |
+----------------------------+---------+------------+------------+------------+--------------+
|   INSTR_RETIRED_ANY STAT   |  FIXC0  |  715796351 |  227622878 |  259597918 | 2.385988e+08 |
| CPU_CLK_UNHALTED_CORE STAT |  FIXC1  | 4410450716 | 1369348491 | 1545967853 | 1.470150e+09 |
|  CPU_CLK_UNHALTED_REF STAT |  FIXC2  | 3657095480 | 1136446600 | 1280368520 | 1.219032e+09 |
| L2_TRANS_ALL_REQUESTS STAT |   PMC0  |  127896852 |  40804495  |  45267891  |   42632284   |
|     L2_RQSTS_MISS STAT     |   PMC1  |   9226987  |   3013421  |   3155817  | 3.075662e+06 |
+----------------------------+---------+------------+------------+------------+--------------+

+----------------------+-----------+-----------+-----------+
|        Metric        |   Core 0  |   Core 2  |   Core 4  |
+----------------------+-----------+-----------+-----------+
|  Runtime (RDTSC) [s] |   0.7747  |   0.7747  |   0.7747  |
| Runtime unhalted [s] |   0.7730  |   0.7476  |   0.6847  |
|      Clock [MHz]     | 2414.8745 | 2410.9569 | 2409.8724 |
|          CPI         |   5.9552  |   6.5685  |   5.9908  |
|    L2 request rate   |   0.1744  |   0.1837  |   0.1785  |
|     L2 miss rate     |   0.0122  |   0.0134  |   0.0132  |
|     L2 miss ratio    |   0.0697  |   0.0731  |   0.0739  |
+----------------------+-----------+-----------+-----------+

+---------------------------+-----------+-----------+-----------+-----------+
|           Metric          |    Sum    |    Min    |    Max    |    Avg    |
+---------------------------+-----------+-----------+-----------+-----------+
|  Runtime (RDTSC) [s] STAT |   2.3241  |   0.7747  |   0.7747  |   0.7747  |
| Runtime unhalted [s] STAT |   2.2053  |   0.6847  |   0.7730  |   0.7351  |
|      Clock [MHz] STAT     | 7235.7038 | 2409.8724 | 2414.8745 | 2411.9013 |
|          CPI STAT         |  18.5145  |   5.9552  |   6.5685  |   6.1715  |
|    L2 request rate STAT   |   0.5366  |   0.1744  |   0.1837  |   0.1789  |
|     L2 miss rate STAT     |   0.0388  |   0.0122  |   0.0134  |   0.0129  |
|     L2 miss ratio STAT    |   0.2167  |   0.0697  |   0.0739  |   0.0722  |
+---------------------------+-----------+-----------+-----------+-----------+

#+end_example

- De acordo com esse rastro temos 7 métricas: =runtime, runtime
  unhalted, clock, cpi, l2 request rate, l2 miss rate e l2 miss ratio.=

- Agora vamos usar a flag de coleta de amostras =-t=.

#+begin_src sh :results output :exports both
sudo likwid-perfctr -f -c N:0-2 -t 10ms -g L2CACHE ./tiling_par 1000
#+end_src

#+RESULTS:
#+begin_example
--------------------------------------------------------------------------------
CPU name:	Intel(R) Xeon(R) CPU E5-2650 0 @ 2.00GHz
CPU type:	Intel Xeon SandyBridge EN/EP processor
CPU clock:	2.00 GHz
--------------------------------------------------------------------------------
# CORES: 0|2|4

1 7 3 0.010573361522728 0.010745079788388 0.010745079788388 0.010745079788388 5.6303038027946e-06 4.9915693376356e-05 0.0 2759.6550066658 2752.9126734128 0.0 7.7441540577717 8.3795853269537 0.0 0.60935350756534 0.64123226727105 0.0 0.043328748280605 0.11743473516327 0.0 0.071106094808126 0.18313915433957 0.0
1 7 3 0.022230624531154 0.010941246373242 0.010941246373242 0.010941246373242 0.0067392261385897 0.0016780195434315 0.0 2698.8054448841 2696.7957783433 0.0 3.0040481254852 1.2030139714692 0.0 0.000612501312264 0.033356730244606 0.0 6.2186268603223e-05 0.002719442833268 0.0 0.10152838427948 0.081526061257388 0.0
1 7 3 0.033958172832069 0.011116052305508 0.011116052305508 0.011116052305508 0.0098067031550738 0.013199397719812 0.0012918937086574 2399.8592420269 2427.407676498 2399.87049958 5.1462188216753 4.7451571657302 6.2816477470271 0.10215084094262 0.079442021796462 0.19980257767426 0.0048879289828106 0.0037740339632498 0.018008708950379 0.047850110069638 0.047506771327135 0.090132515606177
1 7 3 0.045659982744179 0.011162559314957 0.011162559314957 0.011162559314957 0.013485559160656 0.013842753434326 0.01378715393426 2399.8661393683 2399.871626524 2399.871544031 6.5293515815294 6.6912184445897 6.7143825287085 0.20037564213961 0.19092514196838 0.19953849124724 0.017137522645415 0.0092413891450235 0.017188473677661 0.085526975546633 0.04840320687861 0.086141142845288
1 7 3 0.057391977285006 0.011204004051253 0.011204004051253 0.011204004051253 0.013547369995877 0.013873926116358 0.013877902330908 2399.8717396738 2399.8707590596 2399.8714507328 6.802012087488 6.4768928959343 6.982905982906 0.20147261184491 0.2011163195024 0.18573534440009 0.017540239113641 0.017032381015519 0.013315781912526 0.087060166406851 0.084689204027104 0.071692234752277
1 7 3 0.069103656229635 0.011193457982203 0.011193457982203 0.011193457982203 0.013550135645107 0.013915513360343 0.01392851106168 2399.8535847394 2399.8716206315 2399.871791894 6.8063859767216 6.8976698465558 6.668615144405 0.20127995820545 0.19823195551906 0.17414732253687 0.017458519407844 0.016504127890881 0.009050761687455 0.086737495195739 0.083256646728149 0.051971868160873
1 7 3 0.080875692931077 0.011188059190892 0.011188059190892 0.011188059190892 0.013556877508888 0.013900381543853 0.013892741131588 2399.8637723861 2399.8697226232 2399.8724862306 6.9334321474868 6.6570551089463 6.7003750755734 0.20135122728764 0.18022778268689 0.17626960296202 0.017576848846312 0.006242950638304 0.011677431630642 0.087294470876018 0.034639224570331 0.066247563019462
1 7 3 0.092609377563099 0.011190261809742 0.011190261809742 0.011190261809742 0.013545322385391 0.013895842298922 0.013885422736698 2399.878915799 2399.8712767912 2399.8686847285 6.7400245126335 6.5832068934885 6.6590539364879 0.20164228673113 0.1931249888958 0.18148231100743 0.017515635138955 0.014129993189423 0.010118307097754 0.086864890410164 0.07316501748537 0.055753682227135
1 7 3 0.10432676531577 0.011183485944126 0.011183485944126 0.011183485944126 0.013513926691326 0.01389451772745 0.013904693276508 2399.8785801602 2399.87049958 2399.8682557354 6.7981353570315 6.7496245355426 6.636684202751 0.18742944390224 0.20167135425409 0.17914371434838 0.0087899566350401 0.017320309621242 0.011796344033105 0.046897416179843 0.085883836528513 0.065848495304529
1 7 3 0.11609043606579 0.011187237646563 0.011187237646563 0.011187237646563 0.013544869360946 0.013888970928153 0.013877890830288 2399.8666900255 2399.8700675827 2399.8673867191 6.9382436546507 6.6055011989164 6.6760230418338 0.20128359268664 0.20160535661076 0.17671700052053 0.017554181422151 0.017110391393961 0.0098123593440755 0.087211188889497 0.084870718127772 0.055525836875755
1 7 3 0.12775990273271 0.011157207526182 0.011157207526182 0.011157207526182 0.01348178095679 0.013826532059045 0.013877287797749 2399.8600855708 2399.8701524214 2399.8689430809 6.9086310141519 6.9034008238672 6.6835477972386 0.20123479566553 0.20141330670328 0.17506930251006 0.017436524225722 0.017146673324179 0.011115614479848 0.08664766035146 0.085131780043904 0.063492653026414
1 7 3 0.13950400642693 0.011161757771707 0.011161757771707 0.011161757771707 0.013512882134963 0.01386956188087 0.01383575905692 2399.8635728764 2399.8693748154 2399.8719740212 6.8234615949812 6.8945716387144 6.6848549155866 0.20214402330212 0.20156565404236 0.17573421601363 0.017463712896711 0.017378342282875 0.010083805826763 0.086392427594115 0.086216783139171 0.057381004425344
1 7 3 0.1512141497887 0.011170082720908 0.011170082720908 0.011170082720908 0.013520441042831 0.013894548729123 0.013898079419634 2399.8697007898 2399.8717086879 2399.8700678658 6.7116626562965 6.8871432020078 6.6677795362028 0.17941570552647 0.20178025362938 0.17535455773931 0.0084267417806441 0.017281804423916 0.010733829386713 0.046967693022844 0.085646658248621 0.061212149402298
1 7 3 0.16292188702064 0.011148574060333 0.011148574060333 0.011148574060333 0.013468477738968 0.013824039924573 0.013858508784462 2399.8760236023 2399.8708468013 2399.8672091872 6.7490794888184 6.9481403702597 6.6681764715365 0.20183242800218 0.20196728266035 0.17901894121024 0.017415983857635 0.01727649044695 0.011294424701069 0.086289324416426 0.085541035257695 0.06309066864497
1 7 3 0.17466626222951 0.011182931914232 0.011182931914232 0.011182931914232 0.013541271166793 0.013983241014827 0.013968223204488 2399.8521557999 2399.8709286652 2399.8721318575 6.8894964304776 6.6790223325323 6.5750076200586 0.2024098028431 0.20277951729478 0.17477389903393 0.017788590452068 0.017340397125761 0.0077542186880319 0.087884036258151 0.085513553622642 0.044367143669013
1 7 3 0.18649943772991 0.011210605907479 0.011210605907479 0.011210605907479 9.7060237225618e-06 0.013956611077915 0.013937019520784 2384.5150628249 2399.8708435031 2399.8717911051 12.011757425743 6.8753911354536 6.5578870889606 0.75742574257426 0.20220930103666 0.17546646288166 0.095915841584158 0.017358617912113 0.0081642621306936 0.1266339869281 0.085844804482885 0.046528903567171
1 7 3 0.19812760666846 0.011088567822487 0.011088567822487 0.011088567822487 0.010645319405556 0.0028818094981418 0.013673111280689 2399.8544926518 2399.868833961 2399.8693586552 1.8101790105013 6.8451009013482 6.3998048562201 0.17918030001906 0.2045023463082 0.20142849553227 0.016123223001881 0.017876124903648 0.017380621880959 0.089983234765014 0.087412810788522 0.08628680780756
1 7 3 0.20927873286651 0.010757641466197 0.010757641466197 0.010757641466197 0.0046559212265643 0.0 0.0081223387692841 2399.8735924199 0.0 2399.8741931032 1.8590069300433 0.0 3.3001146033892 0.1355402353192 0.0 0.21115263054496 0.01373830027366 0.0 0.019995965213067 0.10135957224293 0.0 0.094699105388643
1 7 3 0.22019453936705 0.010616318340613 0.010616318340613 0.010616318340613 2.4938845662911e-05 0.0015296185359345 0.0 2406.9647113609 2495.1725930828 0.0 1.1125362480482 2.6699134284146 0.0 0.077693508811064 0.00014662794990561 0.0 0.022886459959848 4.363927080524e-06 0.0 0.29457364341085 0.029761904761905 0.0
1 7 3 0.24127119613184 0.020743380281685 0.020743380281685 0.020743380281685 0.022562213923408 0.022888218014102 0.010045238526087 2399.9931001951 2400.2223478764 2399.8706190396 5.9257728609227 5.9023639904724 6.6832915656574 0.13535065118242 0.14097600678358 0.18695684139894 0.0063915935488099 0.0080041860988097 0.012900240293049 0.047222480963137 0.056776938724737 0.069001167309636
1 7 3 0.2528572642987 0.011052951900705 0.011052951900705 0.011052951900705 0.013331448845093 0.013702527867964 0.013752764078635 2399.8707696182 2399.8698865546 2399.8680564373 6.8979105597454 6.5722741873089 6.4704329400594 0.19886446839062 0.18563867331259 0.17710923331468 0.017624671746245 0.0093928083283348 0.0091229100339777 0.088626549975866 0.050597260585452 0.051510075805978
1 7 3 0.26452923960098 0.011097146785395 0.011097146785395 0.011097146785395 0.013464587529058 0.013824960474245 0.013785577849217 2399.8778076613 2399.8702391815 2399.8708477701 6.5159006992422 6.553086572496 6.4573679760346 0.19845947495255 0.18826369127781 0.17192498401448 0.017600227652357 0.013325919510726 0.0083937425781534 0.088684239724833 0.070783269042895 0.048822122196308
1 7 3 0.27620621567309 0.011132543195332 0.011132543195332 0.011132543195332 0.013434185388604 0.01378531733516 0.01380439236442 2399.8791640741 2399.8693679418 2399.8683263607 6.5695124041571 6.559973264367 6.4836890239248 0.19796426920042 0.17959987445959 0.17581067557923 0.017483458800867 0.010914115467192 0.010861536777815 0.088316234396654 0.06076905955548 0.061779734035092
1 7 3 0.2877602731127 0.011043636898082 0.011043636898082 0.011043636898082 0.013324614976348 0.013693751394399 0.013729030798023 2399.8741019409 2399.8754945694 2399.8687514608 6.4792430644472 6.604785945175 6.4626192355836 0.18048217343246 0.17329142379481 0.17202829595798 0.0075442630970576 0.0085416450112881 0.0083850336658254 0.041800599768822 0.04929063899551 0.04874217708855
1 7 3 0.2993642837477 0.011052184859317 0.011052184859317 0.011052184859317 0.013344492548912 0.013732582489667 0.013724976079236 2399.8619567603 2399.8686645296 2399.8690132396 6.7484456791182 6.5592010311802 6.4557614589093 0.19855505748844 0.18441445725352 0.17724110307709 0.017557940444862 0.011148191075954 0.0078614151864431 0.088428573247921 0.060451828137465 0.044354357143805
1 7 3 0.31096081497914 0.011038358113246 0.011038358113246 0.011038358113246 0.013324205954278 0.013731228416603 0.013707454133778 2399.8847294054 2399.8690139163 2399.8730383474 6.6079580256502 6.5500879078364 6.4406424894375 0.19851394573866 0.17575103298565 0.17199204288964 0.017573708797245 0.0097677759043082 0.0094501845373902 0.08852631855084 0.055577345625647 0.054945475259305
1 7 3 0.32252896217901 0.011026675982896 0.011026675982896 0.011026675982896 0.013300046150651 0.013689429161177 0.013684015369057 2399.869146202 2399.8709378745 2399.8706749672 6.8676875767329 6.5609782400565 6.3948271321559 0.18509223434456 0.1816534336155 0.17674705098723 0.012319084744056 0.0091481439498423 0.0093394459097045 0.066556464606307 0.050360424065562 0.052840745333732
1 7 3 0.33408162104315 0.011024544867904 0.011024544867904 0.011024544867904 0.013293752311045 0.013640870041 0.013616557729144 2399.8768183544 2399.8743703071 2399.8682082542 6.4553064805658 6.5553221219523 6.416371668071 0.19827179085115 0.17800216025539 0.17396010638799 0.017247855581776 0.0074366611438781 0.0067856745665971 0.086990970867485 0.041778488155472 0.039007072986393
1 7 3 0.34560507733157 0.011042701347601 0.011042701347601 0.011042701347601 0.013299385615009 0.013699601710073 0.01376304763352 2399.8712214181 2399.872339051 2399.8678838832 6.4256056558724 6.555164977774 6.3807915631874 0.19841431091885 0.17445962652076 0.18751957441314 0.017390010274751 0.0064210062152431 0.01367374903997 0.087644939491605 0.0368051126974 0.072919049026019
1 7 3 0.3572119591215 0.011035245445291 0.011035245445291 0.011035245445291 0.013334847528481 0.013624193141139 0.013741835988972 2399.8582610323 2399.8708518945 2399.870936203 6.5644646989872 6.4887637613084 6.4660094511976 0.1986590582491 0.18147613817463 0.17351570670466 0.017553399148016 0.0083141783985681 0.0092323872332366 0.088359419916338 0.045814168640548 0.053207789707194
1 7 3 0.36882015148214 0.011035777974026 0.011035777974026 0.011035777974026 4.5510455676301e-05 0.013704794990295 0.01367088866076 2400.0814586605 2399.8697115349 2399.8731329157 1.6753672274786 6.4310979210941 6.5086085753185 0.078378676876634 0.18129062095462 0.17979677844098 0.021113279092884 0.0081517027159124 0.0056862804379431 0.26937529356505 0.044964834214743 0.031626153078207
1 7 3 0.38033946154684 0.011015089857726 0.011015089857726 0.011015089857726 0.013321079785594 0.013585018027308 0.013511049536079 2399.866355779 2399.8699695845 2399.8684568093 1.7422979633324 6.289115461228 5.3112399249525 0.18847536448291 0.18408286235788 0.18516642440361 0.016628488441827 0.01341084993177 0.013091050615781 0.088226323304631 0.072852245776672 0.070698835698454
1 7 3 0.39134308678595 0.010673192409453 0.010673192409453 0.010673192409453 0.0055996431483914 0.013148892994652 0.0098407159903557 2399.8846434218 2399.8682180213 2399.8717190041 2.1574470544492 6.1812355952024 1.8602690117715 0.12495111458741 0.177710393785 0.1561404643061 0.010874812886869 0.0099068573006834 0.013763935922499 0.087032540067994 0.055747202454962 0.088150986252459
1 7 3 0.40235892968431 0.010654655909251 0.010654655909251 0.010654655909251 0.0011462353491496 0.013156169387275 0.0015752399976005 2399.9573958762 2413.9724321174 2404.0630782634 3.8458132781266 5.1917524857779 3.3672267470446 0.0026037516168593 0.14868987318043 0.02619765279292 0.00033050197714 0.015668441916955 0.0017593364543919 0.12693298969072 0.10537665801854 0.067156262749898
1 7 3 0.41380625036456 0.011034654913427 0.011034654913427 0.011034654913427 0.013239049859382 0.013615759686082 0.013672879768197 2403.3160790883 2403.222295715 2403.1676141145 6.1241312551537 6.0968868094779 6.024237256956 0.14200657594195 0.14639487244476 0.14256126564068 0.0084379304402735 0.0081171513641731 0.0095995963908708 0.059419293679207 0.055446964969595 0.067336638375996
1 7 3 0.42539912839887 0.011041047258348 0.011041047258348 0.011041047258348 0.013371203990222 0.013737145735893 0.013730015351148 2399.8529994137 2399.8691892649 2399.8709365789 6.724038954769 6.736022955549 6.6370029810081 0.2020357462559 0.1824608660409 0.1941382450073 0.017534926526055 0.01018513955284 0.016414035513468 0.086791208244138 0.055820953686346 0.084548181183211
1 7 3 0.43699949183708 0.011029705146345 0.011029705146345 0.011029705146345 0.013368017818301 0.013762239589919 0.013759428438234 2399.8756162807 2399.8713715315 2399.8729415444 6.9541272925104 6.6484355411049 6.5904505980351 0.20207750399865 0.1837655232054 0.20135318321382 0.017671841871637 0.011907183249311 0.017453428942314 0.087450812297022 0.064795523347447 0.08668067056968
1 7 3 0.44864491570668 0.011031622249789 0.011031622249789 0.011031622249789 1.581085313005e-05 0.013770745048861 0.013758368381035 2395.3252903005 2399.8708481451 2399.8701507015 19.566831683168 6.6964930466145 6.8251350193565 0.84282178217822 0.18134192935322 0.20143203738398 0.13613861386139 0.010816269314723 0.017400152153352 0.16152716593245 0.059645716538368 0.086382247726475
1 7 3 0.46024553165852 0.011035239444968 0.011035239444968 0.011035239444968 0.0083485029727671 0.013717106154587 0.013739032337691 2399.874093044 2399.8694497964 2399.8675299423 6.6762842249385 6.6807262100457 6.555752660862 0.20032605461915 0.18376328767123 0.19988036887615 0.017474752160102 0.0062434094368341 0.017194767056919 0.087231549552175 0.033975281548097 0.086025291796281
1 7 3 0.47190865548319 0.01106719366917 0.01106719366917 0.01106719366917 0.01273434312616 0.0137915061691 0.013741510971434 2399.87049958 2399.8729358646 2399.8728574017 6.7007551050961 6.6811450723949 6.7507098533965 0.2009686204749 0.18210709928122 0.20033280020123 0.017482212971789 0.0080149932308092 0.017271564030754 0.086989764523824 0.044012524840846 0.086214359373027
1 7 3 0.48361924136884 0.011164567923338 0.011164567923338 0.011164567923338 0.013509299941673 0.013883056609026 0.013917515468374 2399.8838238085 2399.8683386746 2399.8712755809 6.747869962633 6.7623422067827 6.8540988495291 0.20323377548795 0.17708229566739 0.20077673221355 0.017616501111568 0.0073798598995706 0.017320965835061 0.086680971552449 0.041674747166324 0.086269786563902
1 7 3 0.49535583615789 0.011143249773043 0.011143249773043 0.011143249773043 0.012069466250395 0.013860694902421 0.013859060814248 2399.864732976 2399.8737894629 2399.8692873773 6.5858596386589 6.6833527702627 6.7608106252291 0.20219182776641 0.17843583390214 0.20026729430498 0.017377299035844 0.0093215286033885 0.017224603077226 0.085944616198433 0.052240227758853 0.086008068052267
1 7 3 0.50701730389319 0.011107941867881 0.011107941867881 0.011107941867881 0.013437316557557 0.013874414142691 0.013900904072048 2399.8832700549 2399.8721428938 2399.8708448814 6.3270648580358 6.5879497539194 6.7128985467702 0.20296406831761 0.17746842169118 0.2004654546719 0.017596433342484 0.0095124899360872 0.017375831466581 0.086697283358293 0.05360102854039 0.086677435246985
1 7 3 0.51872466560487 0.011065568081455 0.011065568081455 0.011065568081455 9.6245193247061e-06 0.013731104909939 0.013617832297917 2393.9006724666 2399.87049958 2399.8707639393 11.910891089109 6.598168948533 6.6876050839579 0.7450495049505 0.18505282840338 0.18844108999766 0.11076732673267 0.0074973491489765 0.015044670888155 0.14867109634551 0.040514642297894 0.079837528472914
1 7 3 0.52977610042371 0.010667041077536 0.010667041077536 0.010667041077536 0.010179999797604 0.0027457841584174 0.013088702246849 2399.8663738503 2399.87049958 2399.8712330372 1.9298372450826 6.4719695451813 6.5006855573031 0.19863391238843 0.17392011503058 0.17394554432455 0.016627165745474 0.01046000447865 0.010332407750262 0.083707588223701 0.060142580269168 0.059400243854384
1 7 3 0.54079667507739 0.010686310617291 0.010686310617291 0.010686310617291 0.012894462765976 0.0 0.013204804011527 2399.8673354353 0.0 2399.870408704 2.0714357836475 0.0 6.6255099936425 0.18753467617085 0.0 0.17534272626507 0.015545206400682 0.0 0.010914152470976 0.082892437377926 0.0 0.062244683332213
1 7 3 0.55219400606028 0.010960918434717 0.010960918434717 0.010960918434717 0.0049097569231598 0.013647692409124 0.013855198605849 2399.8548573597 2399.8669825071 2399.8675548406 1.9847201164112 1.8975657422023 6.4972733115623 0.15741995262456 0.19867488386984 0.17057085180964 0.013205009854892 0.016566454469642 0.0074689948664583 0.083883965372457 0.083384744699264 0.043788225169878
1 7 3 0.56357815333179 0.01070776577498 0.01070776577498 0.01070776577498 5.3577890983076e-06 0.010718182337131 0.013584522000543 2429.5741121504 2475.3323557235 2481.4764274429 6.6305693069307 1.7556043860281 6.282289325099 0.48514851485149 0.16185024737524 0.16996021016212 0.065594059405941 0.013863202111062 0.012493319992203 0.13520408163265 0.085654500600924 0.073507322568532
1 7 3 0.5745329224347 0.010627249430438 0.010627249430438 0.010627249430438 5.0642732606309e-06 0.0017101297760518 0.013615742685165 2488.3178152894 2499.8651037292 2499.866572618 6.2673267326733 2.8890624353249 6.3254141424841 0.48886138613861 0.00016725784147842 0.1926715834363 0.079826732673267 0.0 0.0075345092603498 0.16329113924051 0.0 0.039105451494049
1 7 3 0.58547335726415 0.010597709836526 0.010597709836526 0.010597709836526 5.0057701038878e-06 0.0 0.0099600379287895 2521.5264033686 0.0 2499.8652292307 6.1949257425743 0.0 4.9568027317533 0.50556930693069 0.0 0.099905487545409 0.093440594059406 0.0 0.0038474382844621 0.18482252141983 0.0 0.038510780328392
1 7 3 0.59635805608617 0.010557238152735 0.010557238152735 0.010557238152735 0.023972788035883 0.024273611767883 0.024450355804727 2402.0596244836 2402.2729405747 2402.2424267234 5.8760828066658 5.8996278506999 5.8199589611261 0.13915753207652 0.14512218509074 0.14211911985422 0.0071945047220831 0.008836814075318 0.0070788486739135 0.051700433420499 0.060892234152845 0.04980926339239
1 7 3 0.62082458776352 0.011043971416132 0.011043971416132 0.011043971416132 0.013346611663257 0.013719185266772 0.013702760880537 2399.8696903862 2399.8699747676 2399.8707623008 6.6364106502676 6.5249090000205 6.3938116567655 0.20074683846753 0.1783028842701 0.18176137988897 0.017466592044149 0.0096681384255589 0.009409882254564 0.087008055406932 0.054223118516207 0.051770526061764
1 7 3 0.63242529922051 0.011051710333712 0.011051710333712 0.011051710333712 0.01341313525277 0.013764415707339 0.013732743498354 2399.8639686862 2399.8699764922 2399.8695383741 6.7098290576912 6.3904581933666 6.2885921515343 0.19992070718188 0.17865385820776 0.17834351588657 0.01762201588858 0.010461118449613 0.0082518294020481 0.088145025780387 0.058555233872686 0.046269298667951
1 7 3 0.64404780085326 0.011068879760149 0.011068879760149 0.011068879760149 0.013406316884861 0.013732135965573 0.013689009638541 2399.8700520299 2399.8724220793 2399.8710255495 6.4458118983314 6.5551004527954 6.3253449400437 0.20102445645772 0.17743780328581 0.17478618072578 0.017511829620765 0.0087601711886536 0.0095696212007613 0.087112931079846 0.049370376697817 0.054750445149751
1 7 3 0.65562232389716 0.011064741036829 0.011064741036829 0.011064741036829 0.013378327374589 0.013751262997639 0.013736442697958 2399.8671807841 2399.8699759919 2399.8700627858 6.5823545576818 6.4714044180369 6.2680043050115 0.19986926422625 0.17752789952055 0.1759015186414 0.016777921645627 0.010429626143483 0.0086755062233062 0.08394448096149 0.058749222920177 0.049320246296409
1 7 3 0.6672738455958 0.011094641150195 0.011094641150195 0.011094641150195 0.013460581812916 0.013786456896649 0.013804209854572 2399.8632785172 2399.8713699998 2399.8699780001 6.4611503563271 6.4866327459435 6.4146906943414 0.20031221228131 0.17813343797987 0.17172951485511 0.017426332014528 0.0069438905879051 0.0086462730708246 0.086995854202114 0.038981398813455 0.050348206469456
1 7 3 0.67891896944921 0.011079351825205 0.011079351825205 0.011079351825205 0.013421157185622 0.013757782349413 0.013757324824726 2399.8671019642 2399.87049958 2399.8702379013 6.386266733668 6.8876892362958 6.3394769185253 0.20066149500441 0.19384029989924 0.17631188573941 0.017470063556056 0.012366462853674 0.0084714793222264 0.087062361195265 0.063797171486539 0.048048259972373
1 7 3 0.69053741786326 0.011083092027021 0.011083092027021 0.011083092027021 0.013413071249317 0.013756489279641 0.013778722479312 2399.8611057951 2399.868929413 2399.8682352213 6.5917816197168 6.7515933852212 6.3045873515911 0.19953433110164 0.19991410652999 0.18050832586136 0.017391443241842 0.017175749083087 0.0096868315693839 0.087160155076183 0.085915643379126 0.053664181544865
1 7 3 0.70218682344771 0.011086688221066 0.011086688221066 0.011086688221066 0.013424055342002 0.013776128839363 0.013768076904892 2399.8767570199 2399.872154618 2399.8722427441 6.4927353340861 6.6304415630173 6.3577785766948 0.20104781835107 0.2000262803614 0.18108307743745 0.017416721222905 0.017250217438704 0.012076576885484 0.086629744932083 0.086239755133863 0.066690808751336
1 7 3 0.71380242320805 0.011060590812889 0.011060590812889 0.011060590812889 0.013402500678944 0.013719212268229 0.013692733339466 2399.8722007563 2399.868400336 2399.8695355654 6.4814824666508 6.5713406381377 6.3324747119467 0.19375272796739 0.20036917611741 0.17693196749402 0.01367774135786 0.017170258114318 0.0099891914991627 0.070593800156257 0.085693111320958 0.056457810539523
1 7 3 0.72543062364831 0.011119812508403 0.011119812508403 0.011119812508403 0.013435730972001 0.013845577086686 0.01387617473769 2399.8765729531 2399.870152899 2399.8673863341 6.3582823038221 6.485835571626 6.3425923195965 0.20004349280854 0.20093688565043 0.17834593470599 0.017337019100395 0.017313107146898 0.0088629006766824 0.086666248709162 0.086161916418954 0.049694996924339
1 7 3 0.73730186120248 0.011251882634709 0.011251882634709 0.011251882634709 9.8565318437555e-06 0.013987064721148 0.013888204886819 2380.5478707589 2399.8660383235 2399.8704131758 12.19801980198 6.3818750734349 6.1790914448397 0.82487623762376 0.20055462585569 0.1758800867545 0.10024752475248 0.017295839621641 0.0070247206719136 0.12153038259565 0.086240043319098 0.039940398037891
1 7 3 0.74872741970848 0.010994850765655 0.010994850765655 0.010994850765655 2.7335975008435e-05 0.013702381360059 0.013671030168395 2403.9599886679 2429.6839366508 2429.7456898442 1.0240516999157 6.2087465771023 6.1871659109389 0.063369860447691 0.20329305079823 0.17114049838886 0.019106490587244 0.018190353670357 0.01133874596932 0.30150753768844 0.089478482412128 0.066254019802818
1 7 3 0.75976450775319 0.010676234073576 0.010676234073576 0.010676234073576 0.0006929793921343 0.010997886929573 0.0091589022007006 2400.6257379851 2476.5390346363 2473.3671183208 3.4099966044811 3.9685582162065 4.5442406127257 0.015995846640651 0.14123514965417 0.079419694867688 0.0048521472966256 0.014514604369989 0.0049600870899301 0.303337948008 0.10276906567189 0.062454119197933
HPCELO:0.740614
#+end_example

- Vou tentar compreender os dados novamente, mas agora comparando com
  a execução sem a flag de amostragem.

#+begin_src sh :results output :exports both
rm dados/likwid-exec2withheader.txt
echo "- - - timestamp C0runtime_rdstc C0runtime_unshall C0clock COcpi C0l2reqrate C0l2missrate C0l2missratio C2runtime_rdstc C2runtime_unshall C2clock C2cpi C2l2reqrate C2l2missrate C2l2missratio C4runtime_rdstc C4runtime_unshall C4clock C4cpi C4l2reqrate C4l2missrate C4l2missratio"  >> dados/likwid-exec2withheader.txt
cat dados/liwkid-exec2.txt | grep -i "1 7" | head -8  >> dados/likwid-exec2withheader.txt
#+end_src

#+RESULTS:

#+begin_src sh :results output :exports both
cat dados/likwid-exec2withheader.txt | awk ' { print $1,$25 } '
#+end_src

#+RESULTS:
: - C4l2missratio
: 1 0.0
: 1 0.0
: 1 0.090132515606177
: 1 0.086141142845288
: 1 0.071692234752277
: 1 0.051971868160873
: 1 0.066247563019462
: 1 0.055753682227135

- Agora o traço gerado está compreendido e o experimento pode ser
  realizado. 

* [23:15:57; 11.08.2016] Experimentando a ferramenta =tau=            :Gabriel:
- Agora vou testar a ferramenta =tau=, ela utiliza PAPI, da mesma
  maneira que =scorep=, vamos visualizar se para o mesmo teste no
  benchmark da multiplicação de matrizes, o problema que encontramos
  com scorep, não é encontrado quando utilizamos a ferramenta =tau=.

** Instalação do tau

- Vale lembrar que estou instalando o tau com objetivo de usar pela
  sua ferramenta de trace os hardware counters do =PAPI=, para detectar
  as regiões =memory-bound=. De acordo com o uso, a instalação dessa
  ferramenta pode mudar.

#+begin_src sh :results output :exports both
cd $HOME/Programs/
wget http://tau.uoregon.edu/tau.tgz
tar vxf tau.tgz
rm -rf tau.tgz
cd tau-2.25.1/
./configure -papi=/usr/local/bin/ -PAPIWALLCLOCK -PAPIVIRTUAL -cc=gcc -PROFILE -TRACE -openmp
sudo make install
#+end_src

** Experimento teste

#+begin_src sh :results output :exports both
export TAU_MAKEFILE=$HOME/Programs/tau-2.25.1/x86_64/lib/Makefile.tau-papi-openmp-profile-trace
/home/aulapinroot/Programs/tau-2.25.1/tools/src/tau_cc.sh hpcelo.c tiling.c -o mainTest
export TAU_METRICS=TIME:PAPI_FP_INS:PAPI_L1_DCM
export OMP_NUM_THREADS=32
./mainTest 100
#+end_src

- Foi gerado vários arquivos:

#+begin_src sh :results output :exports both
cd benchmarks/MM/
ls
#+end_src

#+RESULTS:
#+begin_example
continuos.c          tautrace.0.0.14.trc  tautrace.0.0.29.trc
continuosT.c         tautrace.0.0.15.trc  tautrace.0.0.2.trc
events.0.edf         tautrace.0.0.16.trc  tautrace.0.0.30.trc
hpcelo.c             tautrace.0.0.17.trc  tautrace.0.0.31.trc
hpcelo.h             tautrace.0.0.18.trc  tautrace.0.0.3.trc
hpcelo.o             tautrace.0.0.19.trc  tautrace.0.0.4.trc
log                  tautrace.0.0.1.trc   tautrace.0.0.5.trc
mainTest             tautrace.0.0.20.trc  tautrace.0.0.6.trc
Makefile             tautrace.0.0.21.trc  tautrace.0.0.7.trc
normal.c             tautrace.0.0.22.trc  tautrace.0.0.8.trc
normalT.c            tautrace.0.0.23.trc  tautrace.0.0.9.trc
tautrace.0.0.0.trc   tautrace.0.0.24.trc  tiling.c
tautrace.0.0.10.trc  tautrace.0.0.25.trc  tiling.o
tautrace.0.0.11.trc  tautrace.0.0.26.trc  tilingT.c
tautrace.0.0.12.trc  tautrace.0.0.27.trc
tautrace.0.0.13.trc  tautrace.0.0.28.trc
#+end_example

- Não sei como funciona esses arquivos =.trc=, será que é possível
  interpretá-los através de algum recurso parecido com o =otf2-print=,
  visto que esses arquivos são binários e não de texto. Tenho que
  descobrir como fazer...
* [22:20:30; 12.08.2016] Benchmark Rodinia           '              :Gabriel:

#+begin_src sh :results output :exports both
cd $HOME/Programs/
wget http://www.cs.virginia.edu/~kw5na/lava/Rodinia/Packages/Current/rodinia_3.1.tar.bz2
tar -xvjf rodinia_3.1.tar.bz2
rm -rf rodinia_3.1.tar.bz2
cd rodinia_3.1/
ls
#+end_src

#+RESULTS:
#+begin_example
bin
common
cuda
data
LICENSE
Makefile
opencl
openmp
others
README
#+end_example

* [01:13:21; 13.08.2016] Experimento com o benchmark Rodinia        :Gabriel:

- Defini o seguinte script para executar algumas aplicações que
  julguei interessantes no benchmark rodinia, a primeira é a aplicação
  =k_means=, um problema de mineração de dados. Outra aplicação
  escolhida foi o =BFS=, algoritmo de busca em largura em grafo. Já
  aplicação =leucocity= processa uma imagem médica para rastrear
  determinados pontos. Ambos algoritmos escolhidos possuem
  comportamentos diferentes, o que permite comparar o quanto as
  regiões paralelas são memory-bound nas diferentes abordagens.


#+begin_src sh :results output :exports both :tangle benchmarks/rod/scriptOfExecutionRod.bash
#!bin/bash

mkdir log_rodiniaExp1

benchpath=$HOME/Programs/rodinia_3.1/openmp

kmeans_command=$benchpath/kmeans/kmeans_openmp/kmeans -i ../../../data/kmeans/819200.txt -n 32
bfs_command=$benchpath/bfs/bfs 32 ../../data/bfs/graph1MW_6.txt
leukocyte_command=$benchpath/leukocyte/OpenMP/leukocyte 30 32 ../../../data/leukocyte/testfile.avi

#aqui o rastro vai ter cerca de 11 amostras 
sudo likwid-perfctr -t 1ms -f -c N:0-31 -g L2CACHE $bfs_command >> log_rodiniaExp1/saidaBfs_2.log 2>> log_rodiniaExp1/saidaBfs_1.log

#aqui o rastro vai ter cerca de 27 amostras
sudo likwid-perfctr -t 10ms -f -c N:0-31 -g L2CACHE $k_means_command >> log_rodiniaExp1/saidaKmeans_2.log 2>> log_rodiniaExp1/saidaKmeans_1.log

#aqui o rastro vai ter cerca de 24 amostras
sudo likwid-perfctr -t 50ms -f -c N:0-31 -g L2CACHE $leukocyte_command >> log_rodiniaExp1/saidaLeucocyte_2.log 2>> log_rodiniaExp1/saidaLeucocyte_1.log

#+end_src


#+RESULTS
#+begin_example
aulapinroot@beagle1:~/Doc/dissertacao_gbmoro/benchmarks/rod/log_rodiniaExp1$
total 628K                                                                   
 ls -larth                                                                  
total 628K                                                                  
drwxrwxr-x 3 aulapinroot aulapinroot 4,0K Ago 13 10:42 ..                   
-rw-rw-r-- 1 aulapinroot aulapinroot   96 Ago 13 10:42 saidaBfs_1.log       
-rw-rw-r-- 1 aulapinroot aulapinroot  401 Ago 13 10:42 saidaBfs_2.log       
-rw-rw-r-- 1 aulapinroot aulapinroot   96 Ago 13 10:42 saidaKmeans_1.log    
-rw-rw-r-- 1 aulapinroot aulapinroot  363 Ago 13 10:42 saidaKmeans_2.log    
drwxrwxr-x 2 aulapinroot aulapinroot 4,0K Ago 13 10:42 .                    
-rw-rw-r-- 1 aulapinroot aulapinroot 600K Ago 13 10:42 saidaLeucocyte_1.log 
-rw-rw-r-- 1 aulapinroot aulapinroot 1,6K Ago 13 10:42 saidaLeucocyte_2.log
-rw-rw-r-- 1 aulapinroot aulapinroot  401 Ago 13 10:42 saidaBfs_2.log       
-rw-rw-r-- 1 aulapinroot aulapinroot   96 Ago 13 10:42 saidaKmeans_1.log    
-rw-rw-r-- 1 aulapinroot aulapinroot  363 Ago 13 10:42 saidaKmeans_2.log    
drwxrwxr-x 2 aulapinroot aulapinroot 4,0K Ago 13 10:42 .                    
-rw-rw-r-- 1 aulapinroot aulapinroot 600K Ago 13 10:42 saidaLeucocyte_1.log 
-rw-rw-r-- 1 aulapinroot aulapinroot 1,6K Ago 13 10:42 saidaLeucocyte_2.log
#+end_example

- Pelo tamanho do rastro é possível visualizar que nas aplicações
  =k_means= e =bfs= a amostragem não ocorreu, por que o tempo de execução
  dessas aplicações foi muito rápido. Problema é que os benchmarks
  executam muito rápidos, rápidos demais. E não consigo configurá-los
  ao ponto de alterar suas entradas para o default (32 threads
  disponíveis na =beagle1=), o algoritmo =leukocyte= é o único que consigo alterar a entrada,
  aumentando o seu tempo de execução, mas os demais não. Como estou
  com o tempo apertado vou executar o benchmark do =NAS=, focando em
  algumas aplicações, o que o senhor acha professor?

* [12:59:49; 13.08.2016] Experimento com o benchmark NAS - L2 CACHE :Gabriel:
** Instalação do benchmark NAS

#+begin_src sh :results output :exports both
rm -rf /tmp/xxx/
mkdir -p /tmp/xxx/
cd /tmp/xxx/
wget http://www.nas.nasa.gov/assets/npb/NPB3.3.1.tar.gz
tar xf NPB3.3.1.tar.gz
cd NPB3.3.1/NPB3.3-OMP/config
cp make.def.template make.def
cp suite.def.template suit.def
pwd
#+end_src

- Após isso nos arquivos make.def deve ser definido o compilador c e
  fortran utilizado, como também a flag =openmp=. No suite.def deve ser
  definido a classe do algoritmo a ser compilado.

** Definições iniciais

- Primeiramente vou fazer um teste para ver mais ou menos o tempo de
  execução para cada algoritmo, usando =32 threads= (default openmp da
  máquina). 

|-----------+--------------+----------------+--------------|
| Aplicação | Execução (s) | TimeStamp (ms) | Amostras     |
|-----------+--------------+----------------+--------------|
| bt.B      |        37.56 | 100ms          | ~= 37        |
| cg.B      |        18.13 | 50ms           | ~= 36        |
| ep.B      |         3.52 | - Descartado   | - Descartado |
| ft.B      |         8.35 | 30ms           | ~= 27        |
| lu.B      |        34.08 | 100ms          | ~= 34        |
| mg.B      |          3.6 | - Descartado   | - Descartado |
| sp.B      |        83.85 | 225ms          | ~= 37        |
| ua.B      |        40.90 | 110ms          | ~= 37        |
|-----------+--------------+----------------+--------------|

- Na coluna =TimeStamp= e =Amostras= estou propondo uma configuração
  adequada para deixar próximo a quantidade de amostras de acordo com
  o tempo de execução de cada aplicação. O motivo de descartar algumas
  aplicações para o experimento é devido ao seu tempo de execução ser
  inferior a 4 segundos, isso porque na medida que eu defnir um
  =TimeStamp= muito pequeno para coletar as amostras, isso pode afetar
  os valores coletados. A maneira que encontro hoje de evitar isso é
  descartando essas aplicações, mas pretendo investigar como resolver
  tal problemática.

** Script do experimento

#+begin_src sh :results output :exports both :tangle scripts/scriptOfExecutionNAS.bash
#!bin/bash
rm -rf log_NASExp1
mkdir log_NASExp1

benchpath=/home/aulapinroot/Programs/NPB3.3.1/NPB3.3-OMP/bin

bt_command=$benchpath/bt.B.x
cg_command=$benchpath/cg.B.x
ft_command=$benchpath/ft.B.x
lu_command=$benchpath/lu.B.x
sp_command=$benchpath/sp.B.x
ua_command=$benchpath/ua.B.x

sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L2CACHE $bt_command >> log_NASExp1/saidaBt_2.log 2>> log_NASExp1/saidaBt_1.log 
sudo likwid-perfctr -t 50ms -f -c N:0-31 -g L2CACHE $cg_command >> log_NASExp1/saidaCg_2.log 2>> log_NASExp1/saidaCg_1.log 
sudo likwid-perfctr -t 30ms -f -c N:0-31 -g L2CACHE $ft_command >> log_NASExp1/saidaFt_2.log 2>> log_NASExp1/saidaFt_1.log 
sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L2CACHE $lu_command >> log_NASExp1/saidaLu_2.log 2>> log_NASExp1/saidaLu_1.log 
sudo likwid-perfctr -t 225ms -f -c N:0-31 -g L2CACHE $sp_command >> log_NASExp1/saidaSp_2.log 2>> log_NASExp1/saidaSp_1.log 
sudo likwid-perfctr -t 110ms -f -c N:0-31 -g L2CACHE $ua_command >> log_NASExp1/saidaUa_2.log 2>> log_NASExp1/saidaUa_1.log 

#+end_src
** Análise dos dados

- Acho que o primeiro passo é tratar os arquivos gerados pelo
  experimento que estão na extensão de =.log= para =.csv=, já formatando o
  arquivo e adicionando o cabeçalho apropriado para facilitar a
  análise utilizando R.

- Os arquivos gerados no experimento estão no diretório
  [[:benchmarks/NAS-OMP/log_NASExp1:]]. Os arquivos que possuem o =_1= são
  os rastros gerados pela ferramenta likwid, já o =_2= são as saídas que
  não fazem parte do rastro.

#+begin_src sh :results output :exports both :tangle scripts/exp1NAS_test.bash
cd benchmarks/NAS-OMP/log_NASExp1/

numberOfCores=32
count=0

tmp="timeStamp"
while [ $count -lt $numberOfCores ]
do
	tmp=$tmp",C'$count'runtime_rdstc,C'$count'runtime_unshall,C'$count'clock,C'$count'cpi,C'$count'l2reqrate,C'$count'l2missrate,C'$count'l2missratio"
	count=$(echo "$count+1" | bc)
done

echo "$tmp" >> btexp1L2CACHEg.csv

cat saidaBt_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> btexp1L2CACHEg.csv

cat btexp1L2CACHEg.csv

mv btexp1L2CACHEg.csv ../../../dados/
#+end_src

#+RESULTS:
#+begin_example
timeStamp,C'0'runtime_rdstc,C'0'runtime_unshall,C'0'clock,C'0'cpi,C'0'l2reqrate,C'0'l2missrate,C'0'l2missratio,C'1'runtime_rdstc,C'1'runtime_unshall,C'1'clock,C'1'cpi,C'1'l2reqrate,C'1'l2missrate,C'1'l2missratio,C'2'runtime_rdstc,C'2'runtime_unshall,C'2'clock,C'2'cpi,C'2'l2reqrate,C'2'l2missrate,C'2'l2missratio,C'3'runtime_rdstc,C'3'runtime_unshall,C'3'clock,C'3'cpi,C'3'l2reqrate,C'3'l2missrate,C'3'l2missratio,C'4'runtime_rdstc,C'4'runtime_unshall,C'4'clock,C'4'cpi,C'4'l2reqrate,C'4'l2missrate,C'4'l2missratio,C'5'runtime_rdstc,C'5'runtime_unshall,C'5'clock,C'5'cpi,C'5'l2reqrate,C'5'l2missrate,C'5'l2missratio,C'6'runtime_rdstc,C'6'runtime_unshall,C'6'clock,C'6'cpi,C'6'l2reqrate,C'6'l2missrate,C'6'l2missratio,C'7'runtime_rdstc,C'7'runtime_unshall,C'7'clock,C'7'cpi,C'7'l2reqrate,C'7'l2missrate,C'7'l2missratio,C'8'runtime_rdstc,C'8'runtime_unshall,C'8'clock,C'8'cpi,C'8'l2reqrate,C'8'l2missrate,C'8'l2missratio,C'9'runtime_rdstc,C'9'runtime_unshall,C'9'clock,C'9'cpi,C'9'l2reqrate,C'9'l2missrate,C'9'l2missratio,C'10'runtime_rdstc,C'10'runtime_unshall,C'10'clock,C'10'cpi,C'10'l2reqrate,C'10'l2missrate,C'10'l2missratio,C'11'runtime_rdstc,C'11'runtime_unshall,C'11'clock,C'11'cpi,C'11'l2reqrate,C'11'l2missrate,C'11'l2missratio,C'12'runtime_rdstc,C'12'runtime_unshall,C'12'clock,C'12'cpi,C'12'l2reqrate,C'12'l2missrate,C'12'l2missratio,C'13'runtime_rdstc,C'13'runtime_unshall,C'13'clock,C'13'cpi,C'13'l2reqrate,C'13'l2missrate,C'13'l2missratio,C'14'runtime_rdstc,C'14'runtime_unshall,C'14'clock,C'14'cpi,C'14'l2reqrate,C'14'l2missrate,C'14'l2missratio,C'15'runtime_rdstc,C'15'runtime_unshall,C'15'clock,C'15'cpi,C'15'l2reqrate,C'15'l2missrate,C'15'l2missratio,C'16'runtime_rdstc,C'16'runtime_unshall,C'16'clock,C'16'cpi,C'16'l2reqrate,C'16'l2missrate,C'16'l2missratio,C'17'runtime_rdstc,C'17'runtime_unshall,C'17'clock,C'17'cpi,C'17'l2reqrate,C'17'l2missrate,C'17'l2missratio,C'18'runtime_rdstc,C'18'runtime_unshall,C'18'clock,C'18'cpi,C'18'l2reqrate,C'18'l2missrate,C'18'l2missratio,C'19'runtime_rdstc,C'19'runtime_unshall,C'19'clock,C'19'cpi,C'19'l2reqrate,C'19'l2missrate,C'19'l2missratio,C'20'runtime_rdstc,C'20'runtime_unshall,C'20'clock,C'20'cpi,C'20'l2reqrate,C'20'l2missrate,C'20'l2missratio,C'21'runtime_rdstc,C'21'runtime_unshall,C'21'clock,C'21'cpi,C'21'l2reqrate,C'21'l2missrate,C'21'l2missratio,C'22'runtime_rdstc,C'22'runtime_unshall,C'22'clock,C'22'cpi,C'22'l2reqrate,C'22'l2missrate,C'22'l2missratio,C'23'runtime_rdstc,C'23'runtime_unshall,C'23'clock,C'23'cpi,C'23'l2reqrate,C'23'l2missrate,C'23'l2missratio,C'24'runtime_rdstc,C'24'runtime_unshall,C'24'clock,C'24'cpi,C'24'l2reqrate,C'24'l2missrate,C'24'l2missratio,C'25'runtime_rdstc,C'25'runtime_unshall,C'25'clock,C'25'cpi,C'25'l2reqrate,C'25'l2missrate,C'25'l2missratio,C'26'runtime_rdstc,C'26'runtime_unshall,C'26'clock,C'26'cpi,C'26'l2reqrate,C'26'l2missrate,C'26'l2missratio,C'27'runtime_rdstc,C'27'runtime_unshall,C'27'clock,C'27'cpi,C'27'l2reqrate,C'27'l2missrate,C'27'l2missratio,C'28'runtime_rdstc,C'28'runtime_unshall,C'28'clock,C'28'cpi,C'28'l2reqrate,C'28'l2missrate,C'28'l2missratio,C'29'runtime_rdstc,C'29'runtime_unshall,C'29'clock,C'29'cpi,C'29'l2reqrate,C'29'l2missrate,C'29'l2missratio,C'30'runtime_rdstc,C'30'runtime_unshall,C'30'clock,C'30'cpi,C'30'l2reqrate,C'30'l2missrate,C'30'l2missratio,C'31'runtime_rdstc,C'31'runtime_unshall,C'31'clock,C'31'cpi,C'31'l2reqrate,C'31'l2missrate,C'31'l2missratio
0.10093558788872,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.078669250968433,0.061730678505742,0.06812005584327,0.0842342805691,0.029186527697428,0.043639749416139,0.064533694611705,0.049827747707227,0.077229596561942,0.056916491942482,0.064462121917493,0.06978676036586,0.039682751178853,0.053260176521097,0.060669666626694,0.061107531314836,0.081091103040111,0.084310360275542,0.089570930050059,0.088598344910957,0.075744063030957,0.071260555864994,0.070168528901787,0.06912742907677,0.090558811730669,0.079545640346509,0.08952201191732,0.091951127008706,0.076420834867373,0.02561146449652,0.040553241040921,0.027881183155385,2406.0595569703,2399.9940707962,2406.9960856887,2405.6520813749,2400.0714850418,2399.9947525202,2407.3830192521,2399.9888877798,2399.9935808462,2399.9930448638,2399.9912165187,2400.0395373504,2399.9941831342,2399.9956505865,2399.9948326069,2399.9941749309,2405.867401282,2400.011008724,2405.3117987948,2405.3711138561,2399.9927746907,2399.9916857807,2406.7859675129,2400
...

#+end_example

- O próximo passo é fazer filtrar os demais arquivos obtidos no
  experimento com o benchmark NAS.
  
#+begin_src sh :results output :exports both :tangle scripts/exp2NAS_test_L2.bash

cd benchmarks/NAS-OMP/log_NASExp1/

numberOfCores=32

count=0

tmp="timeStamp"
while [ $count -lt $numberOfCores ]
do
	tmp=$tmp",C'$count'runtime_rdstc,C'$count'runtime_unshall,C'$count'clock,C'$count'cpi,C'$count'l2reqrate,C'$count'l2missrate,C'$count'l2missratio"
	count=$(echo "$count+1" | bc)
done

echo "$tmp" >> cgexp1L2CACHEg.csv
echo "$tmp" >> ftexp1L2CACHEg.csv
echo "$tmp" >> luexp1L2CACHEg.csv
echo "$tmp" >> spexp1L2CACHEg.csv
echo "$tmp" >> uaexp1L2CACHEg.csv

cat saidaCg_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> cgexp1L2CACHEg.csv
cat saidaFt_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> ftexp1L2CACHEg.csv
cat saidaLu_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> luexp1L2CACHEg.csv
cat saidaSp_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> spexp1L2CACHEg.csv
cat saidaUa_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> uaexp1L2CACHEg.csv


mv *.csv ../../../dados/
#+end_src

#+RESULTS:

- Todos os =.csv= do experimento foram gerados.

- Utilizando o script que o professor Lucas desenvolveu vou testar
  para as aplicações do benchmark NAS, começando pelo bt.


#+begin_src sh :results output
chmod 755 ./scripts/likwid2csv.sh
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaCg_1.log  > dados/exp1_NASandLikwid/cgB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaFt_1.log  > dados/exp1_NASandLikwid/ftB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaLu_1.log  > dados/exp1_NASandLikwid/luB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaSp_1.log  > dados/exp1_NASandLikwid/spB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaUa_1.log  > dados/exp1_NASandLikwid/uaB.csv

cd dados/exp1_NASandLikwid/
ls
#+end_src

#+RESULTS:
: cgB.csv
: extraction1
: ftB.csv
: luB.csv
: spB.csv
: uaB.csv

*** Plotando os gráficos para análise

A métrica utilizada para gerar os gráficos é a =M7=, essa métrica
apresenta a taxa de misses no segundo nível de cache L2 para cada
processador, esse valor é apresentado como porcentagem.

#+BEGIN_EXAMPLE
l2missrate = l2missrequests/totalOfInstructions
M7 = l2missrate

if M7 => min(M7_total) and M7 < mean(M7_total) then
		the region is memory-bound;
else
		the region is not memory-bound;
#+END_EXAMPLE


- No =eixo y= de cada gráfico é possível visualizar a porcentagem de
  cache misses na L2 de cada processador analisado, como a =beagle1=,
  plataforma na qual o experimento foi executado possui cerca de =32
  cores= é possível visualizar nos arquivos gerados 32 gráficos
  respectivos de cada core, apresentando o comportamento da
  aplicação. Já no =eixo x= é apresentado a frequência das amostras
  realizadas (=time stamp=).

- É possível visualizar também nos gráficos uma linha vermelha que é
  calculada pela média de cache misses total (cache
  L2). Possibilitando uma análise comparativa com as demais regiões da
  aplicação.

**** Aplicação CG

#+begin_src R :results output graphics :file "imagens/cgBNas_Analise.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp1_NASandLikwid/cgB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);
#+end_src

#+RESULTS:
[[file:imagens/cgBNas_Analise.pdf]]

- A aplicação CG tem uma característica interessante, ela é uma
  aplicação que realiza acessos irregulares a memória. No gráfico é
  possível ver que a maior porcentagem registrada de cache misses é de
  40%. Pontos que achei interessante no gráfico gerado:

	a) Para os cores 17 até 24 é possível visualizar um
           comportamento mais linear em 40% de cache misses.
    	b) Nos cores 25, 26, 27 e 28 é possível uma queda brusca na
           taxa de cache misses próximo ao =time stamp= 10
	c) A maioria dos núcleos de processamento apresentam um
           comportamento diferente no gráfico quando comparado com os
           demais, isso pode estar relacionado ao tipo de aplicação,
           pela irregularidade da sua carga. Poderíamos propor por exemplo
           neste tipo de aplicação, uma configuração de frequência
           adequada para cada núcleo de processamento.

- Um ponto que acharia interessante é separar os cores por afinidade,
  vou tentar fazer isso em R, dizendo que os cores 1,3,5,... pertencem
  a um socket e os outros a outro.

**** Aplicação FT

- A aplicação =FT= é a famosa transformada discreta de fourier, só que
  em uma versão de 3 dimensões.

#+begin_src R :results output graphics :file "imagens/ftBNas_Analise.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp1_NASandLikwid/ftB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/ftBNas_Analise.pdf]]

- Diferente da aplicação anterior, nessa aplicação visualizamos um
  comportamento mais homogêneo dos diferentes cores. Visualizamos
  também pequenos intervalos entre um pico de cache misses e um
  aumento na taxa de hit para a cache L2.

- O maior valor registrado de taxa de misses foi 30%.

**** Aplicação LU

- A aplicação =LU= define o método de Gauss-Seidel para resolver 'n'
  equações lineares com um 'x' que é desconhecido.

#+begin_src R :results output graphics :file "imagens/luBNas_Analise.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp1_NASandLikwid/luB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/luBNas_Analise.pdf]]

- A partir do gráfico gerado é possível visualizar um comportamento
  mais =memory-bound= do 17 ao 32º core, especificamente nos primeiros e
  últimos timestamps coletados (considerar que os cores não acessam a
  memória de maneira uniforme, arquitetura NUMA)

**** Aplicação SP

- Essa aplicação resolve o problema chamado =Scalar Penta-diagonal=. 

#+begin_src R :results output graphics :file "imagens/spBNas_Analise.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp1_NASandLikwid/spB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/spBNas_Analise.pdf]]

- Comparado as aplicações anteriores é possível visualizar que o maior
  índice de cache misses é inferior a taxa dos outros, o que pode não
  ser interessante usar esse gráfico no artigo.

**** Aplicação UA

- Essa aplicação define uma série de cálculos sobre uma malha
  adaptativa desistruturada, o que gera acessos irregulares a memória.


#+begin_src R :results output graphics :file "imagens/uaBNas_Analise.pdf" :exports both :session *RFib* 

library(dplyr);
df <- read.csv("dados/exp1_NASandLikwid/uaB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/uaBNas_Analise.pdf]]

- É possível visualizar um comportamento totalmente heterogêneo entre
  os núcleos de processamento, de maneira geral, a taxa de misses na
  cache L2 é baixa, mas durante a execução se altera com um intervalo
  pequeno das frequências. O interessante seria, realizar um
  refinamento maior das amostras para podermos compreender melhor o
  comportamento da taxa de misses em uma granularidade mais fina de
  amostragem.

* 2016-08-14 Attempt to correctly parse =likwid-perfcrt= log file (timeline mode) :Lucas:

See here how Gabriel obtained the timeline logs:
- [[*Script do experimento][Script do experimento]]

So, Gabriel has generated these files:
#+begin_src sh :results output
find benchmarks/NAS-OMP/log_* | grep _1
#+end_src

#+RESULTS:
: benchmarks/NAS-OMP/log_NASExp1/saidaFt_1.log
: benchmarks/NAS-OMP/log_NASExp1/saidaSp_1.log
: benchmarks/NAS-OMP/log_NASExp1/saidaBt_1.log
: benchmarks/NAS-OMP/log_NASExp1/saidaUa_1.log
: benchmarks/NAS-OMP/log_NASExp1/saidaLu_1.log
: benchmarks/NAS-OMP/log_NASExp1/saidaCg_1.log

The man page of the tool is quite nice:

#+begin_src sh :results output
man likwid-perfctr
#+end_src

#+RESULTS:
#+begin_example
LIKWID-PERFCTR(1)           General Commands Manual          LIKWID-PERFCTR(1)

NAME
       likwid-perfctr  -  configure and read out hardware performance counters
       on x86 CPUs

SYNOPSIS
       likwid-perfctr [-vhHmaief] [-c  core_list]  [-C  core_list_for_pinning]
       [-g  performance_group  or  performance_event_string] [-t timeline_fre‐
       quency] [-S monitoring_time] [-T group_switch_frequency] [-V verbosity]
       [-M access_mode] [-o output_file] [-s skip_mask] [-E search_str]

DESCRIPTION
       likwid-perfctr  is  a lightweight command line application to configure
       and read out hardware performance monitoring data on supported x86 pro‐
       cessors. It can measure either as wrapper without changing the measured
       application or with marker API functions inside the  code,  which  will
       turn  on  and  off  the  counters.  There are preconfigured performance
       groups with useful event sets and derived metrics. Additionally,  arbi‐
       trary events can be measured with custom event sets. The marker API can
       measure multiple named regions and the  results  are  accumulated  over
       multiple region calls.

OPTIONS
       -v, --version
              prints version information to standard output, then exits.

       -h, --help
              prints a help message to standard output, then exits.

       -H     prints group help message (use together with -g switch).

       -V <level>, --verbose <level>
              verbose  output  during  execution  for  debugging.  0  for only
              errors, 1 for informational output, 2 for detailed output and  3
              for developer output

       -m     run in marker API mode

       -a     print  available  performance groups for current processor, then
              exit.

       -e     print available counters and performance events of current  pro‐
              cessor.

       -o, --output <filename>
              store  all  output to a file instead of stdout. For the filename
              the following placeholders are supported: %j for  PBS_JOBID,  %r
              for MPI RANK (only Intel MPI at the moment), %h host name and %p
              for process pid.  The placeholders must be separated  by  under‐
              score  as, e.g., -o test_%h_%p. You must specify a suffix to the
              filename. For txt the output is printed as is to the file. Other
              suffixes  trigger a filter on the output.  Available filters are
              csv (comma separated values) and xml at the moment.

       -O     print  output  in  CSV  format  (conform  to   RFC   4180,   see
              https://tools.ietf.org/html/rfc4180 for details).

       -i, --info
              print  cpuid information about processor and about Intel Perfor‐
              mance Monitoring features, then exit.

       -c <cpu expression>
              specify a numerical list of processors.  The  list  may  contain
              multiple  items,  separated  by  comma,  and ranges. For example
              0,3,9-11.

       -C <cpu expression>
              specify a numerical list of processors.  The  list  may  contain
              multiple  items,  separated  by  comma,  and ranges. For example
              0,3,9-11. This variant will also pin the threads to  the  cores.
              Also logical numberings can be used.

       -g, --group <performance group> or <performance event set string>
              specify  which  performance group to measure. This can be one of
              the tags output with the -a flag.  Also a custom event  set  can
              be specified by a comma separated list of events. Each event has
              the format eventId:register with the the register being one of a
              architecture supported performance counter registers.

       -t <frequency of measurements>
              timeline mode for time resolved measurements. The time unit must
              be given on command line, e.g. 4s, 500ms or 900us.

       -S <waittime between measurements>
              End-to-end measurement using likwid-perfctr but sleep instead of
              executing an application. The time unit must be given on command
              line, e.g. 4s, 500ms or 900us.

       -T <time between group switches>
              Frequency to switch groups if multiple are given on commandline,
              default  is  2s.  Value  is  ignored  for a single event set and
              default frequency of 30s is used to catch  overflows.  The  time
              unit must be given on command line, e.g. 4s, 500ms or 900us.

       -s, --skip <mask>
              Specify  skip  mask  as  HEX number. For each set bit the corre‐
              sponding thread is skipped.

       -f, --force
              Force writing of registers even if they are in use.

       -E <search_str>
              Print  only   events   and   corresponding   counters   matching
              <search_str>

EXAMPLE
       Because  likwid-perfctr  measures on processors and not single applica‐
       tions it is necessary to ensure that processes and threads  are  pinned
       to  dedicated resources. You can either pin the application yourself or
       use the builtin pin functionality.

       1.  As wrapper with performance group:

       likwid-perfctr -C 0-2 -g TLB ./cacheBench -n 2 -l  1048576  -i  100  -t
       Stream

       The  parent  process  is pinned to processor 0, Thread 0 to processor 1
       and Thread 1 to processor 2.

       2.  As wrapper with custom event set on AMD:

       likwid-perfctr          -C          0-4           -g           INSTRUC‐
       TIONS_RETIRED_SSE:PMC0,CPU_CLOCKS_UNHALTED:PMC3 ./cacheBench

       It  is specified that the event INSTRUCTIONS_RETIRED_SSE is measured on
       counter PMC0 and the event CPU_CLOCKS_UNHALTED on counter PMC3.  It  is
       possible   calculate   the  run  time  of  all  threads  based  on  the
       CPU_CLOCKS_UNHALTED event. If you want this you have  to  include  this
       event in your custom event string as shown above.

       3.  As wrapper with custom event set on Intel:

       likwid-perfctr                  -C                 0                 -g
       INSTR_RETIRED_ANY:FIXC0,CPU_CLK_UNHALTED_CORE:FIXC1,UNC_L3_LINES_IN_ANY:UPMC0
       ./stream-icc

       On  Intel  processors  fixed events are measured on dedicated counters.
       These are INSTR_RETIRED_ANY and CPU_CLK_UNHALTED_CORE.  If you  config‐
       ure  these  fixed  counters, likwid-perfctr will calculate the run time
       and CPI metrics for your run.

       4.  Using the marker API to measure only parts of your code  (this  can
           be used both with groups or custom event sets):

       likwid-perfctr        -m        -C        0-4        -g        INSTRUC‐
       TIONS_RETIRED_SSE:PMC0,CPU_CLOCKS_UNHALTED:PMC3 ./cacheBench

       You have to link you code against liblikwid.so and use the  marker  API
       calls.   Examples  can  be  found  in  examples  folder /usr/share/lik‐
       wid/examples.  The following code snippet shows the necessary calls:

       #include <likwid.h>

       /* only one thread calls init */
       LIKWID_MARKER_INIT;

       /* Must be called by each thread the should
        * perform measurements.
        * If you place it in the same parallel
        * region as LIKWID_MARKER_START, perform a
        * barrier between the statements to avoid
        * timing problems.
        */
       LIKWID_MARKER_THREADINIT;

       /* If you run the code region only once, register
        * the region tag previously to reduce the overhead
        * of START and STOP calls. Call it once for each
        * thread in parallel environment.
        * Note: No whitespace characters are allowed in the region tags
        * This call is optional, START will do the same operations.
        */
       LIKWID_MARKER_REGISTER("name");

       /* Start measurement
        * Note: No whitespace characters are allowed in the region tags
        */
       LIKWID_MARKER_START("name");
       /*
        * Your code to be measured is here
        * You can also nest named regions
        * No whitespaces are allowed in the region names!
        */
       LIKWID_MARKER_STOP("name");

       /* If you want to measure multiple groups/event sets
        * Switches through groups in round-robin fashion
        */
       LIKWID_MARKER_SWITCH;

       /* Finally */
       LIKWID_MARKER_CLOSE;

       5.  Using likwid in timeline mode:

       likwid-perfctr -c 0-3 -g FLOPS_DP -t 300ms ./cacheBench > out.txt

       This will read out the counters every 300ms on physical cores  0-3  and
       write  the  results  to  out.txt.  The application is not pinned to the
       CPUs. The output syntax of the timeline mode is for custom event sets:

       <groupID>      <numberOfEvents>      <numberOfThreads>      <Timestamp>
       <Event1_Thread1>     <Event2_Thread1>    ...    <Event1_Thread2>    ...
       <EventN_ThreadM>

       For performance groups with metrics: <groupID> <numberOfMetrics>  <num‐
       berOfThreads> <Timestamp> <Metric1_Thread1> <Metric2_Thread1> ... <Met‐
       ric1_Thread2> ...<MetricN_ThreadM>

       For timeline mode there is a frontend application  likwid-perfscope(1),
       which  enables  live  plotting of selected events. Please be aware that
       with high frequencies (<100ms), the values differ from the real results
       but the behavior of them is valid.

       6.  Using likwid in stethoscope mode:

       likwid-perfctr -c 0-3 -g FLOPS_DP -S 2s

       This  will  start  the  counters and read them out after 2s on physical
       cores 0-3 and write the results to stdout.

       7.  Using likwid with counter options:

       likwid-perfctr -c S0:1@S1:1 -g  LLC_LOOKUPS_DATA_READ:CBOX0C0:STATE=0x9
       ./cacheBench

       This  will  program the counter CBOX0C0 (the counter 0 of the LLC cache
       box 0) to measure the event LLC_LOOKUPS_DATA_READ and filter the incre‐
       ments  by the state of a cacheline.  STATE=0x9 for this event means all
       <invalid> and <modified> cachelines.  Which  options  are  allowed  for
       which  box is listed in LIKWID's html documentation. The values for the
       options can be found in the vendors performance  monitoring  documenta‐
       tions.  Likwid  measures the first CPU of socket 0 and the first CPU of
       socket 1. See likwid-pin(1) for details regarding the cpu  expressions.
       For  more  code  examples have a look at the likwid WIKI pages and LIK‐
       WID's html documentation.

AUTHOR
       Written by Thomas Roehl <thomas.roehl@googlemail.com>.

BUGS
       Report Bugs on <https://github.com/RRZE-HPC/likwid/issues>.

SEE ALSO
       likwid-topology(1), likwid-perfscope(1), likwid-pin(1), likwid-bench(1)

likwid-4                          19.05.2016                 LIKWID-PERFCTR(1)
#+end_example

Especially this part where it talks about timeline mode:

#+BEGIN_EXAMPLE
   5.  Using likwid in timeline mode:

       likwid-perfctr -c 0-3 -g FLOPS_DP -t 300ms ./cacheBench > out.txt

       This will read out the counters every 300ms on physical cores  0-3  and
       write  the  results  to  out.txt.  The application is not pinned to the
       CPUs. The output syntax of the timeline mode is for custom event sets:

       <groupID>      <numberOfEvents>      <numberOfThreads>      <Timestamp>
       <Event1_Thread1>     <Event2_Thread1>    ...    <Event1_Thread2>    ...
       <EventN_ThreadM>

       For performance groups with metrics: <groupID> <numberOfMetrics>  <num‐
       berOfThreads> <Timestamp> <Metric1_Thread1> <Metric2_Thread1> ... <Met‐
       ric1_Thread2> ...<MetricN_ThreadM>

       For timeline mode there is a frontend application  likwid-perfscope(1),
       which  enables  live  plotting of selected events. Please be aware that
       with high frequencies (<100ms), the values differ from the real results
       but the behavior of them is valid.
#+END_EXAMPLE

Note that there are two types of output. When you use custom event
sets), the second field is numberOfEvents. When you use performance
groups with metrics (which is your case), the second field is
numberOfMetrics. That gives us a nice headstart. Notes:

- The line with CORE should be ignored
- In the last lines we have the description of each field. The problem
  is that these lines do not match the number of fields in all
  remaining measurements lines. It looks like that these three fields:
  #+BEGIN_EXAMPLE
  <groupID> <numberOfMetrics>  <numberOfThreads> 
  #+END_EXAMPLE
  are part of each measurement line but they are not part of the
  description line with the headers. So I should append to the
  description line these three field descriptions in order to have a
  correct CSV header.

Considering these notes, let's do it:

#+begin_src sh :results output
FILE=benchmarks/NAS-OMP/log_NASExp1/saidaUa_1.log
pwd
ls -hl $FILE
#preparing the header
cat $FILE | grep timeStamp | head -n1
#+end_src

#+RESULTS:
: /home/schnorr/svn/gabriel/dissertacao_gbmoro
: -rw-r--r-- 1 schnorr schnorr 1.4M Aug 14 00:51 benchmarks/NAS-OMP/log_NASExp1/saidaUa_1.log

That's weird. That particular file I took randomly do not have the
header. Where the header comes from? Let's check which files have
them:

#+begin_src sh :results output
DIR=benchmarks/NAS-OMP/log_NASExp1/
for i in $DIR/*_1*; do
  echo $i
  cat $i | grep timeStamp  | wc -l
done
#+end_src

#+RESULTS:
#+begin_example
benchmarks/NAS-OMP/log_NASExp1//saidaBt_1.log
3
benchmarks/NAS-OMP/log_NASExp1//saidaCg_1.log
0
benchmarks/NAS-OMP/log_NASExp1//saidaFt_1.log
0
benchmarks/NAS-OMP/log_NASExp1//saidaLu_1.log
0
benchmarks/NAS-OMP/log_NASExp1//saidaSp_1.log
0
benchmarks/NAS-OMP/log_NASExp1//saidaUa_1.log
0
#+end_example

Only the first BT output has those lines. That's pretty weird.

TODO: I should ask Gabriel about this.

Now I am not sure if these files represent the original likwid-perfctr output.

I just found out that it was Gabriel himself that put those lines in
the files. See [[*Análise dos dados][Análise dos dados]]. I should not rely on them since they
are not standard.

I've just found this with a description of the L2CACHE group:
- https://github.com/RRZE-HPC/likwid/blob/master/groups/broadwellD/L2CACHE.txt

Ok, I will not consider that and try to rather do a headerless CSV file

#+begin_src sh :results output
test="lucas will do everything"
while [ -n "$test" ]; do
   echo $test
   test=`echo $test | cut -d" " -f2-`
done
#+end_src

#+begin_src sh :results output
#!/bin/bash
  function usage()
  {
      echo "$0 <likwid timeline log>";
      echo "where <likwid timeline log> is a file obtained with likwid-perfctr -t (timeline mode)";
  }

  FILE=$1
  if [ -z $FILE ]; then
    echo "Error: file has not been provided.";
    usage;
    exit 1;
  fi

  echo "Time Core Metric Value"
  TEMP=`mktemp`
  cat $FILE | grep -v -e CORE -e ^$  > $TEMP
  while read -r line; do
    GROUPID=`echo $line | awk '{ print $1 }'`
    METRICS=`echo $line | awk '{ print $2 }'`
    CORES=`echo $line | awk '{ print $3 }'`
    TIMESTAMP=`echo $line | awk '{ print $4 }'`
    REST=`echo $line | cut -d" " -f5-`    

    METRIC=0
    while [ $METRIC -lt $METRICS ]; do
      CORE=0
      while [  $CORE -lt $CORES ]; do
         VAL=`echo $REST | cut -d" " -f1` #awk '{ print $1 }'`
         echo $TIMESTAMP $CORE M$METRIC $VAL
         REST=`echo $REST | cut -d" " -f2-`
         CORE=`echo "$CORE+1" | bc`
      done
      METRIC=`echo  "$METRIC+1" | bc`   
    done
  done < $TEMP
  rm $TEMP
  exit 0
#+end_src

#+RESULTS:

Tangle this file C-c C-v t

Use such as this:

#+begin_src sh :results output
chmod 755 ./scripts/likwid2csv.sh
/usr/bin/time ./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaLu_1.log  > /tmp/x
#+end_src

#+RESULTS:

The script is rather slow. I'll update it to make it faster.

#+begin_src sh :results output :tangle scripts/likwid2csv.sh
#!/bin/bash
  function usage()
  {
      echo "$0 <likwid timeline log>";
      echo "where <likwid timeline log> is a file obtained with likwid-perfctr -t (timeline mode)";
  }

  FILE=$1
  if [ -z $FILE ]; then
    echo "Error: file has not been provided.";
    usage;
    exit 1;
  fi

  echo "Time Core Metric Value"
  TEMP=`mktemp`
  cat $FILE | grep -v -e CORE -e ^$  > $TEMP
  while read -r line; do
    GROUPID=`echo $line | awk '{ print $1 }'`
    METRICS=`echo $line | awk '{ print $2 }'`
    CORES=`echo $line | awk '{ print $3 }'`
    TIMESTAMP=`echo $line | awk '{ print $4 }'`
    VALS=`mktemp`
    echo $line | cut -d" " -f5- | sed "s/ /\n/g" > $VALS
    REMS=`mktemp`
    for METRIC in `seq 1 $METRICS`; do
      for CORE in `seq 1 $CORES`; do
         echo $TIMESTAMP $CORE M$METRIC
      done
    done > $REMS
    paste -d " " $REMS $VALS
    rm $VALS
    rm $REMS
  done < $TEMP
  rm $TEMP
  exit 0
#+end_src

Let's try out (don't forget to tangle this file C-c C-v t):

#+begin_src sh :results output
chmod 755 ./scripts/likwid2csv.sh
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaLu_1.log  > /tmp/x.csv
#+end_src

#+RESULTS:

Here's how to read that with R:

#+begin_src R :results output :session :exports both
df <- read.csv("/tmp/x.csv", sep=" ", strip.white=T);
head(df);
#+end_src

#+RESULTS:
:        Time Core Metric     Value
: 1 0.1006167    1     M1 0.1007972
: 2 0.1006167    2     M1 0.1007972
: 3 0.1006167    3     M1 0.1007972
: 4 0.1006167    4     M1 0.1007972
: 5 0.1006167    5     M1 0.1007972
: 6 0.1006167    6     M1 0.1007972

I'll let you analyze values along time.

Note that metrics names should be replaced by something else.
* [13:46:18; 18.08.2016] Experimento com o benchmark NAS - L3 CACHE                       :Gabriel:
** Definições iniciais

- Primeiramente vou fazer um teste para ver mais ou menos o tempo de
  execução para cada algoritmo, usando =32 threads= (default openmp da
  máquina). 

|-----------+--------------+----------------+--------------|
| Aplicação | Execução (s) | TimeStamp (ms) | Amostras     |
|-----------+--------------+----------------+--------------|
| bt.B      |        37.56 | 100ms          | ~= 37        |
| cg.B      |        18.13 | 50ms           | ~= 36        |
| ep.B      |         3.52 | - Descartado   | - Descartado |
| ft.B      |         8.35 | 30ms           | ~= 27        |
| lu.B      |        34.08 | 100ms          | ~= 34        |
| mg.B      |          3.6 | - Descartado   | - Descartado |
| sp.B      |        83.85 | 225ms          | ~= 37        |
| ua.B      |        40.90 | 110ms          | ~= 37        |
|-----------+--------------+----------------+--------------|

- Na coluna =TimeStamp= e =Amostras= estou propondo uma configuração
  adequada para deixar próximo a quantidade de amostras de acordo com
  o tempo de execução de cada aplicação. O motivo de descartar algumas
  aplicações para o experimento é devido ao seu tempo de execução ser
  inferior a 4 segundos, isso porque na medida que eu defnir um
  =TimeStamp= muito pequeno para coletar as amostras, isso pode afetar
  os valores coletados. A maneira que encontro hoje de evitar isso é
  descartando essas aplicações, mas pretendo investigar como resolver
  tal problemática.

** Script do experimento

#+begin_src sh :results output :exports both :tangle scripts/scriptOfExecutionNAS_expL3.bash
#!bin/bash
rm -rf log_NASExp2
mkdir log_NASExp2

benchpath=/home/aulapinroot/Programs/NPB3.3.1/NPB3.3-OMP/bin

bt_command=$benchpath/bt.B.x
cg_command=$benchpath/cg.B.x
ft_command=$benchpath/ft.B.x
lu_command=$benchpath/lu.B.x
sp_command=$benchpath/sp.B.x
ua_command=$benchpath/ua.B.x

sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L3CACHE $bt_command >> log_NASExp2/saidaBt_2.log 2>> log_NASExp2/saidaBt_1.log 
sudo likwid-perfctr -t 50ms -f -c N:0-31 -g L3CACHE $cg_command >> log_NASExp2/saidaCg_2.log 2>> log_NASExp2/saidaCg_1.log 
sudo likwid-perfctr -t 30ms -f -c N:0-31 -g L3CACHE $ft_command >> log_NASExp2/saidaFt_2.log 2>> log_NASExp2/saidaFt_1.log 
sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L3CACHE $lu_command >> log_NASExp2/saidaLu_2.log 2>> log_NASExp2/saidaLu_1.log 
sudo likwid-perfctr -t 225ms -f -c N:0-31 -g L3CACHE $sp_command >> log_NASExp2/saidaSp_2.log 2>> log_NASExp2/saidaSp_1.log 
sudo likwid-perfctr -t 110ms -f -c N:0-31 -g L3CACHE $ua_command >> log_NASExp2/saidaUa_2.log 2>> log_NASExp2/saidaUa_1.log 

#+end_src

- Execução o FT com 100ms, conforme solicitado pelo professor Lucas.

#+begin_src sh :results output :exports both :tangle scripts/scriptOfExecutionNASDoFT_expl2e3.bash

#!bin/bash
rm -rf log_NASExp2FT
mkdir log_NASExp2FT

benchpath=/home/aulapinroot/Programs/NPB3.3.1/NPB3.3-OMP/bin

ft_command=$benchpath/ft.B.x

sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L3CACHE $ft_command >> log_NASExp2/saidaFt100l3_2.log 2>> log_NASExp2/saidaFt100l3_1.log 

sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L2CACHE $ft_command >> log_NASExp2/saidaFt100l2_2.log 2>> log_NASExp2/saidaFt100l2_1.log 

#+end_src

** Análise dos dados

- Acho que o primeiro passo é tratar os arquivos gerados pelo
  experimento que estão na extensão de =.log= para =.csv=, já formatando o
  arquivo e adicionando o cabeçalho apropriado para facilitar a
  análise utilizando R.

- Os arquivos gerados no experimento estão no diretório
  [[:benchmarks/NAS-OMP/log_NASExp2:]]. Os arquivos que possuem o =_1= são
  os rastros gerados pela ferramenta likwid, já o =_2= são as saídas que
  não fazem parte do rastro.

#+begin_src sh :results output :exports both :tangle scripts/exp2NAS_test.bash
cd benchmarks/NAS-OMP/log_NASExp1/

numberOfCores=32
count=0

tmp="timeStamp"
while [ $count -lt $numberOfCores ]
do
	tmp=$tmp",C'$count'runtime_rdstc,C'$count'runtime_unshall,C'$count'clock,C'$count'cpi,C'$count'l2reqrate,C'$count'l2missrate,C'$count'l2missratio"
	count=$(echo "$count+1" | bc)
done

echo "$tmp" >> btexp2L3CACHEg.csv

cat saidaBt_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> btexp2L3CACHEg.csv

cat btexp2L3CACHEg.csv

mv btexp2L3CACHEg.csv ../dados/
#+end_src

#+RESULTS:
#+begin_example
timeStamp,C'0'runtime_rdstc,C'0'runtime_unshall,C'0'clock,C'0'cpi,C'0'l2reqrate,C'0'l2missrate,C'0'l2missratio,C'1'runtime_rdstc,C'1'runtime_unshall,C'1'clock,C'1'cpi,C'1'l2reqrate,C'1'l2missrate,C'1'l2missratio,C'2'runtime_rdstc,C'2'runtime_unshall,C'2'clock,C'2'cpi,C'2'l2reqrate,C'2'l2missrate,C'2'l2missratio,C'3'runtime_rdstc,C'3'runtime_unshall,C'3'clock,C'3'cpi,C'3'l2reqrate,C'3'l2missrate,C'3'l2missratio,C'4'runtime_rdstc,C'4'runtime_unshall,C'4'clock,C'4'cpi,C'4'l2reqrate,C'4'l2missrate,C'4'l2missratio,C'5'runtime_rdstc,C'5'runtime_unshall,C'5'clock,C'5'cpi,C'5'l2reqrate,C'5'l2missrate,C'5'l2missratio,C'6'runtime_rdstc,C'6'runtime_unshall,C'6'clock,C'6'cpi,C'6'l2reqrate,C'6'l2missrate,C'6'l2missratio,C'7'runtime_rdstc,C'7'runtime_unshall,C'7'clock,C'7'cpi,C'7'l2reqrate,C'7'l2missrate,C'7'l2missratio,C'8'runtime_rdstc,C'8'runtime_unshall,C'8'clock,C'8'cpi,C'8'l2reqrate,C'8'l2missrate,C'8'l2missratio,C'9'runtime_rdstc,C'9'runtime_unshall,C'9'clock,C'9'cpi,C'9'l2reqrate,C'9'l2missrate,C'9'l2missratio,C'10'runtime_rdstc,C'10'runtime_unshall,C'10'clock,C'10'cpi,C'10'l2reqrate,C'10'l2missrate,C'10'l2missratio,C'11'runtime_rdstc,C'11'runtime_unshall,C'11'clock,C'11'cpi,C'11'l2reqrate,C'11'l2missrate,C'11'l2missratio,C'12'runtime_rdstc,C'12'runtime_unshall,C'12'clock,C'12'cpi,C'12'l2reqrate,C'12'l2missrate,C'12'l2missratio,C'13'runtime_rdstc,C'13'runtime_unshall,C'13'clock,C'13'cpi,C'13'l2reqrate,C'13'l2missrate,C'13'l2missratio,C'14'runtime_rdstc,C'14'runtime_unshall,C'14'clock,C'14'cpi,C'14'l2reqrate,C'14'l2missrate,C'14'l2missratio,C'15'runtime_rdstc,C'15'runtime_unshall,C'15'clock,C'15'cpi,C'15'l2reqrate,C'15'l2missrate,C'15'l2missratio,C'16'runtime_rdstc,C'16'runtime_unshall,C'16'clock,C'16'cpi,C'16'l2reqrate,C'16'l2missrate,C'16'l2missratio,C'17'runtime_rdstc,C'17'runtime_unshall,C'17'clock,C'17'cpi,C'17'l2reqrate,C'17'l2missrate,C'17'l2missratio,C'18'runtime_rdstc,C'18'runtime_unshall,C'18'clock,C'18'cpi,C'18'l2reqrate,C'18'l2missrate,C'18'l2missratio,C'19'runtime_rdstc,C'19'runtime_unshall,C'19'clock,C'19'cpi,C'19'l2reqrate,C'19'l2missrate,C'19'l2missratio,C'20'runtime_rdstc,C'20'runtime_unshall,C'20'clock,C'20'cpi,C'20'l2reqrate,C'20'l2missrate,C'20'l2missratio,C'21'runtime_rdstc,C'21'runtime_unshall,C'21'clock,C'21'cpi,C'21'l2reqrate,C'21'l2missrate,C'21'l2missratio,C'22'runtime_rdstc,C'22'runtime_unshall,C'22'clock,C'22'cpi,C'22'l2reqrate,C'22'l2missrate,C'22'l2missratio,C'23'runtime_rdstc,C'23'runtime_unshall,C'23'clock,C'23'cpi,C'23'l2reqrate,C'23'l2missrate,C'23'l2missratio,C'24'runtime_rdstc,C'24'runtime_unshall,C'24'clock,C'24'cpi,C'24'l2reqrate,C'24'l2missrate,C'24'l2missratio,C'25'runtime_rdstc,C'25'runtime_unshall,C'25'clock,C'25'cpi,C'25'l2reqrate,C'25'l2missrate,C'25'l2missratio,C'26'runtime_rdstc,C'26'runtime_unshall,C'26'clock,C'26'cpi,C'26'l2reqrate,C'26'l2missrate,C'26'l2missratio,C'27'runtime_rdstc,C'27'runtime_unshall,C'27'clock,C'27'cpi,C'27'l2reqrate,C'27'l2missrate,C'27'l2missratio,C'28'runtime_rdstc,C'28'runtime_unshall,C'28'clock,C'28'cpi,C'28'l2reqrate,C'28'l2missrate,C'28'l2missratio,C'29'runtime_rdstc,C'29'runtime_unshall,C'29'clock,C'29'cpi,C'29'l2reqrate,C'29'l2missrate,C'29'l2missratio,C'30'runtime_rdstc,C'30'runtime_unshall,C'30'clock,C'30'cpi,C'30'l2reqrate,C'30'l2missrate,C'30'l2missratio,C'31'runtime_rdstc,C'31'runtime_unshall,C'31'clock,C'31'cpi,C'31'l2reqrate,C'31'l2missrate,C'31'l2missratio
0.10093558788872,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.078669250968433,0.061730678505742,0.06812005584327,0.0842342805691,0.029186527697428,0.043639749416139,0.064533694611705,0.049827747707227,0.077229596561942,0.056916491942482,0.064462121917493,0.06978676036586,0.039682751178853,0.053260176521097,0.060669666626694,0.061107531314836,0.081091103040111,0.084310360275542,0.089570930050059,0.088598344910957,0.075744063030957,0.071260555864994,0.070168528901787,0.06912742907677,0.090558811730669,0.079545640346509,0.08952201191732,0.091951127008706,0.076420834867373,0.02561146449652,0.040553241040921,0.027881183155385,2406.0595569703,2399.9940707962,2406.9960856887,2405.6520813749,2400.0714850418,2399.9947525202,2407.3830192521,2399.9888877798,2399.9935808462,2399.9930448638,2399.9912165187,2400.0395373504,2399.9941831342,2399.9956505865,2399.9948326069,2399.9941749309,2405.867401282,2400.011008724,2405.3117987948,2405.3711138561,2399.9927746907,2399.9916857807,2406.7859675129,2400
...

#+end_example

- O próximo passo é fazer filtrar os demais arquivos obtidos no
  experimento com o benchmark NAS.
  
#+begin_src sh :results output :exports both :tangle scripts/scriptOfFilterNAS_L3.bash

cd benchmarks/NAS-OMP/log_NASExp1/

numberOfCores=32

count=0

tmp="timeStamp"
while [ $count -lt $numberOfCores ]
do
	tmp=$tmp",C'$count'runtime_rdstc,C'$count'runtime_unshall,C'$count'clock,C'$count'cpi,C'$count'l2reqrate,C'$count'l2missrate,C'$count'l2missratio"
	count=$(echo "$count+1" | bc)
done

echo "$tmp" >> cgexp2L3CACHEg.csv
echo "$tmp" >> ftexp2L2CACHEg.csv
echo "$tmp" >> luexp2L3CACHEg.csv
echo "$tmp" >> spexp2L3CACHEg.csv
echo "$tmp" >> uaexp2L3CACHEg.csv

cat saidaCg_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> cgexp2L3CACHEg.csv
cat saidaFt_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> ftexp2L3CACHEg.csv
cat saidaLu_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> luexp2L3CACHEg.csv
cat saidaSp_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> spexp2L3CACHEg.csv
cat saidaUa_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> uaexp2L3CACHEg.csv


mv *.csv ../../../dados/
#+end_src

#+RESULTS:

- Todos os =.csv= do experimento foram gerados.

- Utilizando o script que o professor Lucas desenvolveu vou testar
  para as aplicações do benchmark NAS, começando pelo bt.


#+begin_src sh :results output
chmod 755 ./scripts/likwid2csv.sh
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2/saidaCg_1.log  > dados/exp2_NASandLikwid/cgB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2/saidaFt_1.log  > dados/exp2_NASandLikwid/ftB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2/saidaLu_1.log  > dados/exp2_NASandLikwid/luB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2/saidaSp_1.log  > dados/exp2_NASandLikwid/spB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2/saidaUa_1.log  > dados/exp2_NASandLikwid/uaB.csv

cd dados/exp2_NASandLikwid/
ls
#+end_src

#+RESULTS:
: cgB.csv
: extraction1
: ftB.csv
: luB.csv
: spB.csv
: uaB.csv
*** Plotando os gráficos para análise

A métrica utilizada para gerar os gráficos é a =M7=, essa métrica
apresenta a taxa de misses no segundo nível de cache L3 para cada
processador, esse valor é apresentado como porcentagem.

#+BEGIN_EXAMPLE
l3missrate = l3missrequests/totalOfInstructions
M7 = l2missrate

if M7 => min(M7_total) and M7 < mean(M7_total) then
		the region is memory-bound;
else
		the region is not memory-bound;
#+END_EXAMPLE


- No =eixo y= de cada gráfico é possível visualizar a porcentagem de
  cache misses na L3 de cada processador analisado, como a =beagle1=,
  plataforma na qual o experimento foi executado possui cerca de =32
  cores= é possível visualizar nos arquivos gerados 32 gráficos
  respectivos de cada core, apresentando o comportamento da
  aplicação. Já no =eixo x= é apresentado a frequência das amostras
  realizadas (=time stamp=).

- É possível visualizar também nos gráficos uma linha vermelha que é
  calculada pela média de cache misses total (cache
  L3). Possibilitando uma análise comparativa com as demais regiões da
  aplicação.

**** Aplicação CG

#+begin_src R :results output graphics :file "imagens/cgBNas_Analise_exp2.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp2_NASandLikwid/cgB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);
#+end_src

#+RESULTS:
[[file:imagens/cgBNas_Analise_exp2.pdf]]

- Em todos os cores podemos visualizar picos que ocorrem em
  determinados pontos, diferentes desses picos não é encontrado
  ocorrências considerável de misses na l3, entre os intervalos de 0 e
  0.25 na taxa de cache misses.

**** Aplicação FT

- A aplicação =FT= é a famosa transformada discreta de fourier, só que
  em uma versão de 3 dimensões.

#+begin_src R :results output graphics :file "imagens/ftBNas_Analise_exp2.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp2_NASandLikwid/ftB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/ftBNas_Analise_exp2.pdf]]

- Nesse gráfico podemos visualizar mais índices de miss para o nível
  da l3, os quais ocorrem principalmente no início da execução da
  aplicação, chegando para o caso máximo próximo a 100% de misses para
  l3.


***** Execução com 100ms 

#+begin_src sh :results output :exports both 
chmod 755 ./scripts/likwid2csv.sh
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2FT/saidaFt100l2_1.log  > dados/exp3_NASandLikwid/ftl2.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2FT/saidaFt100l3_1.log  > dados/exp3_NASandLikwid/ftl3.csv
#+end_src

**** Aplicação LU

- A aplicação =LU= define o método de Gauss-Seidel para resolver 'n'
  equações lineares com um 'x' que é desconhecido.

#+begin_src R :results output graphics :file "imagens/luBNas_Analise_exp2.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp2_NASandLikwid/luB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/luBNas_Analise_exp2.pdf]]

- Nesse gráfico é possível visualizar que para os cores 1 ao 8, o
  comportamento de misses na l3 é maior que os demais. Outro aspecto
  interessante é o baixo índice de miss, o maior valor encontrado foi
  próximo a 20%. 

**** Aplicação SP

- Essa aplicação resolve o problema chamado =Scalar Penta-diagonal=. 

#+begin_src R :results output graphics :file "imagens/spBNas_Analise_exp2.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp2_NASandLikwid/spB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/spBNas_Analise_exp2.pdf]]

- O interessante desse gráfico é que na maior parte da execução os
  índices de misses se manteram a baixo de 25%, mas em alguns pontos
  ocorreu picos estressantes, os quais ultrapassaram na maior parte
  das vezes os 75% de misses para a l3.

**** Aplicação UA

- Essa aplicação define uma série de cálculos sobre uma malha
  adaptativa desistruturada, o que gera acessos irregulares a memória.


#+begin_src R :results output graphics :file "imagens/uaBNas_Analise_exp2.pdf" :exports both :session *RFib* 

library(dplyr);
df <- read.csv("dados/exp2_NASandLikwid/uaB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/uaBNas_Analise_exp2.pdf]]

- Para essa aplicação o maior índice de miss que aplicação chegou foi
  a 30% de misses na l3. Na maioria das vezes o pico de execução
  ocorreu entre a coleta os primeiros 30 segundos. 

* [17:29:08; 18.08.2016] Experimento com o benchmark Graph500 - L2 CACHE e L3 CACHE :Gabriel:
** Instalação da ferramenta

#+begin_src sh :results output :exports both
cd benchmarks/
git clone https://github.com/graph500/graph500
cd graph500
cp make-incs/make.inc-gcc make.inc
sed -i "s/gcc-4.6/gcc/" make.inc
sed -i "s/BUILD_OPENMP = No/BUILD_OPENMP = Yes/" Makefile
make
#+end_src

#+RESULTS:
: gcc -flto -fwhole-program -g -std=c99 -Wall -O3 -march=native -I./generator   seq-list/seq-list.c graph500.c options.c rmat.c kronecker.c verify.c prng.c xalloc.c timer.c generator/splittable_mrg.c generator/graph_generator.c generator/make_graph.c generator/utils.c  -lm -lrt -o seq-list/seq-list
: gcc -flto -fwhole-program -g -std=c99 -Wall -O3 -march=native -I./generator   seq-csr/seq-csr.c graph500.c options.c rmat.c kronecker.c verify.c prng.c xalloc.c timer.c generator/splittable_mrg.c generator/graph_generator.c generator/make_graph.c generator/utils.c  -lm -lrt -o seq-csr/seq-csr
: gcc -flto -fwhole-program -g -std=c99 -Wall -O3 -march=native  -I./generator   make-edgelist.c options.c rmat.c kronecker.c prng.c xalloc.c timer.c generator/splittable_mrg.c generator/graph_generator.c generator/make_graph.c generator/utils.c  -lm -lrt -o make-edgelist
: gcc -flto -fwhole-program -g -std=c99 -Wall -O3 -march=native  -I./generator   omp-csr/omp-csr.c omp-csr/bitmap.h graph500.c options.c rmat.c kronecker.c verify.c prng.c xalloc.c timer.c generator/splittable_mrg.c generator/graph_generator.c generator/make_graph.c generator/utils.c  -lm -lrt -o omp-csr/omp-csr

** Script de experimento

- Executando a aplicação com o parâmetro =-s 25=, a aplicação leva cerca
  de 4 minutos e 48 segundos, o que pode ser compreendido como 5
  minutos aproximadamente. 

#+begin_src sh :results output :exports both :tangle scripts/scriptOfExecutionGraph500_exp.bash
#!bin/bash
rm -rf log_Graph500exp
mkdir log_Graph500exp

benchpath=/home/aulapinroot/Programs/graph500/omp-csr

graph500_command=$benchpath/omp-csr

sudo likwid-perfctr -t 30ms -f -c N:0-31 -g L2CACHE $graph500_command >> log_Graph500exp/saidaGraph500L2_2.log 2>> log_Graph500exp/saidaGraph500L2_1.log 
sudo likwid-perfctr -t 30ms -f -c N:0-31 -g L3CACHE $graph500_command >> log_Graph500exp/saidaGraph500L3_2.log 2>> log_Graph500exp/saidaGraph500L3_1.log 

#+end_src

** Análise dos dados

#+begin_src sh :results output :exports both :tangle scripts/expGraph500_test.bash

cd benchmarks/Graph500/log_Graph500exp/

numberOfCores=32
count=0

tmp="timeStamp"
while [ $count -lt $numberOfCores ]
do
	tmp=$tmp",C'$count'runtime_rdstc,C'$count'runtime_unshall,C'$count'clock,C'$count'cpi,C'$count'l2reqrate,C'$count'l2missrate,C'$count'l2missratio"
	count=$(echo "$count+1" | bc)
done

echo "$tmp" >> graph500L2CACHEg.csv
echo "$tmp" >> graph500L3CACHEg.csv

cat saidaGraph500L2_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >>  graph500L2CACHEg.csv

cat saidaGraph500L3_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >>  graph500L3CACHEg.csv

mv graph500L2CACHEg.csv ../../../dados/
mv graph500L3CACHEg.csv ../../../dados/

#+end_src


#+begin_src sh :results output :exports both :tangle scripts/scriptOfFilterGraph500.bash

cd benchmarks/Graph500/log_Graph500exp/

numberOfCores=32

count=0

tmp="timeStamp"
while [ $count -lt $numberOfCores ]
do
	tmp=$tmp",C'$count'runtime_rdstc,C'$count'runtime_unshall,C'$count'clock,C'$count'cpi,C'$count'l2reqrate,C'$count'l2missrate,C'$count'l2missratio"
	count=$(echo "$count+1" | bc)
done

echo "$tmp" >> graph500L2.csv
echo "$tmp" >> graph500L3.csv

cat saidaGraph500L2_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> graph500L2.csv
cat saidaGraph500L3_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> graph500L3.csv

mv *.csv ../../../dados/
#+end_src


A métrica utilizada para gerar os gráficos é a =M7=, essa métrica
apresenta a taxa de misses no segundo nível de cache L2 para cada
processador, esse valor é apresentado como porcentagem.

#+BEGIN_EXAMPLE
l2missrate = l2missrequests/totalOfInstructions
M7 = l2missrate

if M7 => min(M7_total) and M7 < mean(M7_total) then
		the region is memory-bound;
else
		the region is not memory-bound;
#+END_EXAMPLE


- No =eixo y= de cada gráfico é possível visualizar a porcentagem de
  cache misses na L2 e L3 de cada processador analisado, como a =beagle1=,
  plataforma na qual o experimento foi executado possui cerca de =32
  cores= é possível visualizar nos arquivos gerados 32 gráficos
  respectivos de cada core, apresentando o comportamento da
  aplicação. Já no =eixo x= é apresentado a frequência das amostras
  realizadas (=time stamp=).

- É possível visualizar também nos gráficos uma linha vermelha que é
  calculada pela média de cache misses total (cache
  L2 e L3). Possibilitando uma análise comparativa com as demais regiões da
  aplicação.

*** Novo experimento com 100ms

#+begin_src sh :results output :exports both
./scripts/likwid2csv.sh ./benchmarks/Graph500/log_Graph500exp2/saidaGraph500L2_1.log > dados/exp2_graph500/graph500_L2.csv
./scripts/likwid2csv.sh ./benchmarks/Graph500/log_Graph500exp2/saidaGraph500L3_1.log > dados/exp2_graph500/graph500_L3.csv
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
library(dplyr);
df2 <- read.csv("dados/exp2_graph500/graph500_L2.csv", sep=" ", strip.white=T);
df2 <- df2[df2$Metric == "M7", ];
df2$Metric <- "L2";
df3 <- read.csv("dados/exp2_graph500/graph500_L3.csv", sep=" ", strip.white=T);
df3 <- df3[df3$Metric == "M7", ];
df3$Metric <- "L3";
df <- rbind (df2, df3);
df$Application <- "Graph500";
g <- df %>% group_by(Time,Metric,Application) %>% summarize (N=n(), mean=mean(Value)*100) %>% as.data.frame();
head(g);
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union
       Time Metric Application  N      mean
1 0.1005658     L3    Graph500 32 19.134607
2 0.1005688     L2    Graph500 32 21.497577
3 0.2177010     L2    Graph500 32  7.828144
4 0.2202722     L3    Graph500 32  7.829694
5 0.3471098     L2    Graph500 32  8.558492
6 0.3497140     L3    Graph500 32  8.669937
#+end_example

#+begin_src R :results output graphics :file imagens/exp2_graph500.pdf :exports both :session
library(ggplot2);
ggplot(g, aes(x=Time, y=mean,color=as.factor(Metric))) +
  	geom_line(size=0.5) + geom_point(size=1) + theme_bw() + ylim(0,50) +  
     theme(legend.position=c(0.9,0.5),
               legend.background = element_rect(fill="gray90", size=.5, linetype="dotted")) + 
     scale_color_discrete(name="Cache Level") + facet_grid(Metric~Application) +
      labs(x = "Runtime (seconds)", y= "Average Cache Misses (%)");
#+end_src

#+RESULTS:
[[file:imagens/exp2_graph500.pdf]]

* 2016-08-20 Take a look at graph500 data

Convert the data

#+begin_src sh :results output
./scripts/likwid2csv.sh ./benchmarks/Graph500/log_Graph500exp/saidaGraph500L2_1.log > dados/exp1_graph500/graph500_L2.csv
./scripts/likwid2csv.sh ./benchmarks/Graph500/log_Graph500exp/saidaGraph500L3_1.log > dados/exp1_graph500/graph500_L3.csv
#+end_src

#+RESULTS:

Read the data, aggregate

#+begin_src R :results output :session :exports both
library(dplyr);
df2 <- read.csv("dados/exp1_graph500/graph500_L2.csv", sep=" ", strip.white=T);
df2 <- df2[df2$Metric == "M7", ];
df2$Metric <- "L2";
df3 <- read.csv("dados/exp1_graph500/graph500_L3.csv", sep=" ", strip.white=T);
df3 <- df3[df3$Metric == "M7", ];
df3$Metric <- "L3";
df <- rbind (df2, df3);
df$Application <- "Graph500";
g <- df %>% group_by(Time,Metric,Application) %>% summarize (N=n(), mean=mean(Value)*100) %>% as.data.frame();
head(g);
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union
        Time Metric Application  N       mean
1 0.05056907     L3    Graph500 32  4.7365908
2 0.05057705     L2    Graph500 32  8.8282538
3 0.11702327     L2    Graph500 32 11.3548215
4 0.11772690     L3    Graph500 32  0.2876260
5 0.18278533     L2    Graph500 32 13.6554586
6 0.18569630     L3    Graph500 32  0.1767422
#+end_example

#+begin_src R :results output graphics :file imagens/exp1_graph500.pdf :exports both :session
library(ggplot2);
ggplot(g, aes(x=Time, y=mean,color=as.factor(Metric))) +
  	geom_line(size=0.5) + geom_point(size=1) + theme_bw() + ylim(0,50) +  
     theme(legend.position=c(0.9,0.5),
               legend.background = element_rect(fill="gray90", size=.5, linetype="dotted")) + 
     scale_color_discrete(name="Cache Level") + facet_grid(Metric~Application) +
      labs(x = "Runtime (seconds)", y= "Average Cache Misses (%)");
#+end_src

#+RESULTS:
[[file:imagens/exp1_graph500.pdf]]


Let's zoom in

#+begin_src R :results output graphics :file imagens/exp1_graph500zoom.pdf :exports both :session
library(ggplot2);
x = 120
ggplot(g[g$Time < x & g$Time > x-25,], aes(x=Time, y=mean,color=as.factor(Metric))) +
  	geom_line(size=0.5) + geom_point(size=1) + theme_bw() + ylim(0,50) +  
     theme(legend.position=c(0.9,0.5),
               legend.background = element_rect(fill="gray90", size=.5, linetype="dotted")) + 
     scale_color_discrete(name="Cache Level") + facet_grid(Metric~Application) +
      labs(x = "Runtime (seconds)", y= "Average Cache Misses (%)");
#+end_src

#+RESULTS:
[[file:imagens/exp1_graph500zoom.pdf]]

Looks like there is a correlation between L2 and L3 miss rates at
regular intervals. They are not completely synchronized probably
because metrics are taken in two executions. We can also consider that
executions are synchronized (same machine, similar execution time). If
so, an increase in L3 miss rate generates L2 misses just after.  

Note: Change *x* in the previous code block to see other timeslices.

* [13:53:07; 31.08.2016] Avaliando o Overhead da técnica com e sem likwid :Gabriel:

- Vou fazer um experimento para analisar o =overhead= da utilização do
  likwid.

#+begin_src R :results output :session *Rs* :exports both :tangle dados/exp4NAS_semlikwid/exp4NASDesign.csv
require(DoE.base);
exp4NASDesign <- fac.design (
	nfactors=2,
	replications=20,
	repeat.only=FALSE,
	blocks=1,
	randomize=TRUE,
	seed=10373,
	nlevels=c(7,2),
	factor.names=list(
		versions=c("bt.B","cg.B","ft.B","is.B","lu.B","mg.B","sp.B"),
		threads=c(1,32)));

export.design(exp4NASDesign, 
	path=".",
	filename=NULL,
	type="csv",
	replace=TRUE,
	response.names=c("time"));

#+end_src

#+RESULTS:
:  creating full factorial with 14 runs ...

- Script de execução:

#+begin_src sh :results output :exports both :tangle scripts/exp4Script.bash
#!bin/bash
cd scripts

nameFile="../dados/exp4NAS_semlikwid/exp4NASDesign.csv"

ref=$(cat $nameFile)

i=0

for row in ${ref[@]}; do
	if [ $i -gt 0 ]; then
		name=$(echo "$row" | cut -d ',' -f1)
		runId=$(echo "$row" | cut -d ',' -f2)
		runNumber=$(echo "$row" | cut -d ',' -f3)
		runStd=$(echo "$row" | cut -d ',' -f4)
		version=$(echo "$row" | cut -d ',' -f5 | sed 's/"//g')
		threads=$(echo "$row" | cut -d ',' -f6 | sed 's/"//g')
		time=0
		
		export OMP_NUM_THREADS=$threads

		time=$(./$version | grep -i time | sed 's/Time[[:space:]]in[[:space:]]seconds//g' | sed 's/=//g' | sed 's/[[:space:]]//g')
		echo "$name,$runId,$runNumber,$runStd,$version,$threads,$time" >> "Results.csv"
	else
		echo $row | sed 's/,,/,/g' >> "Results.csv"
		let i=$i+1
	fi
done

#+end_src

- Vamos fazer um novo experimento para o benchmark do NAS, a fim de
  verificar se existe diferença entre uma execução que usa como
  parâmetro =-g L2CACHE e L3CACHE= e duas execuções para cada grupo. A
  hipótese é que alguns valores possam ser obtidos por registradores e
  não contadores de hardware.

#+begin_src sh :results output :exports both :tangle scripts/scriptOfExecutionNAS_expL2AndL3.bash
#!bin/bash
rm -rf log_NASExp3
mkdir log_NASExp3

benchpath=/home/aulapinroot/Programs/NPB3.3.1/NPB3.3-OMP/bin

bt_command=$benchpath/bt.B.x
cg_command=$benchpath/cg.B.x
ft_command=$benchpath/ft.B.x
lu_command=$benchpath/lu.B.x
sp_command=$benchpath/sp.B.x
ua_command=$benchpath/ua.B.x

sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L2CACHE -g L3CACHE  $bt_command >> log_NASExp3/saidaBt_2.log 2>> log_NASExp3/saidaBt_1.log 
sudo likwid-perfctr -t 50ms -f -c N:0-31 -g L2CACHE -g L3CACHE $cg_command >> log_NASExp3/saidaCg_2.log 2>> log_NASExp3/saidaCg_1.log 
sudo likwid-perfctr -t 30ms -f -c N:0-31 -g L2CACHE -g L3CACHE $ft_command >> log_NASExp3/saidaFt_2.log 2>> log_NASExp3/saidaFt_1.log 
sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L2CACHE -g L3CACHE $lu_command >> log_NASExp3/saidaLu_2.log 2>> log_NASExp3/saidaLu_1.log 
sudo likwid-perfctr -t 225ms -f -c N:0-31 -g L2CACHE -g L3CACHE $sp_command >> log_NASExp3/saidaSp_2.log 2>> log_NASExp3/saidaSp_1.log 
sudo likwid-perfctr -t 110ms -f -c N:0-31 -g L2CACHE -g L3CACHE $ua_command >> log_NASExp3/saidaUa_2.log 2>> log_NASExp3/saidaUa_1.log 

#+end_src
