#+TITLE: LabBook
#+AUTHOR: Gabriel Bronzatti Moro and Lucas M. Schnorr
#+LATEX_HEADER: \usepackage[margin=2cm,a4paper]{geometry}
#+STARTUP: overview indent
#+TAGS: Gabriel(G) Lucas(L) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)
#+mode: org
#+coding: utf-8

Esse documento está em pt-br

* [00:18:39; 02.07.2016] Tarefas da Primeira Reunião com o Professor Lucas :Gabriel:
** Principais trabalhos relacionados - Artigo do Luis Felipe

|---------------------+---------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------|
| *Autores*             | *Título*                                                                                            | *Objetivo*                                                                                                                                                     | *Metodologia*                                                                                                                                                                                                                 | *Benchmark, Ferramenta ou Tecnologia*                                | *Resultados*                                                                                                                                                                                                              | *Observação*                                                                                                                                                                       | *Diferença do nosso trabalho*                                      |
|                     |                                                                                                   |                                                                                                                                                              |                                                                                                                                                                                                                             |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|                     |                                                                                                   |                                                                                                                                                              |                                                                                                                                                                                                                             |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|---------------------+---------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------|
| Laurenzano et al.   | =Reducing energy usage with memory and with memory and computation-aware dynamic frequency scaling= | - Abordagem que permite selecionar *por laço* a melhor frequência de clock. O critério de frequência mais adequado está entre desempenho e consumo de energia. | - Instrumentação realizada através da utilização da ferramenta PEBIL toolkit                                                                                                                                                | - Benchmark própio =pcubed= (PMaC's Performance and Power benchmark) | - Os principais resultados adquiridos pelos autores foi a economia de cerca de 7,6% de energia para a primeira plataforma de execução (Intel Xeon E5530) e para a segunda plataforma (AMD Opteron 8380) cerca de 10,6%. | - O autor não chega a definir, mas menciona que uma aplicação =memory-bound= depende primeiramente da proximidade, tamanho e do Speedup disponível com as operaçoes sob a memoria. | - Foco em aplicações paralelas\ (OpenMP)                         |
|                     |                                                                                                   |                                                                                                                                                              | - Uso da biblioteca cpu-freq para alterar a frequência do processador                                                                                                                                                       |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  | - Regiões paralelas dentro da abordagem fork-join                |
|                     |                                                                                                   |                                                                                                                                                              | - Experimento: os parâmentos levados em consideração para aplicação são: taxa de hit dos diferentes níveis de cache, operações de ponto-flutuante (FP) sob a memória e a media de computação de operações sob FP e inteiro. |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|                     |                                                                                                   |                                                                                                                                                              | - A plataforma de execução escolhida por eles *permite a alteração da frequência independentemente de cada core* (frequências avaliadas no experimento 1.6, 1.73, 1.86, 2, 2.13, 2.26, 2.39 e 2.40 GHz).                      |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|---------------------+---------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------|
| Freeh et al.        | =Using Multiple Energy Gears in MPI Programs on a Power-Scalable Cluster=                           | - Abordagem que tem por objetivo encontrar a *frequência adequada para cada fase da aplicação MPI*, de acordo com a heurística alvo (energia e/ou desempenho). | - A aplicação é dividida em n fases e diferentes gears (microprocessadores), para cada gear é executado as n fases da aplicação                                                                                             | - Benchmark do =NAS=                                                 | - Os resultados apresentam a partir da combinação adequada de frequências para os benchmarks executados é possível obter um bom ganho de energia caso fosse utilizado apenas a mesma frequência nos diferentes nós.     | - Os autores introduzem a métrica =OPM (Operations per Miss)=, a qual permite verificar a pressão de memória de uma aplicação ou de uma fase.                                      | - Foco em aplicações paralelas de memória compartilhada (OpenMP) |
|                     |                                                                                                   |                                                                                                                                                              | - Resultados obtidos de tempo e energia                                                                                                                                                                                     |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  | - Trabalho concentra-se em apenas um nó                          |
|                     |                                                                                                   |                                                                                                                                                              | - O cluster aonde foi executado os experimentos permitia a configuração de até 10 diferentes frequências.                                                                                                                   |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|                     |                                                                                                   |                                                                                                                                                              |                                                                                                                                                                                                                             |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|                     |                                                                                                   |                                                                                                                                                              |                                                                                                                                                                                                                             |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|                     |                                                                                                   |                                                                                                                                                              |                                                                                                                                                                                                                             |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|                     |                                                                                                   |                                                                                                                                                              |                                                                                                                                                                                                                             |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|---------------------+---------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------|
| Spiliopoulos et al. | =Power-Sleuth: A Tool for Investigating your Program's Power Behavior=                              | - Melhorar o desempenho e o consumo de energia alterando as frequências por fase da aplicação.                                                               | - Aplicação dividida em fases, durante a execução são coletadas informações sobre essas fases para estimar o consumo de energia de cada fase.                                                                               | - ScarPhase para caracterizar cada fase da aplicação               | - Os resultados do artigo permitem analisar apenas a acurácia da ferraemnta com as medidas de potência reais                                                                                                            |                                                                                                                                                                                  | - Foco em aplicações paralelas                                   |
|                     |                                                                                                   |                                                                                                                                                              | - Após a análise do comportamento da execução a ferramenta desenvolvida pelos autores é capaz de alternar a frequência de cada fase para melhorar o consumo de energia e o desempenho                                       |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  | - Nossa divisão do programa é em regiões e não fases             |
|                     |                                                                                                   |                                                                                                                                                              | - A abordagem utiliza um modelo de desempenho DVFS, um modelo de correlação de capacitânciae uma técnica para detectar as fases da aplicação.                                                                               |                                                                    |                                                                                                                                                                                                                         |                                                                                                                                                                                  |                                                                  |
|---------------------+---------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------|

- Alguns trabalhos possíveis: 

*** Caracterização de aplicações paralelas implementadas em OpenMP
	=Motivativação=: Análise do comportamento da aplicação paralela
	via contadores de hardware. A partir disso será possível
	visualizar o perfil de execução da aplicação pelos contadores
	de hardware. A técnica pode ser usada como uma pré-execução.

	=Metodologia=: Uso da abordagem =DoE= (Desing of Experiments) para
	projetar o experimento e analisar os resultados. Freeh et
	al. possui um trabalho similar, mas o diferencial do nosso
	trabalho é a metodologia e o uso da técnica DoE.
        
*** Modelagem de energia para aplicações híbridas OpenMP/MPI
	=Motivativação=: Contabilizar a energia gasta em cada regiÃ£o
	paralela, mas também a energia gasta dentro do nó (intra-node)
	e a comunicação dentro do nó (se existir) e a comunicação fora
	do nó. Esse trabalho se concentraria na estimativa da energia
	total gasta pela aplicação híbrida implementada em
	OpenMP/MPI.

	=Metodologia=: A metodologia pode ser a seguinte (uma abordagem
	button-up):
        a) Estimar a energia de cada região paralela (usando
           contadores de hardware em diferentes nós);
        b) Estimar a energia da aplicação (fora do limite fork-join);
        c) Estimar a energia da aplicação na comunicação intra-nó;
        d) Estimar a energia da comunicação inter-node (fora do nó).

  =Results=: O resultado seria a estimativa de energia da aplicação
  híbrida como um todo e também a energia gasta em cada nó. Isso pode
  oferecer uma estimativa correta de energia para essas aplicações, a
  partir da informação obtida o desenvolvedor poderá otimizar alguma
  parte da sua aplicação.
* [19:10:05; 05.07.2016] Reunião Semanal com o Professor Lucas :Gabriel:Lucas:
** Definição do assunto da dissertação
	=Objetivo=: Detectar as fases da aplicação utilizando contadores
	de hardware.

    =Ferramentas a serem investigadas=: ScoreP (com PAPI), ExtraE e
    TAU. Também procurar como realizar uma medição utilizando
    contadores de hardware along time.

    =Tarefas=: 
    	a) fazer os trabalhos relacionados direcionando-os na
    temática ``Parallel Application Phase Detection'';
    	b) implementar a detecção de fase usando contadores do PAPI +
           ScoreP;
       	    b.1) A parte =along_time=
		c) Definir as fases, aplicar conhecimento para reduzir energia
    
* [22:15:57; 08.07.2016] Configuração de Ambiente Scorep e PAPI     :Gabriel:
** Instalação do PAPI
#+begin_src sh :results output :exports both
cd $HOME/Downloads/
wget http://icl.cs.utk.edu/projects/papi/downloads/papi-5.4.3.tar.gz
tar -vzxf papi-5.4.3.tar.gz
cd papi-5.4.3/src/
./configure
make
sudo make install
#+end_src

- Verificando se a instalação foi realizada com sucesso

#+begin_src sh :results output :exports both
cd /usr/local/lib/
ls | grep -i libpapi
#+end_src

#+RESULTS:
: libpapi.a
: libpapi.so
: libpapi.so.5
: libpapi.so.5.4.3
: libpapi.so.5.4.3.0

#+begin_src sh :results output :exports both
cd /usr/local/include/
ls | grep -i papi.h
#+end_src

#+RESULTS:
: f77papi.h
: f90papi.h
: fpapi.h
: papi.h

** Instalação do Scorep

- Um dos pré-requisitos de instalação do Scorep e a instalação do
  =Qt_app=.

#+begin_src sh :results output :exports both
cd $HOME/Downloads/
wget http://download.qt.io/official_releases/online_installers/qt-unified-linux-x64-online.run
./qt-unified-linux-x64-online.run
#+end_src

#+RESULTS:

#+begin_src sh :results output :exports both
cd $HOME/Programs/
wget http://www.vi-hps.org/upload/packages/scorep/scorep-2.0.2.tar.gz
tar -vxf scorep-2.0.2.tar.gz
rm scorep-2.0.2.tar.gz
cd scorep-2.0.2/
./configure --prefix=$HOME/Programs/scorep-2.0.2/ --enable-papi  --with-papi-lib=/usr/local/lib/ --with-papi-header=/usr/local/include/
make
sudo make install
#+end_src

#+RESULTS:

#+BEGIN_EXAMPLE

#+END_EXAMPLE

- Compilando aplicação com OpenMP com Scorep

#+begin_src sh :results output :exports both
cd benchmarks/MM/
$HOME/Programs/scorep-2.0.2/bin/scorep gcc -fopenmp -O2 hpcelo.c continuos.c -o continuos_sp
ls
#+end_src

#+RESULTS:
#+begin_example
continuos.c
continuos_sp
continuosT.c
hpcelo.c
hpcelo.h
Makefile
normal.c
normalT.c
tiling.c
tilingT.c
#+end_example

- Habilitando o trace para a execução da aplicação:

#+begin_src sh :results output :exports both
cd benchmarks/MM/
export SCOREP_ENABLE_PROFILING=true
export SCOREP_ENABLE_TRACING=true
export SCOREP_TOTAL_MEMORY=2G
export SCOREP_METRIC_PAPI=
export SCOREP_METRIC_PAPI_PER_PROCESS=PAPI_L1_TCA,PAPI_L2_TCA
export SCOREP_METRIC_RUSAGE_PER_PROCESS=all
export SCOREP_MEMORY_RECORDING=true
export SCOREP_EXPERIMENT_DIRECTORY=continuosExecution 
./continuos_sp 1000
ls
#+end_src

#+RESULTS:
#+begin_example
HPCELO:1.065932
continuos.c
continuosExecution
continuos_sp
continuosT.c
hpcelo.c
hpcelo.h
Makefile
normal.c
normalT.c
tiling.c
tilingT.c
#+end_example
* [16:22:11; 14.07.2016] Conversa semanal com Gabriel         :Gabriel:Lucas:

Com relação a entrada:
- [[*DefiniÃ§Ã£o do assunto da dissertaÃ§Ã£o][Definição do assunto da dissertação]]

Rastreamento com scorep 2.0.2, configurado da seguinte maneira:

#+BEGIN_EXAMPLE
./configure --prefix=/home/schnorr/install/scorep-2.0.2/ --enable-papi  --with-papi-lib=/usr/local/lib/ --with-papi-header=/usr/local/include/
#+END_EXAMPLE

Na saída do config.log, temos:

#+BEGIN_EXAMPLE
(...)
    Score-P (backend):
      C99 compiler used:        gcc
      Pthread support:          yes, using gcc -pthread 
      compiler constructor:     yes, using attribute syntax
      TLS support:              yes, using __thread
      PAPI support:             yes
      metric perf support:      yes
      Unwinding support:        yes
        libunwind support:      yes, using -D_GNU_SOURCE -lunwind
      Sampling support:         yes, using -D_GNU_SOURCE, sa_sigaction
      getrusage support:        yes
      RUSAGE_THREAD support:    yes, using -D_GNU_SOURCE
      dlfcn support:            yes, using -ldl
(...)
#+END_EXAMPLE

Depois de configurar as seguintes variáveis de ambiente:

#+BEGIN_EXAMPLE
export SCOREP_ENABLE_TRACING=true
export SCOREP_METRIC_PAPI=PAPI_L1_TCM
#+END_EXAMPLE

O programa foi executado com =sudo -E=. O argumento =-E= foi importante
para que as variáveis de ambiente do shell corrente sejam transferidas
para o shell que o sudo criará para lançar a aplicação. Precisamos
utilizar =sudo= pois a aplicação necessita acessar contadores de
hardware que são capazes de ser lidos pelo superusuário. Uma forma
melhor de fazer isto é utilizar =setcap=.

Depois de executar o programa que foi compilado com =scorep gcc=,
podemos ver a evolução da métrica =PAPI_L1_TCM= ao longo do tempo
através do seguinte comando:
- a terceira coluna é o timestamp onde o valor da métrica foi
  observado
- o valor da métrica aparece depois do UINT64

No caso de =PAPI_L1_TCM= o valor da métrica é a quantidade de vezes que
ocorreu cache miss na cache L1.

#+BEGIN_EXAMPLE
schnorr@guarani:~/svn/hpcelo-gabriel/MM/src$ /home/schnorr/install/scorep-2.0.2/bin/otf2-print scorep-20160714_1559_2932482742715837/traces.otf2 | grep 12884901888 | grep METRIC
METRIC                           12884901888     2932482706525714  Metric: 0, 1 Values: ("PAPI_L1_TCM" <8>; UINT64; 571)
METRIC                           12884901888     2932482706534678  Metric: 0, 1 Values: ("PAPI_L1_TCM" <8>; UINT64; 776)
METRIC                           12884901888     2932482732253601  Metric: 0, 1 Values: ("PAPI_L1_TCM" <8>; UINT64; 930)
METRIC                           12884901888     2932482732318445  Metric: 0, 1 Values: ("PAPI_L1_TCM" <8>; UINT64; 1119)
METRIC                           12884901888     2932482732323234  Metric: 0, 1 Values: ("PAPI_L1_TCM" <8>; UINT64; 1181)
METRIC                           12884901888     2932482732325389  Metric: 0, 1 Values: ("PAPI_L1_TCM" <8>; UINT64; 1192)
...
#+END_EXAMPLE

Quais são os contadores que devem ser medidos?
- Difícil responder, primeiro precisamos investigar quais contadores
  poderiam (no caso de valores altos) representar uma aplicação
  CPU-bound e uma aplicação MEMORY-bound.
- Procurar na literatura artigos que consigam definir uma eventual
  relação que exista entre CPU-bound e determinados contadores de
  hardware (e o equivalente para algo MEMORY-bound)

Tarefas:
- Medir ao longo do tempo e com scorep o máximo possível de contadores
  - Eventualmente todos os contadores disponíveis
- Utilizar a aplicação de MM desenvolvida por ti
* [23:39:31; 14.07.2016] Execução do benchmark MM com PAPI via Scorep :Gabriel:

- Compilação, utilizando o make file com a diretiva =scorep gcc=:

#+begin_src sh :results output :exports both
cd benchmarks/MM/
make
ls
#+end_src

#+RESULTS:
#+begin_example
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o normal_seq.o -c normal.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o normal_seq hpcelo.c normal_seq.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o normal_par.o -c normal.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o normal_par hpcelo.c normal_par.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o continuos_seq.o -c continuos.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o continuos_seq hpcelo.c continuos_seq.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o continuos_par.o -c continuos.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o continuos_par hpcelo.c continuos_par.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o tiling_seq.o -c tiling.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o tiling_seq hpcelo.c tiling_seq.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o tiling_par.o -c tiling.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o tiling_par hpcelo.c tiling_par.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o normal_seqT.o -c normalT.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o normal_seqT hpcelo.c normal_seqT.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o normal_parT.o -c normalT.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o normal_parT hpcelo.c normal_parT.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o continuos_seqT.o -c continuosT.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o continuos_seqT hpcelo.c continuos_seqT.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o continuos_parT.o -c continuosT.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o continuos_parT hpcelo.c continuos_parT.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o tiling_seqT.o -c tilingT.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -o tiling_seqT hpcelo.c tiling_seqT.o
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o tiling_parT.o -c tilingT.c
/home/gbmoro/Programas/scorep-2.0.2/bin/scorep gcc -Wall -Wextra -O2 -fopenmp -o tiling_parT hpcelo.c tiling_parT.o
continuos.c
continuos_par
continuos_par.o
continuos_parT
continuos_parT.o
continuos_seq
continuos_seq.o
continuos_seqT
continuos_seqT.o
continuosT.c
hpcelo.c
hpcelo.h
Makefile
normal.c
normal_par
normal_par.o
normal_parT
normal_parT.o
normal_seq
normal_seq.o
normal_seqT
normal_seqT.o
normalT.c
tiling.c
tiling_par
tiling_par.o
tiling_parT
tiling_parT.o
tiling_seq
tiling_seq.o
tiling_seqT
tiling_seqT.o
tilingT.c
#+end_example

#+begin_src sh :results output :exports both
cd benchmarks/MM/
export SCOREP_ENABLE_TRACING=true
export SCOREP_TOTAL_MEMORY=2G
export SCOREP_METRIC_PAPI=PAPI_L1_DCM,PAPI_L1_ICM,PAPI_L2_DCM
export SCOREP_METRIC_RUSAGE=ru_utime,ru_stime
export SCOREP_EXPERIMENT_DIRECTORY=exec1
./normal_parT 100
cd exec1/
/$HOME/Programas/scorep-2.0.2/bin/otf2-print traces.otf2
#+end_src

#+RESULTS:
#+begin_example

=== OTF2-PRINT ===
=== Events =====================================================================
Event                               Location            Timestamp  Attributes
--------------------------------------------------------------------------------
METRIC                                     0       79633289900948  Metric: 0, 5 Values: ("PAPI_L1_DCM" <8>; UINT64; 2890), ("PAPI_L1_ICM" <9>; UINT64; 7001), ("PAPI_L2_DCM" <10>; UINT64; 1770), ("ru_utime" <11>; UINT64; 4000), ("ru_stime" <12>; UINT64; 12000)
ENTER                                      0       79633289900948  Region: "main" <16>

#+end_example

* DONE [09:25:09; 15.07.2016] Criação do script para execução do benchmark MM com PAPI via Scorep :Gabriel:

- State "DONE"       from "STARTED"    [2016-07-15 Sex 20:35]
- State "STARTED"    from              [2016-07-15 Sex 10:14]
#+begin_src sh :results output :exports both :tangle benchmarks/MM/scriptSimulation.bash
#!bin/bash

apps=( 
    "continuos_par" 
    "continuos_parT" 
    "normal_par" 
    "normal_parT" 
    "tiling_par" 
    "tiling_parT" 
)

inputSizes=( 
    50 
    60 
    80 
    100 
)

export SCOREP_ENABLE_TRACING=true
export SCOREP_METRIC_PAPI=PAPI_L1_DCM,PAPI_L1_ICM,PAPI_L1_TCM,PAPI_L2_DCM,PAPI_L2_ICM,PAPI_L2_TCM,PAPI_L2_ICA,PAPI_L3_ICA
export SCOREP_METRIC_RUSAGE=ru_utime,ru_stime


for j in ${apps[@]}
do 
  for i in ${inputSizes[@]}
  do
    echo "Running app: $j size: $i"
    export SCOREP_EXPERIMENT_DIRECTORY="exec_$jsize$i"
    sudo -E ./$j $i
  done
done

#+end_src

O script de execução está rodando corretamente, os contadores PAPI
utilizados foram escolhidos de acordo com a disponibilidade da minha
máquina pessoal. Estou com problemas apenas na execução do algoritmo
=tiling=, isso Ã© porque o mesmo utiliza muito a memória principal para
otimizar o uso da cache. O erro que está acontecendo com o SCOREP é o
seguinte:

#+BEGIN_EXAMPLE
Running app: tiling_par size: 60
[Score-P] Trace buffer flush on rank 0.
[Score-P] Increase SCOREP_TOTAL_MEMORY and try again.
[Score-P] Trace buffer flush on rank 0.
[Score-P] Increase SCOREP_TOTAL_MEMORY and try again.
[Score-P] Trace buffer flush on rank 0.
[Score-P] Increase SCOREP_TOTAL_MEMORY and try again.
[Score-P] Trace buffer flush on rank 0.
[Score-P] Increase SCOREP_TOTAL_MEMORY and try again.
[Score-P] Trace buffer flush on rank 0.
[Score-P] Increase SCOREP_TOTAL_MEMORY and try again.
HPCELO:0.462356
#+END_EXAMPLE

- Vou mudar o script para aumentar o =SCOREP_TOTAL_MEMORY=:

#+begin_src sh :results output :exports both :tangle benchmarks/MM/scriptSimulation2.bash
#!bin/bash

apps=( 
    "continuos_par" 
    "continuos_parT" 
    "normal_par" 
    "normal_parT" 
    "tiling_par" 
    "tiling_parT" 
)

inputSizes=( 
    50 
    60 
    80 
    100 
)

export SCOREP_ENABLE_TRACING=true
export SCOREP_TOTAL_MEMORY=3G
export SCOREP_PAGE_SIZE=800000
export SCOREP_METRIC_PAPI=PAPI_L1_DCM,PAPI_L1_ICM,PAPI_L1_TCM,PAPI_L2_DCM,PAPI_L2_ICM,PAPI_L2_TCM,PAPI_L2_ICA,PAPI_L3_ICA
export SCOREP_METRIC_RUSAGE=ru_utime,ru_stime


for j in ${apps[@]}
do 
  for i in ${inputSizes[@]}
  do
    echo "Running app: $j size: $i"
    export SCOREP_EXPERIMENT_DIRECTORY="exec_$jsize$i"
    sudo -E ./$j $i
  done
done

#+end_src

Executando o script com a modificação no =SCOREP_TOTAL_MEMORY= para 3
gigabytes, ocorreu o seguinte erro:

#+BEGIN_EXAMPLE
[Score-P] Please report this to support@score-p.org. Thank you.
[Score-P] Try also to preserve any generated core dumps.
^CRunning app: tiling_parT size: 60
[Score-P] src/measurement/SCOREP_Memory.c:106: Fatal: Bug '!allocator': Cannot create memory manager for SCOREP_TOTAL_MEMORY=3221225472 and SCOREP_PAGE_SIZE=800000
#+END_EXAMPLE

Esse erro de acordo com os fÃ³runs Ã© devido a minha limitaÃ§Ã£o de
memÃ³ria principal. 

- Vou modificar o script para executar todos os algoritmos de
  multiplicação de matriz, exceto o =tiling=.

#+begin_src sh :results output :exports both :tangle benchmarks/MM/scriptSimulation3.bash
#!bin/bash

apps=( "continuos_par" "continuos_parT" "normal_par" "normal_parT" )

inputSizes=( 50 60 80 100 )

export SCOREP_ENABLE_TRACING=true
export SCOREP_METRIC_PAPI=PAPI_L1_DCM,PAPI_L1_ICM,PAPI_L1_TCM,PAPI_L2_DCM,PAPI_L2_ICM,PAPI_L2_TCM,PAPI_L2_ICA,PAPI_L3_ICA
export SCOREP_METRIC_RUSAGE=ru_utime,ru_stime


for j in ${apps[@]}
do 
  for i in ${inputSizes[@]}
  do
          export SCOREP_EXPERIMENT_DIRECTORY="exec_$j$i"
	    echo "Running app: $j size: $i"
	    sudo -E ./$j $i
  done
done

#+end_src

As pastas geradas foram:

#+begin_src sh :results output :exports both
cd benchmarks/MM/
ls | grep -i exec
#+end_src

#+RESULTS:
#+begin_example
exec_continuos_par100
exec_continuos_par50
exec_continuos_par60
exec_continuos_par80
exec_continuos_parT100
exec_continuos_parT50
exec_continuos_parT60
exec_continuos_parT80
exec_normal_par100
exec_normal_par50
exec_normal_par60
exec_normal_par80
exec_normal_parT100
exec_normal_parT50
exec_normal_parT60
exec_normal_parT80
#+end_example

O próximo passo é fazer um script para analisar esses dados e a partir
deles gerar um arquivo csv. Esse script deverá utilizar a saída da
ferramenta =otf2print= disponibilizada pelo =scorep=.
* WAITING [00:09:15; 16.07.2016] Análise dos resultados do experimento com PAPI - benchmark MM :Gabriel:
- State "WAITING"    from "STARTED"    [2016-07-18 Seg 12:07]
- State "STARTED"    from              [2016-07-16 SÃ¡b 14:24]

** Exportando o arquivo csv por thread
Primeiramente vou fazer um script teste para gerar o csv do arquivo
gerado na execução da versão =normal_par= com =80= de entrada. O script
vai ser criado em python, porque como são muitos dado

#+begin_src sh :results output :exports both
cd benchmarks/MM/exec_normal_par80/
/home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | awk '{ print $1,$2,$3,$4,$5,$8,$11,$12,$15,$16,$19,$20,$21,$24,$27,$28,$31 }' >> t.csv
#+end_src

#+RESULTS:

#+begin_src sh :results output :exports both
cd benchmarks/MM/exec_normal_par80/
sudo /home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | awk '{ print $1,$2,$3,$4,$5,$8,$11,$12,$15,$16,$19,$20,$21,$24,$27,$28,$31 }' >> t.csv
#+end_src

#+RESULTS:
|sh: 2: cannot create t.csv: Permission denied|

#+begin_src sh :results output :exports both
cd benchmarks/MM/
chmod 777 exec*
#+end_src

#+RESULTS:

- Vou tentar novamente com as permissões alteradas

#+begin_src sh :results output :exports both
cd benchmarks/MM/exec_normal_par80/
 /home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | sed 's/(//g' | sed 's/)//g' | sed 's/\"P/P/g' | sed 's/\"/,/g' | sed 's/C[[:space:]]/C,/g' | sed 's/[[:space:]]M/,M/g' | sed 's/[[:space:]]R/,R/g'  | sed 's/AVE[[:space:]]/AVE,/g' | sed 's/ER[[:space:]]/ER,/g' | awk '{ print $1,$3,$4,$5,$8,$11,$16,$19,$24,$27,$28,$31 }' >> ../execNormal80.csv
#+end_src

- Dessa maneira funcionou

O script vai funcionar da seguinte forma primeiramente vou filtrar
pela palavra thread, a fim de conhecer o identificador respectivo de
cada thread, da seguinte maneira:

#+begin_src sh :results output :exports both
cd exec_normal_par80/
/home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | awk '{ print $1,$2,$3,$4,$5,$8,$11,$16,$19,$24,$27,$28,$31 }' | grep -i thread

#+end_src

#+RESULTS:
#+begin_example
THREAD_FORK 0 148300136098648 Model: "OpenMP" Requested       
THREAD_TEAM_BEGIN 8589934592 148300136631927 Thread Team:        
THREAD_TEAM_BEGIN 12884901888 148300136632116 Thread Team:        
THREAD_TEAM_BEGIN 4294967296 148300136632125 Thread Team:        
THREAD_TEAM_BEGIN 0 148300136632758 Thread Team:        
THREAD_TEAM_END 4294967296 148300137791884 Thread Team:        
THREAD_TEAM_END 0 148300137794262 Thread Team:        
THREAD_TEAM_END 8589934592 148300137794587 Thread Team:        
THREAD_TEAM_END 12884901888 148300137827954 Thread Team:        
THREAD_JOIN 0 148300137838547 Model: "OpenMP"        
#+end_example

A partir dessa saída é possível visualizar o momento em que o fork
inicia e termina. Além disso é possível visualizar o identificador de
cada thread.

#+begin_src sh :results output :exports both :tangle benchmarks/MM/scriptAnalyseTest.sh
cd exec_normal_par80/
array=$(/home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | awk '{ print $1,$2,$3,$4,$5,$8,$11,$16,$19,$24,$27,$28,$31 }' | grep -i THREAD_TEAM_BEGIN | awk ' { print $2 } ')

threads=4

x=1

while [ $x -le $threads ];
do
      echo $array | cut -d ' ' -f$x
	x=$((x+1))
done

#+end_src

#+RESULTS:
: 8589934592
: 12884901888
: 4294967296
: 0

Agora vou utilizar um desses identificadores de thread para recuperar
as medidas obtidas pelos =contadores de hardware= para as regiões de
código daquela thread.

#+begin_src sh :results output :exports both
cd benchmarks/MM/exec_normal_par80/
/home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | sed 's/(//g' | sed 's/)//g' | sed 's/\"P/P/g' | sed 's/\"/,/g' | sed 's/C[[:space:]]/C,/g' | sed 's/[[:space:]]M/,M/g' | sed 's/[[:space:]]R/,R/g'  | sed 's/AVE[[:space:]]/AVE,/g' | sed 's/ER[[:space:]]/ER,/g' | awk '{ print $1,$2,$3,$4,$5,$8,$11,$16,$19,$24,$27,$28,$31 }' | grep -i 8589934592
#+end_src

#+RESULTS:
#+begin_example
THREAD_TEAM_BEGIN 8589934592 148300136631927 Thread Team:        
METRIC, 8589934592 148300137337967 ,Metric: 0, PAPI_L1_DCM, 135, PAPI_L1_TCM, 550, PAPI_L2_ICM, 278, PAPI_L2_TCM, 367,
ENTER, 8589934592 148300137337967 ,Region: ,!$omp <3>       
METRIC, 8589934592 148300137347440 ,Metric: 0, PAPI_L1_DCM, 188, PAPI_L1_TCM, 831, PAPI_L2_ICM, 344, PAPI_L2_TCM, 458,
ENTER, 8589934592 148300137347440 ,Region: ,!$omp <4>       
METRIC, 8589934592 148300137764567 ,Metric: 0, PAPI_L1_DCM, 16509, PAPI_L1_TCM, 17407, PAPI_L2_ICM, 402, PAPI_L2_TCM, 1044,
ENTER, 8589934592 148300137764567 ,Region: ,!$omp @normal.c:51,       
METRIC, 8589934592 148300137775434 ,Metric: 0, PAPI_L1_DCM, 16596, PAPI_L1_TCM, 17558, PAPI_L2_ICM, 418, PAPI_L2_TCM, 1090,
LEAVE, 8589934592 148300137775434 ,Region: ,!$omp @normal.c:51,       
METRIC, 8589934592 148300137781926 ,Metric: 0, PAPI_L1_DCM, 16615, PAPI_L1_TCM, 17612, PAPI_L2_ICM, 430, PAPI_L2_TCM, 1104,
LEAVE, 8589934592 148300137781926 ,Region: ,!$omp <4>       
METRIC, 8589934592 148300137788125 ,Metric: 0, PAPI_L1_DCM, 16636, PAPI_L1_TCM, 17644, PAPI_L2_ICM, 430, PAPI_L2_TCM, 1105,
LEAVE, 8589934592 148300137788125 ,Region: ,!$omp <3>       
THREAD_TEAM_END 8589934592 148300137794587 Thread Team:        
#+end_example

- O script final para gerar os arquivos =csv= para análise será criado a
  partir dos fragmentos de script anteriores

#+begin_src sh :results output :exports both :tangle benchmarks/MM/scriptCSVExporter.sh

scorepFolders=$( ls | grep -i "exec_")

threads=4

for i in ${scorepFolders[@]};
do
      cd $i
      
      array=$(/home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | awk '{ print $1,$2,$3,$4,$5,$8,$11,$16,$19,$24,$27,$28,$31 }' | grep -i THREAD_TEAM_BEGIN | awk ' { print $2 } ')

	x=1
	
	echo "Folder: $i"
	while [ $x -le $threads ];
	do
		echo "Thread visited: $x"
    		idTmp=$(echo $array | cut -d ' ' -f$x)
		/home/gbmoro/Programas/scorep-2.0.2/bin/otf2-print traces.otf2 | sed 's/(//g' | sed 's/)//g' | sed 's/\"P/P/g' | sed 's/\"/,/g' | sed 's/C[[:space:]]/C,/g' | sed 's/[[:space:]]M/,M/g' | sed 's/[[:space:]]R/,R/g'  | sed 's/AVE[[:space:]]/AVE,/g' | sed 's/ER[[:space:]]/ER,/g' | awk '{ print $1,$2,$3,$4,$5,$8,$11,$16,$19,$24,$27,$28,$31 }' | grep -i $idTmp >> thread_$idTmp.csv
		x=$((x+1))
	done
	cd ..
done

#+end_src

#+RESULTS:
| Folder: exec_continuos_par100  |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_par50   |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_par60   |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_par80   |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_parT100 |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_parT50  |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_parT60  |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_continuos_parT80  |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_par100     |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_par50      |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_par60      |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_par80      |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_parT100    |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_parT50     |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_parT60     |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
| Folder: exec_normal_parT80     |
| Thread visited: 1              |
| Thread visited: 2              |
| Thread visited: 3              |
| Thread visited: 4              |
|                                |

** Analizando resultados obtidos

- O caso escolhido para ser o primeiro a ser analisado e plotado em
  gráfico é o algoritmo normal de entrada igual a 80. Seus rastros
  estão disponíveis na pasta:

#+begin_src sh :results output :exports both :tangle benchmarks/MM/exec_normal_par80/scriptOfGraph.sh
#path: benchmarks/MM/exec_normal_par80/

threadsFiles=$(ls | grep -i thre)
count=0;

for x in ${threadsFiles[@]};
do
	array=$(cat $x | awk '{ print $6 $7"\n"$8 $9"\n"$10 $11"\n"$12 $13}' | sed 's/(//g' | sed 's/)//g' | sed 's/\"/,/g' | sed 's/,,/,/g')
	idThread=$(echo $x | sed 's/.csv//g'| sed 's/thread_//g')
	let count=$count+1
	for i in ${array[@]};
	do
    	if [[ $i =~ .*@.* || $i =~ .*\<.* || $i =~ .*Threads.* || $i =~ .*Request*. ]]; then
	   		continue	    
		else
		    	echo "$count,$i" >> threadAnalyse.csv
		fi
	done
done

echo "thread,hardwareCounter,value" >> threadAnalyseOutput.csv
cat threadAnalyse.csv | sed 's/,,/,/g' |  sed 's/,*$//' >> threadAnalyseOutput.csv
rm threadAnalyse.csv 

#+end_src

#+RESULTS:

- Vou gerar um gráfico para visualizarmos o comportamento das threads
  nessa aplicação, através dos 4 contadores analisados.

#+begin_src R :results output graphics :file "graph.pdf" :exports both :session *Mnormalpar80*  :tangle benchmarks/MM/exec_normal_par80/plotScript.r
library(dplyr);
df <- read.csv("threadAnalyseOutput.csv");
k <- df %>% select(thread,hardwareCounter,value) %>%
     group_by(thread,hardwareCounter) %>%
     as.data.frame();

library(ggplot2);
ggplot(k, aes(x=as.factor(thread), y=value, color=hardwareCounter)) +
  geom_line(aes(group=thread)) +
  theme_bw() + scale_y_log10() +
  facet_wrap(~hardwareCounter);
#+end_src

#+RESULTS:
[[file:graph.pdf]]

* [2016-07-18 Mon 23:57] Retorno sobre as entradas anteriores         :Lucas:

Não consegui gerar a data desta entrada no formato visto nas seções
anteriores. Usei o atalho C-u C-c ! de acordo com o texto:
- http://orgmode.org/manual/Creating-timestamps.html

Reviso aqui o gráfico gerado na seção (veja seção imediatamente anterior):
- [[*Analizando resultados obtidos][Analizando resultados obtidos]]

Vamos olhar os dados (note o caminho relativo a raiz do repositório):

#+begin_src R :results output :session :exports both
df <- read.csv("benchmarks/MM/exec_normal_par80/threadAnalyseOutput.csv");
head(df);
#+end_src

#+RESULTS:
:   thread hardwareCounter value
: 1      1     PAPI_L1_DCM  4103
: 2      1     PAPI_L1_TCM 11234
: 3      1     PAPI_L2_ICM  4492
: 4      1     PAPI_L2_TCM  7141
: 5      1     PAPI_L1_DCM  4412
: 6      1     PAPI_L1_TCM 12150

O tempo desapareceu das medidas (imagino que ele deveria ser
mantido). Para tentar entender melhor o que foi feito, vamos olhar
para apenas uma thread e uma única métrica.

#+begin_src R :results output :session :exports both
head(df[df$thread == 1 & df$hardwareCounter == "PAPI_L1_DCM",]);
#+end_src

#+RESULTS:
:    thread hardwareCounter value
: 1       1     PAPI_L1_DCM  4103
: 5       1     PAPI_L1_DCM  4412
: 9       1     PAPI_L1_DCM  4523
: 13      1     PAPI_L1_DCM  4560
: 17      1     PAPI_L1_DCM  4589
: 21      1     PAPI_L1_DCM  4610

Parece estar tudo bem, o valor vai sempre aumentando.

Olhando o script =scriptOfGraph.sh=, parece-me que estás tirando fora a
informação de tempo. Não entendi também de onde tiraste a
informação das threads, pois olhando o arquivo =execNormal80.csv= (que
parece ser a origem dos dados), não tem dados sobre threads nas linhas
com as métricas. Veja:

#+begin_src sh :results output :session :exports both
ls -hl benchmarks/MM/execNormal80.csv
head benchmarks/MM/execNormal80.csv | grep METRIC
#+end_src

#+RESULTS:
: -rw-r--r-- 1 schnorr schnorr 6.3M Jul 18 23:42 benchmarks/MM/execNormal80.csv
: METRIC, 148299959479341 ,Metric: 0, PAPI_L1_DCM, 4103, PAPI_L1_TCM, 11234, PAPI_L2_ICM, 4492, PAPI_L2_TCM, 7141,
: METRIC, 148299959647641 ,Metric: 0, PAPI_L1_DCM, 4412, PAPI_L1_TCM, 12150, PAPI_L2_ICM, 4795, PAPI_L2_TCM, 7592,
: METRIC, 148299959668347 ,Metric: 0, PAPI_L1_DCM, 4523, PAPI_L1_TCM, 12576, PAPI_L2_ICM, 4846, PAPI_L2_TCM, 7690,

Olhando para o gráfico (e o código que o gerou):
[[file:benchmarks/MM/exec_normal_par80/graph.pdf]]

Alguns equívocos sobre o gráfico:
- estás desenhando com linha, quando deverias usar =geom_point()=
- evitar _sempre_ escalas logaritmicas, prefira escalas lineares

Existem alguns equívocos sobre os dados também. Por exemplo, após
agrupar com =group_by= nenhuma transformação nos dados é feita. Além
disso, entendo que como os valores dos contadores apenas aumentam
(veja acima), o ideal seria subtrair o maior valor do contador pelo
menor valor do mesmo contador. Isso permitiria tu obteres o valor
correto global para cada thread. Vejamos:

#+begin_src R :results output :session :exports both
k <- df[df$thread == 1 & df$hardwareCounter == "PAPI_L1_DCM",];
nrow(k);
#+end_src

#+RESULTS:
: [1] 76884

Existem várias medidas, vamos ver a diferença:

#+begin_src R :results output :session :exports both
head(k);
tail(k);
#+end_src

#+RESULTS:
#+begin_example
   thread hardwareCounter value
1       1     PAPI_L1_DCM  4103
5       1     PAPI_L1_DCM  4412
9       1     PAPI_L1_DCM  4523
13      1     PAPI_L1_DCM  4560
17      1     PAPI_L1_DCM  4589
21      1     PAPI_L1_DCM  4610
       thread hardwareCounter  value
307513      1     PAPI_L1_DCM 339304
307517      1     PAPI_L1_DCM 339321
307521      1     PAPI_L1_DCM 339494
307525      1     PAPI_L1_DCM 339497
307529      1     PAPI_L1_DCM 339595
307533      1     PAPI_L1_DCM 339604
#+end_example

Como não temos a coluna do tempo (foi removida desse CSV pelo script
mencionado acima), vamos plotar este valor em função da ordem das
medições. Mas primeiro, adicionar uma nova coluna com um identificador
de cada medição:

#+begin_src R :results output :session :exports both
k$seq = seq(1,nrow(k));
head(k);
tail(k);
#+end_src

#+RESULTS:
#+begin_example
   thread hardwareCounter value seq
1       1     PAPI_L1_DCM  4103   1
5       1     PAPI_L1_DCM  4412   2
9       1     PAPI_L1_DCM  4523   3
13      1     PAPI_L1_DCM  4560   4
17      1     PAPI_L1_DCM  4589   5
21      1     PAPI_L1_DCM  4610   6
       thread hardwareCounter  value   seq
307513      1     PAPI_L1_DCM 339304 76879
307517      1     PAPI_L1_DCM 339321 76880
307521      1     PAPI_L1_DCM 339494 76881
307525      1     PAPI_L1_DCM 339497 76882
307529      1     PAPI_L1_DCM 339595 76883
307533      1     PAPI_L1_DCM 339604 76884
#+end_example

Ótimo, agora vamos ao gráfico:

#+begin_src R :results output graphics :file (org-babel-temp-file "figure" ".png") :exports both :width 600 :height 400 :session
library(ggplot2);
ggplot(k, aes(x=seq, y=value)) + geom_point() + theme_bw();
#+end_src

#+RESULTS:
[[file:/tmp/babel-10319ASZ/figure10319Cnl.png]]

Veja já que grave, o contador bate no limite e volta para 0. Isso é um
problema pois não podemos simplesmente considerar a diferenças entre o
valor máximo e o mínimo para ter um sumário do valor para cada thread.

Qual seria a solução para isso?

Veja o momento onde isso acontece.

#+begin_src R :results output :session :exports both
head(k[k$seq > 38439,]);
#+end_src

#+RESULTS:
:        thread hardwareCounter  value   seq
: 153757      1     PAPI_L1_DCM 339497 38440
: 153761      1     PAPI_L1_DCM 339595 38441
: 153765      1     PAPI_L1_DCM 339604 38442
: 153769      1     PAPI_L1_DCM   4103 38443
: 153773      1     PAPI_L1_DCM   4412 38444
: 153777      1     PAPI_L1_DCM   4523 38445

Isso é relativamente simples de detectar no momento do
rastreamento. Não há nenhum evento do Score-P que informa que houve
uma quebra do contador (pelo seu tamanho limitado)?

Isso deve ser resolvido antes de qualquer coisa.

_Tarefas_:
- adicionar uma coluna de tempo ao CSV
- tentar detectar a quebra do contador no Score-p

A ferramenta ReDFST parece que rastrea alguns contadores (não tenho
total certeza), e me parece também que ela detectaria. Mas os valores
de contadores obtidos são sempre globais. O que queremos é a evolução
do valor dos contadores _ao longo do tempo_.
* [13:44:21; 04.08.2016] Reexecução do benchmark MM com PAPI via Scorep - Contadores principais :Gabriel:
- Os principais contadores para visualizarmos o comportamento da
  aplicação via PAPI são: =PAPI_L1_DCH=, =PAPI_L2_DCH=, =PAPI_L3_TCM=,
  =PAPI_L1_DCA=, =PAPI_L2_DCA=, =PAPI_L3_DCA= e =PAPI_FP_OPS=.

Primeiramente vamos visualizar quais contadores temos disponíveis na
  máquina =beagle1= (terceira coluna é a disponibilidade do contador) :

#+begin_src sh :results output :exports both
sudo papi_avail | grep -i DCH
#+end_src

#+RESULTS:
| PAPI_L3_DCH  0x8000001d  No    No   Level 3 data cache hits |
| PAPI_L1_DCH  0x8000003e  No    No   Level 1 data cache hits |
| PAPI_L2_DCH  0x8000003f  Yes   Yes  Level 2 data cache hits |

#+begin_src sh :results output :exports both
sudo papi_avail | grep -i TCM
#+end_src

#+RESULTS:
| PAPI_L1_TCM  0x80000006  Yes   Yes  Level 1 cache misses |
| PAPI_L2_TCM  0x80000007  Yes   No   Level 2 cache misses |
| PAPI_L3_TCM  0x80000008  Yes   No   Level 3 cache misses |

#+begin_src sh :results output :exports both
sudo papi_avail | grep -i DCA
#+end_src

#+RESULTS:
| PAPI_L1_DCA  0x80000040  No    No   Level 1 data cache accesses |
| PAPI_L2_DCA  0x80000041  Yes   No   Level 2 data cache accesses |
| PAPI_L3_DCA  0x80000042  Yes   Yes  Level 3 data cache accesses |

#+begin_src sh :results output :exports both
sudo papi_avail | grep -i OPS
#+end_src

#+RESULTS:
| PAPI_FP_OPS  0x80000066  Yes   Yes  Floating point operations                                                               |
| PAPI_SP_OPS  0x80000067  Yes   Yes  Floating point operations; optimized to count scaled single precision vector operations |
| PAPI_DP_OPS  0x80000068  Yes   Yes  Floating point operations; optimized to count scaled double precision vector operations |

- Todos os contadores que serão utilizados no experimento são
  disponíveis na =beagle1=.
  
** Experimento
*** Projeto do Experimento

- Definição do projeto do experimento a ser realizado:

#+begin_src R :results output :session *experiment* :exports both
require(DoE.base);
  expDesign_MM <- fac.design (
           nfactors=2,
           replications=5,
           repeat.only=FALSE,
           blocks=1,
           randomize=TRUE,
           seed=10373,
           nlevels=c(6,2),
           factor.names=list(
               app=c("normal_par","continuos_par","tiling_par","normal_parT","continuos_parT","tiling_parT"),
			size=c(50,80)));

  export.design(expDesign_MM,
                path=".",
                filename=NULL,
                type="csv",
                replace=TRUE,
                response.names=c("timeOfExecution","thread_region","idThread","PAPI_L2_DCH",
"PAPI_L2_DCA","PAPI_L1_TCM","PAPI_L2_TCM",
"PAPI_L3_TCM","PAPI_FP_OPS"));

#+end_src

#+RESULTS:
#+begin_example
Loading required package: DoE.base
Loading required package: grid
Loading required package: conf.design

Attaching package: ‘DoE.base’

The following objects are masked from ‘package:stats’:

    aov, lm

The following object is masked from ‘package:graphics’:

    plot.design

The following object is masked from ‘package:base’:

    lengths
 creating full factorial with 12 runs ...
#+end_example

- O full factorial pode ser visualizado na imagem gerada pelo seguinte
  script:

#+begin_src R :results output graphics :file "imagens/fullFactorialExpMM.png") :exports both :width 600 :height 400 :session *R* 
library(SixSigma)
library(grid)

effect<-"Hit, Misses das Caches e Operações FP"
causes.gr<-c("Versão", "Tamanho", "Threads")
causes<-vector(mode="list", length=length(causes.gr))

causes[1]<-list(c("normal_par","normal_parT", "continuos_par", "continuos_parT", "tiling_par", "tiling_parT"))
causes[2]<-list(c(50,80))
causes[3]<-list(c(32))

ss.ceDiag(effect, causes.gr, causes, sub="Experiment")

#+end_src

#+RESULTS:
[[file:imagens/fullFactorialExpMM.png]]

*** Plataforma de Execução

- As principais características da =beagle1= são:

#+begin_src sh :results output :exports both
lscpu
#+end_src

#+RESULTS:
| Architecture:          x86_64                                      |    |
| CPU op-mode(s):        32-bit, 64-bit                             |    |
| Byte Order:            Little Endian                              |    |
| CPU(s):                32                                         |    |
| On-line CPU(s) list:   0-                                         | 31 |
| Thread(s) per core:    2                                          |    |
| Core(s) per socket:    8                                          |    |
| Socket(s):             2                                          |    |
| NUMA node(s):          2                                          |    |
| Vendor ID:             GenuineIntel                               |    |
| CPU family:            6                                          |    |
| Model:                 45                                         |    |
| Stepping:              7                                          |    |
| CPU MHz:               2000.141                                   |    |
| BogoMIPS:              4001.23                                    |    |
| Virtualization:        VT-x                                       |    |
| L1d cache:             32K                                        |    |
| L1i cache:             32K                                        |    |
| L2 cache:              256K                                       |    |
| L3 cache:              20480K                                     |    |
| NUMA node0 CPU(s):     0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30 |    |
| NUMA node1 CPU(s):     1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31 |    |

*** Script de simulação do experimento

#+begin_src sh :results output :exports :tangle dados/scriptOfSimulationExpMM.sh
#!bin/bash


function toClear() {
	sudo rm -rf tmp tmp2 tmp.csv tmp2.csv Results_expMM.csv
}

function toExport() {
	export SCOREP_ENABLE_TRACING=true
	export SCOREP_METRIC_RUSAGE=ru_utime,ru_stime
	export SCOREP_TOTAL_MEMORY=3G
}

function execute() {
	scorepPath=/home/aulapinroot/Programs/scorep-2.0.2/bin

	cat expDesign_MM.csv | head -1 >> Results_expMM.csv

	lines=$(cat expDesign_MM.csv)

	h=0
	for i in ${lines[@]}; do

		if [ $h -gt 1 ]; then
		    
			echo "definindo variáveis de ambiente"
			echo "exportando as variáveis utilizadas pelo scorep"

			toExport

			name=$(echo $i | cut -d ',' -f1)
			runNoInStdOrder=$(echo $i | cut -d ',' -f2)
			runNo=$(echo $i | cut -d ',' -f3)
			runRP=$(echo $i | cut -d ',' -f4)
			app=$(echo $i | cut -d ',' -f5 | sed 's/\"//g')
			size=$(echo $i | cut -d ',' -f6 | sed 's/\"//g')

			echo "Executando -- $app"

			export SCOREP_METRIC_PAPI=PAPI_L2_DCH,PAPI_L2_DCA,PAPI_L1_TCM
			export SCOREP_EXPERIMENT_DIRECTORY="tmp"

			timeOfExecution=$(sudo -E ./$app $size | sed 's/HPCELO://g')
			
			$scorepPath/otf2-print tmp/traces.otf2 | awk ' { print $1,$3,$11,$15,$19,$20} ' | sed 's/[\")(,]//g' | sed 's/\ /,/g' | sed 's/,,,,//g' | sed 's/,ru_utime//g' >> tmp.csv
			
			toExport

			export SCOREP_METRIC_PAPI=PAPI_L2_TCM,PAPI_L3_TCM,PAPI_FP_OPS
			export SCOREP_EXPERIMENT_DIRECTORY="tmp2"

			sudo -E ./$app $size
			
			$scorepPath/otf2-print tmp2/traces.otf2 | awk ' { print $1,$3,$11,$15,$19,$20} ' | sed 's/[\")(,]//g' | sed 's/\ /,/g' | sed 's/,,,,//g' | sed 's/,ru_utime//g' >> tmp2.csv 


			paste tmp.csv tmp2.csv > tmpR.csv
			
			sed -i 's/\t/,/g' tmpR.csv

			res=$(cat tmpR.csv)

			for count in ${res[@]}; do
				echo "$name,$runNoInStdOrder,$runNo,$runRP,$app,$size,$timeOfExecution,$count" >> Results_expMM.csv
			done;

			
			sudo rm -rf tmp tmp2 tmp.csv tmp2.csv tmpR.csv 
		fi

		let h=$h+1;
		echo "interation $h"
	done
}

toClear

execute
#+end_src

* 2016-08-10 Attempt to understand scorep hardware counters metrics   :Lucas:

#+begin_src sh :results output
otf2-print scorep-20160810_1601_8543111267115196/traces.otf2 | grep METRIC | awk '{ print "Thread", "Timestamp", $8, $12, $16 }' | tr -d '(\"' | sed "s/ /,/g" | head -n1 > x.csv
otf2-print scorep-20160810_1601_8543111267115196/traces.otf2  | grep ^METRIC | awk '{ print $2, $3, $11, $15, $19 }' | tr -d ")," | sed "s/ /,/g" >> x.csv
#+end_src

#+begin_src R :results output :session :exports both
df <- read.csv("artigos/2016_wsppd/idgraf_2016_08_10.csv");
df$Timestamp <- df$Timestamp - min(df$Timestamp); #obtain a zero
df$Timestamp <- df$Timestamp/1000000000; #in seconds now
library(reshape);
df <- melt(df, id=c("Thread", "Timestamp"));

head(df);
#+end_src

#+RESULTS:
:       Thread Timestamp    variable  value
: 1          0  0.000000 PAPI_L2_DCH    219
: 2          0  1.461988 PAPI_L2_DCH 177452
: 3          0  1.462043 PAPI_L2_DCH 177463
: 4          0  1.466827 PAPI_L2_DCH 179331
: 5          0  1.466844 PAPI_L2_DCH 179357
: 6 8589934592  1.493765 PAPI_L2_DCH    121

#+begin_src R :results output graphics :file "imagens/analiseProfLucas.png" :exports both :width 1200 :height 800 :session
library(ggplot2);
ggplot(df, aes(x=Timestamp, y=value, color=variable)) + geom_line() + theme_bw() + facet_grid(Thread~variable);
#+end_src

#+RESULTS:
[[file:imagens/analiseProfLucas.png]]

Data is clearly missing. There is no measurements from timestamp 0 to
more than 200s. It might be some issue related to tracing. Let's check
the dataframe textually, for thread 0:

#+begin_src R :results output :session :exports both
df[df$Thread == 0 & df$variable == "PAPI_L2_DCH",];
#+end_src

#+RESULTS:
#+begin_example
    Thread  Timestamp    variable      value
1        0   0.000000 PAPI_L2_DCH        219
2        0   1.461988 PAPI_L2_DCH     177452
3        0   1.462043 PAPI_L2_DCH     177463
4        0   1.466827 PAPI_L2_DCH     179331
5        0   1.466844 PAPI_L2_DCH     179357
52       0   2.126407 PAPI_L2_DCH    1072592
119      0   2.228808 PAPI_L2_DCH    1072636
137      0   2.228837 PAPI_L2_DCH    1072636
146      0   2.228846 PAPI_L2_DCH    1072636
148      0   2.228958 PAPI_L2_DCH    1072677
190      0   2.228974 PAPI_L2_DCH    1072686
204      0 240.032126 PAPI_L2_DCH 7164116273
233      0 267.039035 PAPI_L2_DCH 7164116324
250      0 267.039065 PAPI_L2_DCH 7164116324
264      0 267.039075 PAPI_L2_DCH 7164116324
292      0 267.046954 PAPI_L2_DCH 7164116352
293      0 267.046964 PAPI_L2_DCH 7164116361
294      0 267.499745 PAPI_L2_DCH 7164116381
#+end_example

We should get a much finer granularity when measuring. I believe
scorep is only measuring the metrics when something is actually traced
(from the application level). That's very bad, since in the meantime
(from 2.228974 to 240.032126) we got nothing.

* STARTED [23:58:15; 10.08.2016] Script protótipo para coletar em diferentes time stamps usando abordagem manual com Intel PCM :Gabriel:
- State "STARTED"    from              [2016-08-11 Qui 16:40]
- O script deve inicializar o programa-alvo, em X interações deverá
  coletar os hardwares counters específicos para gerar o rastro de
  execução. Essas interações terão como condição de parada o término
  do processo, o time stamp será definido de acordo com o tempo gasto
  pela aplicação como um todo, por isso deverá ser informado por
  parâmetro.

#+begin_src sh :results output :exports both :tangle scripts/scriptPCMexp1.bash
pathOfIntelPCM=/home/aulapinroot/Programs/IntelPerformanceCounterMonitor-V2.11

app=normal_par

size=6000

flag=0

timeOfCollet=0.002 #em segundos
timeAcc=0.0

echo "The application $app is being executed..."
#disparando a aplicação alvo
./$app $size &

#cabeçalho do arquivo
echo "TimeStamp,L3miss,L2miss,L3hit,L2hit" >> Results.csv

while [ $flag -eq 0 ]; do
	echo "Time stamp - $timeAcc"

	#recuperando o estado do processo para ver se o mesmo está executando
	stateOfProcess=$(ps ux | grep -i $app | head -1 | awk ' { print $8 } ')

	#pegar a quantidade de Rs nesse fluxo de caracteres
	amountOfR=$(echo $stateOfProcess | grep R | wc -l | bc)	

	#se existir um R, então o processo está execuntando
	if [ $amountOfR == 1 ]; then
		flag=0;
	else
	    	flag=1;
	fi

	#aqui executo algum processo leve
	sudo -E $pathOfIntelPCM/pcm.x --noJKTWA -r --external-program clean >> tmp.log

	l3miss=$(cat tmp.log | grep -i "TOTAL *" | head -1 | awk ' { print $7,$8 } ')
	l3miss=$(echo $l3miss | sed -e 's/[[:space:]]K/*1024/g')
	l3miss=$(echo $l3miss | sed -e 's/[[:space:]]M/*1024*1024/g')
	l3miss=$(echo $l3miss | sed -e 's/[[:space:]]G/*1024*1024*1024/g')
	l3miss=$(echo $l3miss | bc)

	l2miss=$(cat tmp.log | grep -i "TOTAL *" | head -1 | awk ' { print $9,$10 } ')
	l2miss=$(echo $l2miss | sed -e 's/[[:space:]]K/*1024/g')
	l2miss=$(echo $l2miss | sed -e 's/[[:space:]]M/*1024*1024/g')
	l2miss=$(echo $l2miss | sed -e 's/[[:space:]]G/*1024*1024*1024/g')
	l2miss=$(echo $l2miss | bc)

	l3hit=$(cat tmp.log | grep -i "TOTAL *" | head -1 | awk ' { print $11 } ')
	l2hit=$(cat tmp.log | grep -i "TOTAL *" | head -1 | awk ' { print $12 } ')

	echo "$timeAcc,$l3miss,$l2miss,$l3hit,$l2hit" >> Results.csv

	#sleep $timeOfCollet

	#timeAcc=$(echo "$timeAcc+$timeOfCollet" | bc)
	timeAcc=$(echo "$timeAcc+1" | bc);
	rm tmp.log
done
#+end_src

#+RESULTS:
#+begin_example
TimeStamp,L3miss,L2miss,L3hit,L2hit
0.0,46080,51200,0.10,0.13
1.0,1057792,10485760,0.90,0.01
2.0,833536,6281216,0.87,0.01
3.0,5718016,35651584,0.84,0.01
4.0,459776,2722816,0.83,0.01
5.0,4577280,27262976,0.83,0.00
6.0,4392960,26214400,0.83,0.01
7.0,189440,324608,0.42,0.21
8.0,6773760,34603008,0.80,0.00
9.0,1221632,6487040,0.81,0.01
10.0,6791168,34603008,0.80,0.00
11.0,5078016,27262976,0.81,0.00
12.0,6463488,34603008,0.81,0.00
13.0,1232896,6567936,0.81,0.00
14.0,7702528,37748736,0.79,0.01
15.0,7273472,33554432,0.78,0.00
16.0,59392,87040,0.32,0.29
17.0,143360,484352,0.70,0.17
18.0,1398784,7318528,0.81,0.03
19.0,625664,3027968,0.79,0.00
20.0,8224768,38797312,0.79,0.01
21.0,7543808,37748736,0.80,0.00
22.0,5612544,27262976,0.79,0.00
23.0,8998912,39845888,0.77,0.00
24.0,7250944,33554432,0.78,0.01
25.0,7941120,35651584,0.78,0.01
26.0,1517568,6606848,0.77,0.00
27.0,5953536,27262976,0.78,0.00
28.0,7496704,35651584,0.79,0.01
29.0,8685568,38797312,0.77,0.00
30.0,6930432,33554432,0.79,0.00
31.0,7645184,35651584,0.79,0.00
32.0,8279040,36700160,0.77,0.00
33.0,8115200,37748736,0.78,0.01
34.0,7917568,35651584,0.77,0.00
35.0,7739392,36700160,0.78,0.00
36.0,6269952,30408704,0.79,0.00
37.0,8169472,37748736,0.78,0.00
38.0,7809024,36700160,0.78,0.00
39.0,5847040,27262976,0.78,0.00
40.0,6980608,33554432,0.79,0.00
41.0,7785472,35651584,0.78,0.00
42.0,7525376,35651584,0.79,0.00
43.0,7630848,35651584,0.79,0.00
44.0,7728128,35651584,0.78,0.00
45.0,1514496,6580224,0.77,0.00
46.0,6475776,30408704,0.78,0.00
47.0,7690240,35651584,0.78,0.00
48.0,7632896,35651584,0.78,0.00
49.0,6664192,29360128,0.77,0.00
50.0,5654528,26214400,0.78,0.00
51.0,7553024,34603008,0.78,0.00
52.0,8286208,36700160,0.77,0.01
53.0,8539136,37748736,0.77,0.00
54.0,7943168,36700160,0.78,0.00
55.0,7463936,34603008,0.79,0.00
56.0,122880,507904,0.76,0.03
57.0,1378304,6400000,0.78,0.00
58.0,1399808,6425600,0.78,0.00
59.0,7431168,34603008,0.79,0.00
60.0,978944,4717568,0.79,0.00
61.0,8198144,37748736,0.78,0.01
62.0,7841792,37748736,0.79,0.00
63.0,1347584,6467584,0.79,0.00
64.0,5840896,27262976,0.78,0.01
65.0,6465536,31457280,0.79,0.00
66.0,1381376,6492160,0.79,0.00
67.0,1492992,6633472,0.77,0.00
68.0,1515520,6874112,0.78,0.00
69.0,1356800,6226944,0.78,0.00
70.0,8104960,37748736,0.78,0.00
71.0,2725888,11534336,0.78,0.00
72.0,6637568,30408704,0.78,0.00
73.0,5969920,26214400,0.77,0.00
74.0,2094080,9460736,0.78,0.05
75.0,7837696,36700160,0.79,0.00
76.0,7556096,35651584,0.79,0.00
77.0,7766016,35651584,0.78,0.01
78.0,1206272,5321728,0.77,0.00
79.0,8000512,34603008,0.76,0.02
80.0,7604224,35651584,0.78,0.01
81.0,8060928,36700160,0.78,0.00
82.0,1316864,6294528,0.79,0.00
83.0,7443456,36700160,0.79,0.00
84.0,4930560,22020096,0.77,0.00
85.0,7490560,36700160,0.79,0.00
86.0,1433600,6588416,0.78,0.00
87.0,7649280,37748736,0.79,0.00
88.0,2052096,9309184,0.78,0.00
89.0,7557120,34603008,0.78,0.00
90.0,7642112,39845888,0.80,0.00
91.0,6752256,32505856,0.79,0.00
92.0,7240704,35651584,0.79,0.00
93.0,8536064,42991616,0.80,0.00
94.0,490496,1898496,0.74,0.06
95.0,8374272,42991616,0.80,0.00
96.0,121856,559104,0.78,0.02
97.0,8514560,45088768,0.81,0.00
98.0,9328640,48234496,0.80,0.00
99.0,112640,582656,0.81,0.02
100.0,8974336,47185920,0.81,0.00
101.0,9147392,50331648,0.81,0.00
102.0,6796288,33554432,0.80,0.00
103.0,9434112,50331648,0.81,0.00
104.0,10485760,52428800,0.80,0.00
105.0,7735296,39845888,0.81,0.00
106.0,2095104,10121216,0.79,0.00
107.0,10485760,51380224,0.79,0.00
108.0,2019328,9956352,0.80,0.01
109.0,7443456,38797312,0.81,0.00
110.0,10485760,54525952,0.80,0.00
111.0,1870848,9511936,0.80,0.00
112.0,10485760,55574528,0.81,0.00
113.0,10485760,54525952,0.81,0.00
114.0,11534336,65011712,0.81,0.00
115.0,12582912,63963136,0.80,0.01
116.0,8701952,48234496,0.82,0.00
117.0,10038272,59768832,0.83,0.00
118.0,10485760,59768832,0.83,0.00
119.0,9673728,50331648,0.81,0.01
120.0,7840768,45088768,0.82,0.00
121.0,2877440,13631488,0.80,0.00
122.0,9346048,48234496,0.80,0.00
123.0,167936,839680,0.80,0.02
124.0,173056,975872,0.82,0.02
125.0,8958976,51380224,0.82,0.00
126.0,8354816,50331648,0.83,0.00
127.0,1104896,6454272,0.83,0.00
128.0,11264,18432,0.34,0.23

#+end_example

- Análise dos resultados:

#+begin_src R :results output graphics :file "imagens/l3missgraph_exp1.png" :exports both :width 800 :height 600 :session *R* 
df <- read.csv("dados/exp1_manualPCM.csv");

library(ggplot2);
ggplot(df, aes(x=TimeStamp,y=L3miss)) +
geom_line(color='blue');
#+end_src

#+RESULTS:
[[file:imagens/l3missgraph_exp1.png]]


#+begin_src R :results output graphics :file "imagens/l2missgraph_exp1.png" :exports both :width 800 :height 600 :session *R* 
df <- read.csv("dados/exp1_manualPCM.csv");

library(ggplot2);
ggplot(df, aes(x=TimeStamp,y=L2miss)) +
geom_line(color='red');
#+end_src

#+RESULTS:
[[file:imagens/l2missgraph_exp1.png]]

- Vou pesquisar uma forma de gerar no mesmo gráfico todos os dados do
  =.csv= 

* STARTED [21:21:52; 11.08.2016] Experimentando a ferramenta =likwid= :Gabriel:
- State "STARTED"    from              [2016-08-12 Sex 16:07]
- Instalando a ferramenta na =beagle1=

#+begin_src sh :results output :exports both
cd $HOME/Programs/
git clone https://github.com/RRZE-HPC/likwid.git
cd likwid
make
sudo make install
#+end_src

#+RESULTS:

- Testando o seu recurso de medição =full node=:

#+begin_src sh :results output :exports both
sudo likwid-perfctr -f -c N:0-31 -g MEM ./tiling_par 100 > ../../dados/outOfLikwid_exp1.txt
#+end_src 

#+begin_src sh :results output :exports both
cd dados/
cat outOfLikwid_exp1.txt
#+end_src

#+RESULTS:
#+begin_example
--------------------------------------------------------------------------------
CPU name:	Intel(R) Xeon(R) CPU E5-2650 0 @ 2.00GHz
CPU type:	Intel Xeon SandyBridge EN/EP processor
CPU clock:	2.00 GHz
--------------------------------------------------------------------------------
HPCELO:0.075840
--------------------------------------------------------------------------------
Group 1: MEM
+-----------------------+---------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+---------+-----------+----------+----------+-----------+----------+-----------+-----------+-----------+----------+----------+----------+-----------+
|         Event         | Counter |   Core 0  |   Core 2  |   Core 4  |   Core 6  |   Core 8  |  Core 10  |  Core 12  |  Core 14  |   Core 1  |   Core 3  |   Core 5  |   Core 7  |   Core 9  |  Core 11  |  Core 13  |  Core 15  |  Core 16  |  Core 18  |  Core 20  | Core 22 |  Core 24  |  Core 26 |  Core 28 |  Core 30  |  Core 17 |  Core 19  |  Core 21  |  Core 23  |  Core 25 |  Core 27 |  Core 29 |  Core 31  |
+-----------------------+---------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+---------+-----------+----------+----------+-----------+----------+-----------+-----------+-----------+----------+----------+----------+-----------+
|   INSTR_RETIRED_ANY   |  FIXC0  |  48374458 |  45352262 |  36603520 |  41002247 |  36810725 |  38621003 |  37999593 |  39003498 |  50476207 |  35306169 |  37374151 |  36669360 |  35951123 |  37092138 |  36058105 |  35282321 |  34828385 |  47770845 |  48482726 |  124634 |  33572988 | 13443606 | 13199540 |  37346267 | 14746667 |  42418624 |  51831212 |  35226940 | 14775707 | 13433452 | 26212555 |  33148044 |
| CPU_CLK_UNHALTED_CORE |  FIXC1  | 167198929 | 163088008 | 131974702 | 118476831 | 129738287 | 121648201 | 120054153 | 138735328 | 158162029 | 126651687 | 135462851 | 132224211 | 116138645 | 115708107 | 121735191 | 126890935 | 128065707 | 169991275 | 166806068 |  941625 | 119189618 | 49059442 | 48697186 | 132159474 | 55340498 | 147496129 | 176997990 | 128285818 | 55329326 | 49087123 | 94191829 | 120429844 |
|  CPU_CLK_UNHALTED_REF |  FIXC2  | 138774100 | 135281160 | 109781300 |  98536960 | 108096520 | 101341080 | 100032120 | 115362600 | 131797460 | 105543140 | 112864920 | 110181080 |  96776680 |  96416600 | 101428560 | 105733160 | 106671300 | 141188020 | 138622220 |  784680 |  99307180 | 40874440 | 40578960 | 110079020 | 46112880 | 122904360 | 147476480 | 106888900 | 46104360 | 40901700 | 78488300 | 100351520 |
|      CAS_COUNT_RD     | MBOX0C0 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_WR     | MBOX0C1 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_RD     | MBOX1C0 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_WR     | MBOX1C1 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_RD     | MBOX2C0 |   90067   |     0     |     0     |     0     |     0     |     0     |     0     |     0     |   28899   |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_WR     | MBOX2C1 |   47797   |     0     |     0     |     0     |     0     |     0     |     0     |     0     |   17154   |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_RD     | MBOX3C0 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
|      CAS_COUNT_WR     | MBOX3C1 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |    0    |     0     |     0    |     0    |     0     |     0    |     0     |     0     |     0     |     0    |     0    |     0    |     0     |
+-----------------------+---------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+---------+-----------+----------+----------+-----------+----------+-----------+-----------+-----------+----------+----------+----------+-----------+

+----------------------------+---------+------------+--------+-----------+--------------+
|            Event           | Counter |     Sum    |   Min  |    Max    |      Avg     |
+----------------------------+---------+------------+--------+-----------+--------------+
|   INSTR_RETIRED_ANY STAT   |  FIXC0  | 1088539072 | 124634 |  51831212 |   34016846   |
| CPU_CLK_UNHALTED_CORE STAT |  FIXC1  | 3765957047 | 941625 | 176997990 | 1.176862e+08 |
|  CPU_CLK_UNHALTED_REF STAT |  FIXC2  | 3135281760 | 784680 | 147476480 |   97977555   |
|      CAS_COUNT_RD STAT     | MBOX0C0 |      0     |    0   |     0     |       0      |
|      CAS_COUNT_WR STAT     | MBOX0C1 |      0     |    0   |     0     |       0      |
|      CAS_COUNT_RD STAT     | MBOX1C0 |      0     |    0   |     0     |       0      |
|      CAS_COUNT_WR STAT     | MBOX1C1 |      0     |    0   |     0     |       0      |
|      CAS_COUNT_RD STAT     | MBOX2C0 |   118966   |    0   |   90067   |   3717.6875  |
|      CAS_COUNT_WR STAT     | MBOX2C1 |    64951   |    0   |   47797   |   2029.7188  |
|      CAS_COUNT_RD STAT     | MBOX3C0 |      0     |    0   |     0     |       0      |
|      CAS_COUNT_WR STAT     | MBOX3C1 |      0     |    0   |     0     |       0      |
+----------------------------+---------+------------+--------+-----------+--------------+

+-----------------------------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+
|               Metric              |   Core 0  |   Core 2  |   Core 4  |   Core 6  |   Core 8  |  Core 10  |  Core 12  |  Core 14  |   Core 1  |   Core 3  |   Core 5  |   Core 7  |   Core 9  |  Core 11  |  Core 13  |  Core 15  |  Core 16  |  Core 18  |  Core 20  |  Core 22  |  Core 24  |  Core 26  |  Core 28  |  Core 30  |  Core 17  |  Core 19  |  Core 21  |  Core 23  |  Core 25  |  Core 27  |  Core 29  |  Core 31  |
+-----------------------------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+
|        Runtime (RDTSC) [s]        |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |   0.0789  |
|        Runtime unhalted [s]       |   0.0836  |   0.0815  |   0.0660  |   0.0592  |   0.0649  |   0.0608  |   0.0600  |   0.0694  |   0.0791  |   0.0633  |   0.0677  |   0.0661  |   0.0581  |   0.0579  |   0.0609  |   0.0634  |   0.0640  |   0.0850  |   0.0834  |   0.0005  |   0.0596  |   0.0245  |   0.0243  |   0.0661  |   0.0277  |   0.0738  |   0.0885  |   0.0641  |   0.0277  |   0.0245  |   0.0471  |   0.0602  |
|            Clock [MHz]            | 2409.5581 | 2410.9991 | 2404.2225 | 2404.6208 | 2400.3180 | 2400.6702 | 2400.2145 | 2405.1068 | 2399.9795 | 2399.9009 | 2400.3445 | 2400.0279 | 2400.0394 | 2400.0722 | 2400.3149 | 2400.1132 | 2401.0301 | 2407.9148 | 2406.5303 | 2399.9254 | 2400.3254 | 2400.3973 | 2400.0224 | 2401.0770 | 2400.1211 | 2400.0797 | 2400.2579 | 2400.2605 | 2400.0800 | 2400.1510 | 2400.0520 | 2400.0623 |
|                CPI                |   3.4563  |   3.5960  |   3.6055  |   2.8895  |   3.5245  |   3.1498  |   3.1594  |   3.5570  |   3.1334  |   3.5872  |   3.6245  |   3.6058  |   3.2305  |   3.1195  |   3.3761  |   3.5964  |   3.6770  |   3.5585  |   3.4405  |   7.5551  |   3.5502  |   3.6493  |   3.6893  |   3.5388  |   3.7527  |   3.4772  |   3.4149  |   3.6417  |   3.7446  |   3.6541  |   3.5934  |   3.6331  |
|  Memory read bandwidth [MBytes/s] |  73.0360  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |  23.4344  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |
|  Memory read data volume [GBytes] |   0.0058  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |   0.0018  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |
| Memory write bandwidth [MBytes/s] |  38.7589  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |  13.9103  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |
| Memory write data volume [GBytes] |   0.0031  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |   0.0011  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |
|    Memory bandwidth [MBytes/s]    |  111.7949 |     0     |     0     |     0     |     0     |     0     |     0     |     0     |  37.3447  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |
|    Memory data volume [GBytes]    |   0.0088  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |   0.0029  |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |     0     |
+-----------------------------------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+

+----------------------------------------+------------+-----------+-----------+-----------+
|                 Metric                 |     Sum    |    Min    |    Max    |    Avg    |
+----------------------------------------+------------+-----------+-----------+-----------+
|        Runtime (RDTSC) [s] STAT        |   2.5248   |   0.0789  |   0.0789  |   0.0789  |
|        Runtime unhalted [s] STAT       |   1.8829   |   0.0005  |   0.0885  |   0.0588  |
|            Clock [MHz] STAT            | 76854.7897 | 2399.9009 | 2410.9991 | 2401.7122 |
|                CPI STAT                |  115.7818  |   2.8895  |   7.5551  |   3.6182  |
|  Memory read bandwidth [MBytes/s] STAT |   96.4704  |     0     |  73.0360  |   3.0147  |
|  Memory read data volume [GBytes] STAT |   0.0076   |     0     |   0.0058  |   0.0002  |
| Memory write bandwidth [MBytes/s] STAT |   52.6692  |     0     |  38.7589  |   1.6459  |
| Memory write data volume [GBytes] STAT |   0.0042   |     0     |   0.0031  |   0.0001  |
|    Memory bandwidth [MBytes/s] STAT    |  149.1396  |     0     |  111.7949 |   4.6606  |
|    Memory data volume [GBytes] STAT    |   0.0117   |     0     |   0.0088  |   0.0004  |
+----------------------------------------+------------+-----------+-----------+-----------+

#+end_example

- Pelo que eu percebi de acordo com esses resultados é que a
  ferramenta possui um funcionamento parecido com perf, oferecendo a
  somatória total dos eventos, não funcionando como uma ferramenta
  monitora coletando diferentes valores a cada =time stamp=. Posso estar
  errado, por isso vou continuar investigando seus recursos.

- O caminho se utilizarmos essa ferramenta é usar algo parecido com
  esse comando:

#+begin_example
sudo likwid-perfctr -t 20ms -f -c N:0-31 -g L2 -g L3 -g MEM ./tiling_par 1500 >> saida1.csv 2>> saida2.csv 
#+end_example


- A apartir do parâmetro =t= é possível definir a frequência em que será
  realizado a coleta dos contadores de hardware, os quais são
  respectivos para o grupo informado no parâmetro =g=. O grupo =MEM=
  disponibiliza uma série de eventos para compreender o comportamento
  da memória, existem outros grupos de evento, como =L2CACHE= (todos
  eventos na l2).

- Agora vou tentar compreender quais eventos posso utilizar no trace,
  porque preciso retirar eventos que necessito para minha análise.

#+begin_src sh :results output :exports both
sudo likwid-perfctr -e | grep -i cache
#+end_src

#+RESULTS:
#+begin_example
L3_LAT_CACHE_REFERENCE, 0x2E, 0x4F, PMC
L3_LAT_CACHE_MISS, 0x2E, 0x41, PMC
CACHE_LOCK_CYCLES_SPLIT_LOCK_UC_LOCK_DURATION, 0x63, 0x1, PMC
CACHE_LOCK_CYCLES_CACHE_LOCK_DURATION, 0x63, 0x2, PMC
ICACHE_HITS, 0x80, 0x1, PMC
ICACHE_MISSES, 0x80, 0x2, PMC
ICACHE_ACCESSES, 0x80, 0x3, PMC
ICACHE_IFETCH_STALL, 0x80, 0x4, PMC
TXT_INSERTS_AD_CACHE, 0x2, 0x1, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
TXT_INSERTS_AK_CACHE, 0x2, 0x2, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
TXT_INSERTS_BL_CACHE, 0x2, 0x4, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
TXT_INSERTS_IV_CACHE, 0x2, 0x8, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
TXR_BL_DRS_CACHE, 0x10, 0x1, BBOX
#+end_example

#+begin_src sh :results output :exports both
sudo likwid-perfctr -e | grep -i HIT
#+end_src

#+RESULTS:
#+begin_example
This architecture has 97 counters.
This architecture has 727 events.
L2_RQSTS_ALL_DEM_AND_DATA_RD_HIT, 0x24, 0x1, PMC
L2_RQSTS_RFO_HITS, 0x24, 0x4, PMC
L2_RQSTS_CODE_RD_HITS, 0x24, 0x10, PMC
L2_RQSTS_PF_HIT, 0x24, 0x40, PMC
L2_STORE_LOCK_RQSTS_HIT_E, 0x27, 0x4, PMC
L2_STORE_LOCK_RQSTS_HIT_M, 0x27, 0x8, PMC
L1D_WB_RQST_HIT_E, 0x28, 0x4, PMC
L1D_WB_RQST_HIT_M, 0x28, 0x8, PMC
DTLB_STORE_MISSES_STLB_HIT, 0x49, 0x10, PMC
LOAD_HIT_PRE_SW_PF, 0x4C, 0x1, PMC
LOAD_HIT_PRE_HW_PF, 0x4C, 0x2, PMC
ICACHE_HITS, 0x80, 0x1, PMC
ITLB_MISSES_STLB_HIT, 0x85, 0x10, PMC
MEM_LOAD_UOPS_RETIRED_L1_HIT, 0xD1, 0x1, PMC
MEM_LOAD_UOPS_RETIRED_L2_HIT, 0xD1, 0x2, PMC
MEM_LOAD_UOPS_RETIRED_L3_HIT, 0xD1, 0x4, PMC
MEM_LOAD_UOPS_RETIRED_HIT_LFB, 0xD1, 0x40, PMC
MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_MISS, 0xD2, 0x1, PMC
MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_HIT, 0xD2, 0x2, PMC
MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_HITM, 0xD2, 0x4, PMC
MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_NONE, 0xD2, 0x8, PMC
CBOX_MISC_RFO_HIT_S, 0x39, 0x8, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
WPQ_READ_HIT, 0x23, 0x0, MBOX
WPQ_WRITE_HIT, 0x24, 0x0, MBOX
#+end_example


#+begin_src sh :results output :exports both
sudo likwid-perfctr -e | grep -i miss
#+end_src

#+RESULTS:
#+begin_example
DTLB_LOAD_MISSES_CAUSES_A_WALK, 0x8, 0x1, PMC
DTLB_LOAD_MISSES_WALK_COMPLETED, 0x8, 0x2, PMC
DTLB_LOAD_MISSES_WALK_DURATION, 0x8, 0x4, PMC
L2_RQSTS_ALL_DEM_AND_DATA_RD_MISS, 0x24, 0x2, PMC
L2_RQSTS_RFO_MISS, 0x24, 0x8, PMC
L2_RQSTS_CODE_RD_MISS, 0x24, 0x20, PMC
L2_RQSTS_PF_MISS, 0x24, 0x80, PMC
L2_RQSTS_MISS, 0x24, 0xAA, PMC
L2_STORE_LOCK_RQSTS_MISS, 0x27, 0x1, PMC
L3_LAT_CACHE_MISS, 0x2E, 0x41, PMC
L1D_PEND_MISS_PENDING, 0x48, 0x1, PMC1
DTLB_STORE_MISSES_CAUSES_A_WALK, 0x49, 0x1, PMC
DTLB_STORE_MISSES_WALK_COMPLETED, 0x49, 0x2, PMC
DTLB_STORE_MISSES_WALK_DURATION, 0x49, 0x4, PMC
DTLB_STORE_MISSES_STLB_HIT, 0x49, 0x10, PMC
HW_PRE_REQ_DL1_MISS, 0x4E, 0x2, PMC
ICACHE_MISSES, 0x80, 0x2, PMC
ITLB_MISSES_CAUSES_A_WALK, 0x85, 0x1, PMC
ITLB_MISSES_WALK_COMPLETED, 0x85, 0x2, PMC
ITLB_MISSES_WALK_DURATION, 0x85, 0x4, PMC
ITLB_MISSES_STLB_HIT, 0x85, 0x10, PMC
OTHER_ASSISTS_ITLB_MISS_RETIRED, 0xC1, 0x2, PMC
MEM_UOPS_RETIRED_LOADS_STLB_MISS, 0xD0, 0x11, PMC
MEM_UOPS_RETIRED_STORES_STLB_MISS, 0xD0, 0x12, PMC
MEM_LOAD_UOPS_RETIRED_L1_MISS, 0xD1, 0x8, PMC
MEM_LOAD_UOPS_RETIRED_L2_MISS, 0xD1, 0x10, PMC
MEM_LOAD_UOPS_RETIRED_L3_MISS, 0xD1, 0x20, PMC
MEM_LOAD_UOPS_LLC_HIT_RETIRED_XSNP_MISS, 0xD2, 0x1, PMC
MEM_LOAD_UOPS_MISC_RETIRED_LLC_MISS, 0xD4, 0x2, PMC
ISMQ_DRD_MISS_OCC, 0x21, 0x0, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
LLC_VICTIMS_MISS, 0x37, 0x8, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
LLC_VICTIMS_NID_MISSES, 0x37, 0x41, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1, NID|
TOR_INSERTS_MISS_OPCODE, 0x35, 0x3, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1, OPCODE|
TOR_INSERTS_MISS_ALL, 0x35, 0xA, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
TOR_INSERTS_NID_MISS_OPCODE, 0x35, 0x43, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1, OPCODE|NID|
TOR_INSERTS_NID_MISS_ALL, 0x35, 0x4A, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0|CBOX0C1|CBOX1C1|CBOX2C1|CBOX3C1|CBOX4C1|CBOX5C1|CBOX6C1|CBOX7C1
TOR_OCCUPANCY_MISS_OPCODE, 0x36, 0x3, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0, OPCODE|
TOR_OCCUPANCY_MISS_ALL, 0x36, 0xA, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0
TOR_OCCUPANCY_NID_MISS_OPCODE, 0x36, 0x43, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0, OPCODE|NID|
TOR_OCCUPANCY_NID_MISS_ALL, 0x36, 0x4A, CBOX0C0|CBOX1C0|CBOX2C0|CBOX3C0|CBOX4C0|CBOX5C0|CBOX6C0|CBOX7C0, NID|
PRE_COUNT_PAGE_MISS, 0x2, 0x1, MBOX
#+end_example

- Um dos problemas é que não achei uma maneira de usa um evento
  individual com a ferramenta, só dar pra usar um ou mais grupos
  específicos de eventos. Por exemplo para o grupo L2, temos cerca de:

#+begin_src sh :results output :exports both
sudo likwid-perfctr -E L2 | wc -l
#+end_src

#+RESULTS:
#+begin_example
46
#+end_example

- Se executamos uma aplicação qualquer coletando os eventos do grupo
  L2, chegaremos no seguinte resultado para a primeira linha do
  trace, teremos o número de colunas igual a:

#+begin_src sh :results output :exports both
sudo likwid-perfctr -t 20ms -f -c N:0-31 -g L2 ./tiling_par 1500 >> saida1.csv 2>> saida2.csv 
#contando quantas colunas a primeira linha da tabela gerada possui
cat saida2.csv | head -3 | grep -i 1[[:space:]]10 | 
sed 's/[[:space:]]/_/g' | grep -o "_" | wc -l
#+end_src

#+RESULTS:
#+begin_example
320
#+end_example

- O que pode estar ocorrendo é que para cada core foram realizadas =10
  medidas= nesse time stamp, as quais pertencem ao grupo L2. O grupo L2
  disponibiliza cerca de 45 events.

#+begin_src sh :results output :exports both
sudo likwid-perfctr -E L2 | head -1
#+end_src

#+RESULTS:
#+begin_example
Found 45 event(s) with search key L2:
#+end_example

- O tempo total de execução da aplicação foi aproximadamente de 2 segundos e o tempo
  de cada amostragem foi realizado de acordo com o intervalo de 20ms
  (o que representa 0,02 segundos), corresponderia a =100 medidas= e
  pelos valores apresentarem o mesmo tipo, essa alternativa também
  não explica rastro gerado.

#+begin_src sh :results output :exports both
cat saida2.csv | head -4
#+end_src

#+RESULTS:
#+begin_example
# CORES: 0|2|4|6|8|10|12|14|1|3|5|7|9|11|13|15|16|18|20|22|24|26|28|30|17|19|21|23|25|27|29|31
1 10 32 0.020565900340284 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 6.4515176738843e-05 0.0 0.0001469359025298 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.011959422262748 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.1932560084084e-05 0.0 0.0 0.0 0.0 0.0 0.0 2399.212467893 0.0 2397.7659509024 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2400.0290461965 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2400.9239098063 0.0 0.0 0.0 0.0 0.0 0.0 5.7336473515819 0.0 4.1062934913227 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.58535669192174 0.0 0.0 0.0 0.0 0.0 0.0 0.0 19.920526793824 0.0 0.0 0.0 0.0 0.0 0.0 3.404802846571 0.0 8.8820943823592 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 267.84449059692 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.28990169164644 0.0 0.0 0.0 0.0 0.0 0.0 7.0656e-05 0.0 0.00018432 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.005558272 0.0 0.0 0.0 0.0 0.0 0.0 0.0 6.016e-06 0.0 0.0 0.0 0.0 0.0 0.0 0.83886446944503 0.0 1.6623086361429 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 231.35080211551 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.086353695384047 0.0 0.0 0.0 0.0 0.0 0.0 1.7408e-05 0.0 3.4496e-05 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.00480096 0.0 0.0 0.0 0.0 0.0 0.0 0.0 1.792e-06 0.0 0.0 0.0 0.0 0.0 0.0 13.779582534854 0.0 29.977068540462 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 512.12059047509 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.99306749691655 0.0 0.0 0.0 0.0 0.0 0.0 0.000285952 0.0 0.00062208 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.010627456 0.0 0.0 0.0 0.0 0.0 0.0 0.0 2.0608e-05 0.0 0.0 0.0 0.0 0.0 0.0
1 10 32 0.052882378871277 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.010691572789483 0.0020462021055553 0.018534346274703 0.016790309496927 0.0087798075522169 0.0089623325522428 0.0012850935205041 0.0014472769648044 0.017818854314618 0.018055624963249 0.018252697503128 0.018400905909144 0.013262310332 0.013484195939854 0.013694852516946 0.013936062677739 0.0 0.030057526842369 0.0 0.0 0.0 0.0 0.0 0.0002432716664409 0.0 0.024131956109313 0.013494352467677 0.013751853173099 0.013994558837989 0.014225544470772 0.014449581084519 0.01465725865345 2399.9798445053 2399.9987033006 2399.9850731856 2399.9944972654 2399.9921951233 2399.9966386715 2399.9896900871 2399.9950835058 2399.997398544 2399.9907003085 2399.9949373242 2399.9928382905 2399.9879963119 2399.9932472319 2399.9946519569 2399.9942001861 0.0 2399.9762183369 0.0 0.0 0.0 0.0 0.0 2401.3655156302 0.0 2399.9920328742 2399.99618193 2399.9947341332 2399.9935109656 2399.9930034416 2399.9963318802 2399.9951445039 1.8530922327127 6.9445810488161 0.74169923571061 2.1212525705097 1.6547947919044 1.6414444434473 1.8235766987343 2.6656689944661 2.3406562999204 4.9804609682778 4.3610016472638 4.3927487445439 5.4649123981763 5.4263224643841 5.4851839954628 5.5035852619806 0.0 1.3760982767871 0.0 0.0 0.0 0.0 0.0 4.8004222822977 0.0 4.8483234512698 6.8474819194727 6.6684602860755 6.8964428757107 6.8182144102454 6.9271475857645 6.9372478795018 3910.9793322531 249.80878251538 4155.6510456273 4176.3294882079 4271.9723346873 4352.5361215074 562.57078760839 459.78900843437 3919.7565613537 1113.3750162358 1160.3829018767 1185.731611335 1189.4413427856 1260.1686184454 1237.5893031856 1245.9378821307 0.0 3833.6046128203 0.0 0.0 0.0 0.0 0.0 27.435854194559 0.0 1513.947464443 1541.2239774803 1673.1113266379 1582.7424480406 1597.877613741 1590.1821091166 1608.5018537211 0.111531072 0.007123904 0.11850848 0.119098176 0.121825664 0.124123136 0.016043072 0.013112 0.111781376 0.031750592 0.033091136 0.033814016 0.033919808 0.035936768 0.035292864 0.035530944 0.0 0.109324544 0.0 0.0 0.0 0.0 0.0 0.0007824 0.0 0.043173888 0.043951744 0.047712832 0.045135744 0.04556736 0.045347904 0.045870336 11.97078497127 0.64858583740102 36.222060261773 12.161545511682 12.379236951917 12.596928392152 1.8492551211711 29.794552170713 11.526425124193 3.6087405762659 5.2739678819806 4.4772620955538 3.7209526588612 4.5311238951995 4.111450706293 4.2461052054074 0.0 130.16601581059 0.0 0.0 0.0 0.0 0.0 2.2823937599891 0.0 5.4175993477026 4.591718419801 5.8619591947802 5.5477653635132 5.1550230744296 5.8148301200901 5.5836732299437 0.000341376 1.8496e-05 0.00103296 0.000346816 0.000353024 0.000359232 5.2736e-05 0.000849664 0.000328704 0.000102912 0.0001504 0.00012768 0.000106112 0.000129216 0.000117248 0.000121088 0.0 0.003712 0.0 0.0 0.0 0.0 0.0 6.5088e-05 0.0 0.000154496 0.000130944 0.000167168 0.000158208 0.000147008 0.000165824 0.000159232 3932.5218078698 250.51123015243 4425.8285653754 4188.8860202504 4284.4368528219 4365.2632159154 565.1135134 489.90448716131 3931.778963883 1117.300194885 1166.1730453386 1190.5544866449 1193.3642771931 1264.8994798476 1241.8960029156 1250.3882133264 0.0 3971.3628981393 0.0 0.0 0.0 0.0 0.0 43.863703086515 0.0 1520.0248708364 1545.8448710416 1679.0877421569 1588.3149000622 1603.0573234736 1596.0373355864 1614.1236790592 0.112145408 0.007143936 0.126213248 0.119456256 0.12218112 0.12448608 0.016115584 0.013970816 0.112124224 0.031862528 0.033256256 0.033951552 0.03403168 0.03607168 0.03541568 0.035657856 0.0 0.113253056 0.0 0.0 0.0 0.0 0.0 0.00125088 0.0 0.0433472 0.04408352 0.047883264 0.045294656 0.045715072 0.04551488 0.04
#+end_example


- Na minha visão, as medidas atribuídas ao =core 0=
  são:

#+begin_src sh :results output :exports both
cat saida2.csv | awk ' { print $1,$2,$3,$4,$5,$6,$7,$8, $9, $10 } '
#+end_src

#+RESULTS:
#+begin_example
# CORES: 0|2|4|6|8|10|12|14|1|3|5|7|9|11|13|15|16|18|20|22|24|26|28|30|17|19|21|23|25|27|29|31              

1 10 32 0.020565900340284 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727 0.020751862349727
1 10 32 0.052882378871277 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494 0.028517428123494
1 10 32 0.09635633496818 0.037663742679823 0.037663742679823 0.037663742679823 0.037663742679823 0.037663742679823 0.037663742679823
1 10 32 0.14175093632669 0.038175362581406 0.038175362581406 0.038175362581406 0.038175362581406 0.038175362581406 0.038175362581406
1 10 32 0.19055983303866 0.037408529480667 0.037408529480667 0.037408529480667 0.037408529480667 0.037408529480667 0.037408529480667
1 10 32 0.23373419581483 0.035995958110927 0.035995958110927 0.035995958110927 0.035995958110927 0.035995958110927 0.035995958110927
1 10 32 0.2707095811089 0.031250161109816 0.031250161109816 0.031250161109816 0.031250161109816 0.031250161109816 0.031250161109816
1 10 32 0.30574692159369 0.030901274154041 0.030901274154041 0.030901274154041 0.030901274154041 0.030901274154041 0.030901274154041
1 10 32 0.34345025038196 0.034008777167045 0.034008777167045 0.034008777167045 0.034008777167045 0.034008777167045 0.034008777167045
1 10 32 0.38945874792224 0.038910133594311 0.038910133594311 0.038910133594311 0.038910133594311 0.038910133594311 0.038910133594311
1 10 32 0.45076335586621 0.054312018287774 0.054312018287774 0.054312018287774 0.054312018287774 0.054312018287774 0.054312018287774
1 10 32 0.50110384527398 0.043193507828615 0.043193507828615 0.043193507828615 0.043193507828615 0.043193507828615 0.043193507828615
1 10 32 0.54653061972063 0.038292795903114 0.038292795903114 0.038292795903114 0.038292795903114 0.038292795903114 0.038292795903114
1 10 32 0.58794866868538 0.034191524667682 0.034191524667682 0.034191524667682 0.034191524667682 0.034191524667682 0.034191524667682
1 10 32 0.62532758108491 0.031971041584668 0.031971041584668 0.031971041584668 0.031971041584668 0.031971041584668 0.031971041584668
1 10 32 0.69713587080372 0.054595953565615 0.054595953565615 0.054595953565615 0.054595953565615 0.054595953565615 0.054595953565615
1 10 32 0.75864096929694 0.054518049352196 0.054518049352196 0.054518049352196 0.054518049352196 0.054518049352196 0.054518049352196
1 10 32 0.81967775350721 0.053879670103356 0.053879670103356 0.053879670103356 0.053879670103356 0.053879670103356 0.053879670103356
1 10 32 0.86361384387013 0.038013580638204 0.038013580638204 0.038013580638204 0.038013580638204 0.038013580638204 0.038013580638204
1 10 32 0.90010770384505 0.032637677910919 0.032637677910919 0.032637677910919 0.032637677910919 0.032637677910919 0.032637677910919
1 10 32 0.96178581031223 0.054615402118894 0.054615402118894 0.054615402118894 0.054615402118894 0.054615402118894 0.054615402118894
1 10 32 1.0234256361745 0.054492634782573 0.054492634782573 0.054492634782573 0.054492634782573 0.054492634782573 0.054492634782573
1 10 32 1.068888123719 0.038391344673089 0.038391344673089 0.038391344673089 0.038391344673089 0.038391344673089 0.038391344673089
1 10 32 1.114830458078 0.038656629899838 0.038656629899838 0.038656629899838 0.038656629899838 0.038656629899838 0.038656629899838
1 10 32 1.1528937623525 0.0314080670424 0.0314080670424 0.0314080670424 0.0314080670424 0.0314080670424 0.0314080670424
1 10 32 1.1882726477729 0.031378069960223 0.031378069960223 0.031378069960223 0.031378069960223 0.031378069960223 0.031378069960223
1 10 32 1.2501763858582 0.054638963683441 0.054638963683441 0.054638963683441 0.054638963683441 0.054638963683441 0.054638963683441
1 10 32 1.3122447273944 0.054866458306663 0.054866458306663 0.054866458306663 0.054866458306663 0.054866458306663 0.054866458306663
1 10 32 1.374278135835 0.054689566322067 0.054689566322067 0.054689566322067 0.054689566322067 0.054689566322067 0.054689566322067
1 10 32 1.4203290264914 0.038867854478487 0.038867854478487 0.038867854478487 0.038867854478487 0.038867854478487 0.038867854478487
1 10 32 1.4630186349396 0.035465177156853 0.035465177156853 0.035465177156853 0.035465177156853 0.035465177156853 0.035465177156853
1 10 32 1.5008432540601 0.034009647169428 0.034009647169428 0.034009647169428 0.034009647169428 0.034009647169428 0.034009647169428
1 10 32 1.54686985015 0.038571888167688 0.038571888167688 0.038571888167688 0.038571888167688 0.038571888167688 0.038571888167688
1 10 32 1.5906067714673 0.038611618276528 0.038611618276528 0.038611618276528 0.038611618276528 0.038611618276528 0.038611618276528
1 10 32 1.6511031856972 0.055176146655054 0.055176146655054 0.055176146655054 0.055176146655054 0.055176146655054 0.055176146655054
1 10 32 1.6933346513903 0.036808871837904 0.036808871837904 0.036808871837904 0.036808871837904 0.036808871837904 0.036808871837904
1 10 32 1.7293196254711 0.031210933502352 0.031210933502352 0.031210933502352 0.031210933502352 0.031210933502352 0.031210933502352
1 10 32 1.7643075513205 0.03045094742037 0.03045094742037 0.03045094742037 0.03045094742037 0.03045094742037 0.03045094742037
1 10 32 1.824618709543 0.054997413165413 0.054997413165413 0.054997413165413 0.054997413165413 0.054997413165413 0.054997413165413
1 10 32 1.8849542533322 0.054928345976204 0.054928345976204 0.054928345976204 0.054928345976204 0.054928345976204 0.054928345976204
1 10 32 1.945161144269 0.054922520460245 0.054922520460245 0.054922520460245 0.054922520460245 0.054922520460245 0.054922520460245
1 10 32 1.9889136441289 0.038486636434141 0.038486636434141 0.038486636434141 0.038486636434141 0.038486636434141 0.038486636434141
1 10 32 2.0305064550724 0.036600271766445 0.036600271766445 0.036600271766445 0.036600271766445 0.036600271766445 0.036600271766445
1 10 32 2.0688733331785 0.033605387561959 0.033605387561959 0.033605387561959 0.033605387561959 0.033605387561959 0.033605387561959
1 10 32 2.1128902892629 0.038715660061551 0.038715660061551 0.038715660061551 0.038715660061551 0.038715660061551 0.038715660061551
1 10 32 2.1727482732439 0.054482756255511 0.054482756255511 0.054482756255511 0.054482756255511 0.054482756255511 0.054482756255511
1 10 32 2.2246024697985 0.046505758902527 0.046505758902527 0.046505758902527 0.046505758902527 0.046505758902527 0.046505758902527
1 10 32 2.2703944237455 0.038628239822063 0.038628239822063 0.038628239822063 0.038628239822063 0.038628239822063 0.038628239822063
1 10 32 2.3078289247973 0.033431525585664 0.033431525585664 0.033431525585664 0.033431525585664 0.033431525585664 0.033431525585664
1 10 32 2.3536088117113 0.038578614186114 0.038578614186114 0.038578614186114 0.038578614186114 0.038578614186114 0.038578614186114
1 10 32 2.4153674908992 0.054461493197261 0.054461493197261 0.054461493197261 0.054461493197261 0.054461493197261 0.054461493197261
1 10 32 2.4596523962177 0.037190238882659 0.037190238882659 0.037190238882659 0.037190238882659 0.037190238882659 0.037190238882659
1 10 32 2.50484396302 0.038172488573532 0.038172488573532 0.038172488573532 0.038172488573532 0.038172488573532 0.038172488573532
1 10 32 2.5401693267939 0.031285784207406 0.031285784207406 0.031285784207406 0.031285784207406 0.031285784207406 0.031285784207406
#+end_example


- E para calcular a quantidade de amostras obtidas nessa execução,
  basta analisar a quantidade de linhas do rastro.

#+begin_src sh :results output :exports both
cat saida2.csv | awk ' { print $1,$2,$3,$4,$5,$6,$7,$8, $9, $10 } ' | wc -l
#+end_src

#+RESULTS:
#+begin_example
56
#+end_example

- Mas ainda não tenho certeza se estou interpretando da maneira
  correta esses dados. Vou pesquisar a fundo para ver se compreendo
  melhor, para poder quem sabe utilizar no trabalho. A única certeza
  que tenho, é que essa ferramenta é capaz de obter valores de
  hardware counters em determinados time stamps com intervalo definido
  em sua chamada.

- Minha nova hipótese é compreender o rastro executado sem a flag =-t=,
  o qual vai dar os valores gerais da aplicação. Para facilitar vou
  usar apenas 3 cores da máquina com a flag =g= L2CACHE.

#+begin_src sh :results output :exports both
sudo likwid-perfctr -f -c N:0-2 -g L2CACHE ./tiling_par 1000
#+end_src

#+RESULTS:
#+begin_example
--------------------------------------------------------------------------------
CPU name:	Intel(R) Xeon(R) CPU E5-2650 0 @ 2.00GHz
CPU type:	Intel Xeon SandyBridge EN/EP processor
CPU clock:	2.00 GHz
--------------------------------------------------------------------------------
HPCELO:0.754494
--------------------------------------------------------------------------------
Group 1: L2CACHE
+-----------------------+---------+------------+------------+------------+
|         Event         | Counter |   Core 0   |   Core 2   |   Core 4   |
+-----------------------+---------+------------+------------+------------+
|   INSTR_RETIRED_ANY   |  FIXC0  |  259597918 |  227622878 |  228575555 |
| CPU_CLK_UNHALTED_CORE |  FIXC1  | 1545967853 | 1495134372 | 1369348491 |
|  CPU_CLK_UNHALTED_REF |  FIXC2  | 1280368520 | 1240280360 | 1136446600 |
| L2_TRANS_ALL_REQUESTS |   PMC0  |  45267891  |  41824466  |  40804495  |
|     L2_RQSTS_MISS     |   PMC1  |   3155817  |   3057749  |   3013421  |
+-----------------------+---------+------------+------------+------------+

+----------------------------+---------+------------+------------+------------+--------------+
|            Event           | Counter |     Sum    |     Min    |     Max    |      Avg     |
+----------------------------+---------+------------+------------+------------+--------------+
|   INSTR_RETIRED_ANY STAT   |  FIXC0  |  715796351 |  227622878 |  259597918 | 2.385988e+08 |
| CPU_CLK_UNHALTED_CORE STAT |  FIXC1  | 4410450716 | 1369348491 | 1545967853 | 1.470150e+09 |
|  CPU_CLK_UNHALTED_REF STAT |  FIXC2  | 3657095480 | 1136446600 | 1280368520 | 1.219032e+09 |
| L2_TRANS_ALL_REQUESTS STAT |   PMC0  |  127896852 |  40804495  |  45267891  |   42632284   |
|     L2_RQSTS_MISS STAT     |   PMC1  |   9226987  |   3013421  |   3155817  | 3.075662e+06 |
+----------------------------+---------+------------+------------+------------+--------------+

+----------------------+-----------+-----------+-----------+
|        Metric        |   Core 0  |   Core 2  |   Core 4  |
+----------------------+-----------+-----------+-----------+
|  Runtime (RDTSC) [s] |   0.7747  |   0.7747  |   0.7747  |
| Runtime unhalted [s] |   0.7730  |   0.7476  |   0.6847  |
|      Clock [MHz]     | 2414.8745 | 2410.9569 | 2409.8724 |
|          CPI         |   5.9552  |   6.5685  |   5.9908  |
|    L2 request rate   |   0.1744  |   0.1837  |   0.1785  |
|     L2 miss rate     |   0.0122  |   0.0134  |   0.0132  |
|     L2 miss ratio    |   0.0697  |   0.0731  |   0.0739  |
+----------------------+-----------+-----------+-----------+

+---------------------------+-----------+-----------+-----------+-----------+
|           Metric          |    Sum    |    Min    |    Max    |    Avg    |
+---------------------------+-----------+-----------+-----------+-----------+
|  Runtime (RDTSC) [s] STAT |   2.3241  |   0.7747  |   0.7747  |   0.7747  |
| Runtime unhalted [s] STAT |   2.2053  |   0.6847  |   0.7730  |   0.7351  |
|      Clock [MHz] STAT     | 7235.7038 | 2409.8724 | 2414.8745 | 2411.9013 |
|          CPI STAT         |  18.5145  |   5.9552  |   6.5685  |   6.1715  |
|    L2 request rate STAT   |   0.5366  |   0.1744  |   0.1837  |   0.1789  |
|     L2 miss rate STAT     |   0.0388  |   0.0122  |   0.0134  |   0.0129  |
|     L2 miss ratio STAT    |   0.2167  |   0.0697  |   0.0739  |   0.0722  |
+---------------------------+-----------+-----------+-----------+-----------+

#+end_example

- De acordo com esse rastro temos 7 métricas: =runtime, runtime
  unhalted, clock, cpi, l2 request rate, l2 miss rate e l2 miss ratio.=

- Agora vamos usar a flag de coleta de amostras =-t=.

#+begin_src sh :results output :exports both
sudo likwid-perfctr -f -c N:0-2 -t 10ms -g L2CACHE ./tiling_par 1000
#+end_src

#+RESULTS:
#+begin_example
--------------------------------------------------------------------------------
CPU name:	Intel(R) Xeon(R) CPU E5-2650 0 @ 2.00GHz
CPU type:	Intel Xeon SandyBridge EN/EP processor
CPU clock:	2.00 GHz
--------------------------------------------------------------------------------
# CORES: 0|2|4

1 7 3 0.010573361522728 0.010745079788388 0.010745079788388 0.010745079788388 5.6303038027946e-06 4.9915693376356e-05 0.0 2759.6550066658 2752.9126734128 0.0 7.7441540577717 8.3795853269537 0.0 0.60935350756534 0.64123226727105 0.0 0.043328748280605 0.11743473516327 0.0 0.071106094808126 0.18313915433957 0.0
1 7 3 0.022230624531154 0.010941246373242 0.010941246373242 0.010941246373242 0.0067392261385897 0.0016780195434315 0.0 2698.8054448841 2696.7957783433 0.0 3.0040481254852 1.2030139714692 0.0 0.000612501312264 0.033356730244606 0.0 6.2186268603223e-05 0.002719442833268 0.0 0.10152838427948 0.081526061257388 0.0
1 7 3 0.033958172832069 0.011116052305508 0.011116052305508 0.011116052305508 0.0098067031550738 0.013199397719812 0.0012918937086574 2399.8592420269 2427.407676498 2399.87049958 5.1462188216753 4.7451571657302 6.2816477470271 0.10215084094262 0.079442021796462 0.19980257767426 0.0048879289828106 0.0037740339632498 0.018008708950379 0.047850110069638 0.047506771327135 0.090132515606177
1 7 3 0.045659982744179 0.011162559314957 0.011162559314957 0.011162559314957 0.013485559160656 0.013842753434326 0.01378715393426 2399.8661393683 2399.871626524 2399.871544031 6.5293515815294 6.6912184445897 6.7143825287085 0.20037564213961 0.19092514196838 0.19953849124724 0.017137522645415 0.0092413891450235 0.017188473677661 0.085526975546633 0.04840320687861 0.086141142845288
1 7 3 0.057391977285006 0.011204004051253 0.011204004051253 0.011204004051253 0.013547369995877 0.013873926116358 0.013877902330908 2399.8717396738 2399.8707590596 2399.8714507328 6.802012087488 6.4768928959343 6.982905982906 0.20147261184491 0.2011163195024 0.18573534440009 0.017540239113641 0.017032381015519 0.013315781912526 0.087060166406851 0.084689204027104 0.071692234752277
1 7 3 0.069103656229635 0.011193457982203 0.011193457982203 0.011193457982203 0.013550135645107 0.013915513360343 0.01392851106168 2399.8535847394 2399.8716206315 2399.871791894 6.8063859767216 6.8976698465558 6.668615144405 0.20127995820545 0.19823195551906 0.17414732253687 0.017458519407844 0.016504127890881 0.009050761687455 0.086737495195739 0.083256646728149 0.051971868160873
1 7 3 0.080875692931077 0.011188059190892 0.011188059190892 0.011188059190892 0.013556877508888 0.013900381543853 0.013892741131588 2399.8637723861 2399.8697226232 2399.8724862306 6.9334321474868 6.6570551089463 6.7003750755734 0.20135122728764 0.18022778268689 0.17626960296202 0.017576848846312 0.006242950638304 0.011677431630642 0.087294470876018 0.034639224570331 0.066247563019462
1 7 3 0.092609377563099 0.011190261809742 0.011190261809742 0.011190261809742 0.013545322385391 0.013895842298922 0.013885422736698 2399.878915799 2399.8712767912 2399.8686847285 6.7400245126335 6.5832068934885 6.6590539364879 0.20164228673113 0.1931249888958 0.18148231100743 0.017515635138955 0.014129993189423 0.010118307097754 0.086864890410164 0.07316501748537 0.055753682227135
1 7 3 0.10432676531577 0.011183485944126 0.011183485944126 0.011183485944126 0.013513926691326 0.01389451772745 0.013904693276508 2399.8785801602 2399.87049958 2399.8682557354 6.7981353570315 6.7496245355426 6.636684202751 0.18742944390224 0.20167135425409 0.17914371434838 0.0087899566350401 0.017320309621242 0.011796344033105 0.046897416179843 0.085883836528513 0.065848495304529
1 7 3 0.11609043606579 0.011187237646563 0.011187237646563 0.011187237646563 0.013544869360946 0.013888970928153 0.013877890830288 2399.8666900255 2399.8700675827 2399.8673867191 6.9382436546507 6.6055011989164 6.6760230418338 0.20128359268664 0.20160535661076 0.17671700052053 0.017554181422151 0.017110391393961 0.0098123593440755 0.087211188889497 0.084870718127772 0.055525836875755
1 7 3 0.12775990273271 0.011157207526182 0.011157207526182 0.011157207526182 0.01348178095679 0.013826532059045 0.013877287797749 2399.8600855708 2399.8701524214 2399.8689430809 6.9086310141519 6.9034008238672 6.6835477972386 0.20123479566553 0.20141330670328 0.17506930251006 0.017436524225722 0.017146673324179 0.011115614479848 0.08664766035146 0.085131780043904 0.063492653026414
1 7 3 0.13950400642693 0.011161757771707 0.011161757771707 0.011161757771707 0.013512882134963 0.01386956188087 0.01383575905692 2399.8635728764 2399.8693748154 2399.8719740212 6.8234615949812 6.8945716387144 6.6848549155866 0.20214402330212 0.20156565404236 0.17573421601363 0.017463712896711 0.017378342282875 0.010083805826763 0.086392427594115 0.086216783139171 0.057381004425344
1 7 3 0.1512141497887 0.011170082720908 0.011170082720908 0.011170082720908 0.013520441042831 0.013894548729123 0.013898079419634 2399.8697007898 2399.8717086879 2399.8700678658 6.7116626562965 6.8871432020078 6.6677795362028 0.17941570552647 0.20178025362938 0.17535455773931 0.0084267417806441 0.017281804423916 0.010733829386713 0.046967693022844 0.085646658248621 0.061212149402298
1 7 3 0.16292188702064 0.011148574060333 0.011148574060333 0.011148574060333 0.013468477738968 0.013824039924573 0.013858508784462 2399.8760236023 2399.8708468013 2399.8672091872 6.7490794888184 6.9481403702597 6.6681764715365 0.20183242800218 0.20196728266035 0.17901894121024 0.017415983857635 0.01727649044695 0.011294424701069 0.086289324416426 0.085541035257695 0.06309066864497
1 7 3 0.17466626222951 0.011182931914232 0.011182931914232 0.011182931914232 0.013541271166793 0.013983241014827 0.013968223204488 2399.8521557999 2399.8709286652 2399.8721318575 6.8894964304776 6.6790223325323 6.5750076200586 0.2024098028431 0.20277951729478 0.17477389903393 0.017788590452068 0.017340397125761 0.0077542186880319 0.087884036258151 0.085513553622642 0.044367143669013
1 7 3 0.18649943772991 0.011210605907479 0.011210605907479 0.011210605907479 9.7060237225618e-06 0.013956611077915 0.013937019520784 2384.5150628249 2399.8708435031 2399.8717911051 12.011757425743 6.8753911354536 6.5578870889606 0.75742574257426 0.20220930103666 0.17546646288166 0.095915841584158 0.017358617912113 0.0081642621306936 0.1266339869281 0.085844804482885 0.046528903567171
1 7 3 0.19812760666846 0.011088567822487 0.011088567822487 0.011088567822487 0.010645319405556 0.0028818094981418 0.013673111280689 2399.8544926518 2399.868833961 2399.8693586552 1.8101790105013 6.8451009013482 6.3998048562201 0.17918030001906 0.2045023463082 0.20142849553227 0.016123223001881 0.017876124903648 0.017380621880959 0.089983234765014 0.087412810788522 0.08628680780756
1 7 3 0.20927873286651 0.010757641466197 0.010757641466197 0.010757641466197 0.0046559212265643 0.0 0.0081223387692841 2399.8735924199 0.0 2399.8741931032 1.8590069300433 0.0 3.3001146033892 0.1355402353192 0.0 0.21115263054496 0.01373830027366 0.0 0.019995965213067 0.10135957224293 0.0 0.094699105388643
1 7 3 0.22019453936705 0.010616318340613 0.010616318340613 0.010616318340613 2.4938845662911e-05 0.0015296185359345 0.0 2406.9647113609 2495.1725930828 0.0 1.1125362480482 2.6699134284146 0.0 0.077693508811064 0.00014662794990561 0.0 0.022886459959848 4.363927080524e-06 0.0 0.29457364341085 0.029761904761905 0.0
1 7 3 0.24127119613184 0.020743380281685 0.020743380281685 0.020743380281685 0.022562213923408 0.022888218014102 0.010045238526087 2399.9931001951 2400.2223478764 2399.8706190396 5.9257728609227 5.9023639904724 6.6832915656574 0.13535065118242 0.14097600678358 0.18695684139894 0.0063915935488099 0.0080041860988097 0.012900240293049 0.047222480963137 0.056776938724737 0.069001167309636
1 7 3 0.2528572642987 0.011052951900705 0.011052951900705 0.011052951900705 0.013331448845093 0.013702527867964 0.013752764078635 2399.8707696182 2399.8698865546 2399.8680564373 6.8979105597454 6.5722741873089 6.4704329400594 0.19886446839062 0.18563867331259 0.17710923331468 0.017624671746245 0.0093928083283348 0.0091229100339777 0.088626549975866 0.050597260585452 0.051510075805978
1 7 3 0.26452923960098 0.011097146785395 0.011097146785395 0.011097146785395 0.013464587529058 0.013824960474245 0.013785577849217 2399.8778076613 2399.8702391815 2399.8708477701 6.5159006992422 6.553086572496 6.4573679760346 0.19845947495255 0.18826369127781 0.17192498401448 0.017600227652357 0.013325919510726 0.0083937425781534 0.088684239724833 0.070783269042895 0.048822122196308
1 7 3 0.27620621567309 0.011132543195332 0.011132543195332 0.011132543195332 0.013434185388604 0.01378531733516 0.01380439236442 2399.8791640741 2399.8693679418 2399.8683263607 6.5695124041571 6.559973264367 6.4836890239248 0.19796426920042 0.17959987445959 0.17581067557923 0.017483458800867 0.010914115467192 0.010861536777815 0.088316234396654 0.06076905955548 0.061779734035092
1 7 3 0.2877602731127 0.011043636898082 0.011043636898082 0.011043636898082 0.013324614976348 0.013693751394399 0.013729030798023 2399.8741019409 2399.8754945694 2399.8687514608 6.4792430644472 6.604785945175 6.4626192355836 0.18048217343246 0.17329142379481 0.17202829595798 0.0075442630970576 0.0085416450112881 0.0083850336658254 0.041800599768822 0.04929063899551 0.04874217708855
1 7 3 0.2993642837477 0.011052184859317 0.011052184859317 0.011052184859317 0.013344492548912 0.013732582489667 0.013724976079236 2399.8619567603 2399.8686645296 2399.8690132396 6.7484456791182 6.5592010311802 6.4557614589093 0.19855505748844 0.18441445725352 0.17724110307709 0.017557940444862 0.011148191075954 0.0078614151864431 0.088428573247921 0.060451828137465 0.044354357143805
1 7 3 0.31096081497914 0.011038358113246 0.011038358113246 0.011038358113246 0.013324205954278 0.013731228416603 0.013707454133778 2399.8847294054 2399.8690139163 2399.8730383474 6.6079580256502 6.5500879078364 6.4406424894375 0.19851394573866 0.17575103298565 0.17199204288964 0.017573708797245 0.0097677759043082 0.0094501845373902 0.08852631855084 0.055577345625647 0.054945475259305
1 7 3 0.32252896217901 0.011026675982896 0.011026675982896 0.011026675982896 0.013300046150651 0.013689429161177 0.013684015369057 2399.869146202 2399.8709378745 2399.8706749672 6.8676875767329 6.5609782400565 6.3948271321559 0.18509223434456 0.1816534336155 0.17674705098723 0.012319084744056 0.0091481439498423 0.0093394459097045 0.066556464606307 0.050360424065562 0.052840745333732
1 7 3 0.33408162104315 0.011024544867904 0.011024544867904 0.011024544867904 0.013293752311045 0.013640870041 0.013616557729144 2399.8768183544 2399.8743703071 2399.8682082542 6.4553064805658 6.5553221219523 6.416371668071 0.19827179085115 0.17800216025539 0.17396010638799 0.017247855581776 0.0074366611438781 0.0067856745665971 0.086990970867485 0.041778488155472 0.039007072986393
1 7 3 0.34560507733157 0.011042701347601 0.011042701347601 0.011042701347601 0.013299385615009 0.013699601710073 0.01376304763352 2399.8712214181 2399.872339051 2399.8678838832 6.4256056558724 6.555164977774 6.3807915631874 0.19841431091885 0.17445962652076 0.18751957441314 0.017390010274751 0.0064210062152431 0.01367374903997 0.087644939491605 0.0368051126974 0.072919049026019
1 7 3 0.3572119591215 0.011035245445291 0.011035245445291 0.011035245445291 0.013334847528481 0.013624193141139 0.013741835988972 2399.8582610323 2399.8708518945 2399.870936203 6.5644646989872 6.4887637613084 6.4660094511976 0.1986590582491 0.18147613817463 0.17351570670466 0.017553399148016 0.0083141783985681 0.0092323872332366 0.088359419916338 0.045814168640548 0.053207789707194
1 7 3 0.36882015148214 0.011035777974026 0.011035777974026 0.011035777974026 4.5510455676301e-05 0.013704794990295 0.01367088866076 2400.0814586605 2399.8697115349 2399.8731329157 1.6753672274786 6.4310979210941 6.5086085753185 0.078378676876634 0.18129062095462 0.17979677844098 0.021113279092884 0.0081517027159124 0.0056862804379431 0.26937529356505 0.044964834214743 0.031626153078207
1 7 3 0.38033946154684 0.011015089857726 0.011015089857726 0.011015089857726 0.013321079785594 0.013585018027308 0.013511049536079 2399.866355779 2399.8699695845 2399.8684568093 1.7422979633324 6.289115461228 5.3112399249525 0.18847536448291 0.18408286235788 0.18516642440361 0.016628488441827 0.01341084993177 0.013091050615781 0.088226323304631 0.072852245776672 0.070698835698454
1 7 3 0.39134308678595 0.010673192409453 0.010673192409453 0.010673192409453 0.0055996431483914 0.013148892994652 0.0098407159903557 2399.8846434218 2399.8682180213 2399.8717190041 2.1574470544492 6.1812355952024 1.8602690117715 0.12495111458741 0.177710393785 0.1561404643061 0.010874812886869 0.0099068573006834 0.013763935922499 0.087032540067994 0.055747202454962 0.088150986252459
1 7 3 0.40235892968431 0.010654655909251 0.010654655909251 0.010654655909251 0.0011462353491496 0.013156169387275 0.0015752399976005 2399.9573958762 2413.9724321174 2404.0630782634 3.8458132781266 5.1917524857779 3.3672267470446 0.0026037516168593 0.14868987318043 0.02619765279292 0.00033050197714 0.015668441916955 0.0017593364543919 0.12693298969072 0.10537665801854 0.067156262749898
1 7 3 0.41380625036456 0.011034654913427 0.011034654913427 0.011034654913427 0.013239049859382 0.013615759686082 0.013672879768197 2403.3160790883 2403.222295715 2403.1676141145 6.1241312551537 6.0968868094779 6.024237256956 0.14200657594195 0.14639487244476 0.14256126564068 0.0084379304402735 0.0081171513641731 0.0095995963908708 0.059419293679207 0.055446964969595 0.067336638375996
1 7 3 0.42539912839887 0.011041047258348 0.011041047258348 0.011041047258348 0.013371203990222 0.013737145735893 0.013730015351148 2399.8529994137 2399.8691892649 2399.8709365789 6.724038954769 6.736022955549 6.6370029810081 0.2020357462559 0.1824608660409 0.1941382450073 0.017534926526055 0.01018513955284 0.016414035513468 0.086791208244138 0.055820953686346 0.084548181183211
1 7 3 0.43699949183708 0.011029705146345 0.011029705146345 0.011029705146345 0.013368017818301 0.013762239589919 0.013759428438234 2399.8756162807 2399.8713715315 2399.8729415444 6.9541272925104 6.6484355411049 6.5904505980351 0.20207750399865 0.1837655232054 0.20135318321382 0.017671841871637 0.011907183249311 0.017453428942314 0.087450812297022 0.064795523347447 0.08668067056968
1 7 3 0.44864491570668 0.011031622249789 0.011031622249789 0.011031622249789 1.581085313005e-05 0.013770745048861 0.013758368381035 2395.3252903005 2399.8708481451 2399.8701507015 19.566831683168 6.6964930466145 6.8251350193565 0.84282178217822 0.18134192935322 0.20143203738398 0.13613861386139 0.010816269314723 0.017400152153352 0.16152716593245 0.059645716538368 0.086382247726475
1 7 3 0.46024553165852 0.011035239444968 0.011035239444968 0.011035239444968 0.0083485029727671 0.013717106154587 0.013739032337691 2399.874093044 2399.8694497964 2399.8675299423 6.6762842249385 6.6807262100457 6.555752660862 0.20032605461915 0.18376328767123 0.19988036887615 0.017474752160102 0.0062434094368341 0.017194767056919 0.087231549552175 0.033975281548097 0.086025291796281
1 7 3 0.47190865548319 0.01106719366917 0.01106719366917 0.01106719366917 0.01273434312616 0.0137915061691 0.013741510971434 2399.87049958 2399.8729358646 2399.8728574017 6.7007551050961 6.6811450723949 6.7507098533965 0.2009686204749 0.18210709928122 0.20033280020123 0.017482212971789 0.0080149932308092 0.017271564030754 0.086989764523824 0.044012524840846 0.086214359373027
1 7 3 0.48361924136884 0.011164567923338 0.011164567923338 0.011164567923338 0.013509299941673 0.013883056609026 0.013917515468374 2399.8838238085 2399.8683386746 2399.8712755809 6.747869962633 6.7623422067827 6.8540988495291 0.20323377548795 0.17708229566739 0.20077673221355 0.017616501111568 0.0073798598995706 0.017320965835061 0.086680971552449 0.041674747166324 0.086269786563902
1 7 3 0.49535583615789 0.011143249773043 0.011143249773043 0.011143249773043 0.012069466250395 0.013860694902421 0.013859060814248 2399.864732976 2399.8737894629 2399.8692873773 6.5858596386589 6.6833527702627 6.7608106252291 0.20219182776641 0.17843583390214 0.20026729430498 0.017377299035844 0.0093215286033885 0.017224603077226 0.085944616198433 0.052240227758853 0.086008068052267
1 7 3 0.50701730389319 0.011107941867881 0.011107941867881 0.011107941867881 0.013437316557557 0.013874414142691 0.013900904072048 2399.8832700549 2399.8721428938 2399.8708448814 6.3270648580358 6.5879497539194 6.7128985467702 0.20296406831761 0.17746842169118 0.2004654546719 0.017596433342484 0.0095124899360872 0.017375831466581 0.086697283358293 0.05360102854039 0.086677435246985
1 7 3 0.51872466560487 0.011065568081455 0.011065568081455 0.011065568081455 9.6245193247061e-06 0.013731104909939 0.013617832297917 2393.9006724666 2399.87049958 2399.8707639393 11.910891089109 6.598168948533 6.6876050839579 0.7450495049505 0.18505282840338 0.18844108999766 0.11076732673267 0.0074973491489765 0.015044670888155 0.14867109634551 0.040514642297894 0.079837528472914
1 7 3 0.52977610042371 0.010667041077536 0.010667041077536 0.010667041077536 0.010179999797604 0.0027457841584174 0.013088702246849 2399.8663738503 2399.87049958 2399.8712330372 1.9298372450826 6.4719695451813 6.5006855573031 0.19863391238843 0.17392011503058 0.17394554432455 0.016627165745474 0.01046000447865 0.010332407750262 0.083707588223701 0.060142580269168 0.059400243854384
1 7 3 0.54079667507739 0.010686310617291 0.010686310617291 0.010686310617291 0.012894462765976 0.0 0.013204804011527 2399.8673354353 0.0 2399.870408704 2.0714357836475 0.0 6.6255099936425 0.18753467617085 0.0 0.17534272626507 0.015545206400682 0.0 0.010914152470976 0.082892437377926 0.0 0.062244683332213
1 7 3 0.55219400606028 0.010960918434717 0.010960918434717 0.010960918434717 0.0049097569231598 0.013647692409124 0.013855198605849 2399.8548573597 2399.8669825071 2399.8675548406 1.9847201164112 1.8975657422023 6.4972733115623 0.15741995262456 0.19867488386984 0.17057085180964 0.013205009854892 0.016566454469642 0.0074689948664583 0.083883965372457 0.083384744699264 0.043788225169878
1 7 3 0.56357815333179 0.01070776577498 0.01070776577498 0.01070776577498 5.3577890983076e-06 0.010718182337131 0.013584522000543 2429.5741121504 2475.3323557235 2481.4764274429 6.6305693069307 1.7556043860281 6.282289325099 0.48514851485149 0.16185024737524 0.16996021016212 0.065594059405941 0.013863202111062 0.012493319992203 0.13520408163265 0.085654500600924 0.073507322568532
1 7 3 0.5745329224347 0.010627249430438 0.010627249430438 0.010627249430438 5.0642732606309e-06 0.0017101297760518 0.013615742685165 2488.3178152894 2499.8651037292 2499.866572618 6.2673267326733 2.8890624353249 6.3254141424841 0.48886138613861 0.00016725784147842 0.1926715834363 0.079826732673267 0.0 0.0075345092603498 0.16329113924051 0.0 0.039105451494049
1 7 3 0.58547335726415 0.010597709836526 0.010597709836526 0.010597709836526 5.0057701038878e-06 0.0 0.0099600379287895 2521.5264033686 0.0 2499.8652292307 6.1949257425743 0.0 4.9568027317533 0.50556930693069 0.0 0.099905487545409 0.093440594059406 0.0 0.0038474382844621 0.18482252141983 0.0 0.038510780328392
1 7 3 0.59635805608617 0.010557238152735 0.010557238152735 0.010557238152735 0.023972788035883 0.024273611767883 0.024450355804727 2402.0596244836 2402.2729405747 2402.2424267234 5.8760828066658 5.8996278506999 5.8199589611261 0.13915753207652 0.14512218509074 0.14211911985422 0.0071945047220831 0.008836814075318 0.0070788486739135 0.051700433420499 0.060892234152845 0.04980926339239
1 7 3 0.62082458776352 0.011043971416132 0.011043971416132 0.011043971416132 0.013346611663257 0.013719185266772 0.013702760880537 2399.8696903862 2399.8699747676 2399.8707623008 6.6364106502676 6.5249090000205 6.3938116567655 0.20074683846753 0.1783028842701 0.18176137988897 0.017466592044149 0.0096681384255589 0.009409882254564 0.087008055406932 0.054223118516207 0.051770526061764
1 7 3 0.63242529922051 0.011051710333712 0.011051710333712 0.011051710333712 0.01341313525277 0.013764415707339 0.013732743498354 2399.8639686862 2399.8699764922 2399.8695383741 6.7098290576912 6.3904581933666 6.2885921515343 0.19992070718188 0.17865385820776 0.17834351588657 0.01762201588858 0.010461118449613 0.0082518294020481 0.088145025780387 0.058555233872686 0.046269298667951
1 7 3 0.64404780085326 0.011068879760149 0.011068879760149 0.011068879760149 0.013406316884861 0.013732135965573 0.013689009638541 2399.8700520299 2399.8724220793 2399.8710255495 6.4458118983314 6.5551004527954 6.3253449400437 0.20102445645772 0.17743780328581 0.17478618072578 0.017511829620765 0.0087601711886536 0.0095696212007613 0.087112931079846 0.049370376697817 0.054750445149751
1 7 3 0.65562232389716 0.011064741036829 0.011064741036829 0.011064741036829 0.013378327374589 0.013751262997639 0.013736442697958 2399.8671807841 2399.8699759919 2399.8700627858 6.5823545576818 6.4714044180369 6.2680043050115 0.19986926422625 0.17752789952055 0.1759015186414 0.016777921645627 0.010429626143483 0.0086755062233062 0.08394448096149 0.058749222920177 0.049320246296409
1 7 3 0.6672738455958 0.011094641150195 0.011094641150195 0.011094641150195 0.013460581812916 0.013786456896649 0.013804209854572 2399.8632785172 2399.8713699998 2399.8699780001 6.4611503563271 6.4866327459435 6.4146906943414 0.20031221228131 0.17813343797987 0.17172951485511 0.017426332014528 0.0069438905879051 0.0086462730708246 0.086995854202114 0.038981398813455 0.050348206469456
1 7 3 0.67891896944921 0.011079351825205 0.011079351825205 0.011079351825205 0.013421157185622 0.013757782349413 0.013757324824726 2399.8671019642 2399.87049958 2399.8702379013 6.386266733668 6.8876892362958 6.3394769185253 0.20066149500441 0.19384029989924 0.17631188573941 0.017470063556056 0.012366462853674 0.0084714793222264 0.087062361195265 0.063797171486539 0.048048259972373
1 7 3 0.69053741786326 0.011083092027021 0.011083092027021 0.011083092027021 0.013413071249317 0.013756489279641 0.013778722479312 2399.8611057951 2399.868929413 2399.8682352213 6.5917816197168 6.7515933852212 6.3045873515911 0.19953433110164 0.19991410652999 0.18050832586136 0.017391443241842 0.017175749083087 0.0096868315693839 0.087160155076183 0.085915643379126 0.053664181544865
1 7 3 0.70218682344771 0.011086688221066 0.011086688221066 0.011086688221066 0.013424055342002 0.013776128839363 0.013768076904892 2399.8767570199 2399.872154618 2399.8722427441 6.4927353340861 6.6304415630173 6.3577785766948 0.20104781835107 0.2000262803614 0.18108307743745 0.017416721222905 0.017250217438704 0.012076576885484 0.086629744932083 0.086239755133863 0.066690808751336
1 7 3 0.71380242320805 0.011060590812889 0.011060590812889 0.011060590812889 0.013402500678944 0.013719212268229 0.013692733339466 2399.8722007563 2399.868400336 2399.8695355654 6.4814824666508 6.5713406381377 6.3324747119467 0.19375272796739 0.20036917611741 0.17693196749402 0.01367774135786 0.017170258114318 0.0099891914991627 0.070593800156257 0.085693111320958 0.056457810539523
1 7 3 0.72543062364831 0.011119812508403 0.011119812508403 0.011119812508403 0.013435730972001 0.013845577086686 0.01387617473769 2399.8765729531 2399.870152899 2399.8673863341 6.3582823038221 6.485835571626 6.3425923195965 0.20004349280854 0.20093688565043 0.17834593470599 0.017337019100395 0.017313107146898 0.0088629006766824 0.086666248709162 0.086161916418954 0.049694996924339
1 7 3 0.73730186120248 0.011251882634709 0.011251882634709 0.011251882634709 9.8565318437555e-06 0.013987064721148 0.013888204886819 2380.5478707589 2399.8660383235 2399.8704131758 12.19801980198 6.3818750734349 6.1790914448397 0.82487623762376 0.20055462585569 0.1758800867545 0.10024752475248 0.017295839621641 0.0070247206719136 0.12153038259565 0.086240043319098 0.039940398037891
1 7 3 0.74872741970848 0.010994850765655 0.010994850765655 0.010994850765655 2.7335975008435e-05 0.013702381360059 0.013671030168395 2403.9599886679 2429.6839366508 2429.7456898442 1.0240516999157 6.2087465771023 6.1871659109389 0.063369860447691 0.20329305079823 0.17114049838886 0.019106490587244 0.018190353670357 0.01133874596932 0.30150753768844 0.089478482412128 0.066254019802818
1 7 3 0.75976450775319 0.010676234073576 0.010676234073576 0.010676234073576 0.0006929793921343 0.010997886929573 0.0091589022007006 2400.6257379851 2476.5390346363 2473.3671183208 3.4099966044811 3.9685582162065 4.5442406127257 0.015995846640651 0.14123514965417 0.079419694867688 0.0048521472966256 0.014514604369989 0.0049600870899301 0.303337948008 0.10276906567189 0.062454119197933
HPCELO:0.740614
#+end_example

- Vou tentar compreender os dados novamente, mas agora comparando com
  a execução sem a flag de amostragem.

#+begin_src sh :results output :exports both
rm dados/likwid-exec2withheader.txt
echo "- - - timestamp C0runtime_rdstc C0runtime_unshall C0clock COcpi C0l2reqrate C0l2missrate C0l2missratio C2runtime_rdstc C2runtime_unshall C2clock C2cpi C2l2reqrate C2l2missrate C2l2missratio C4runtime_rdstc C4runtime_unshall C4clock C4cpi C4l2reqrate C4l2missrate C4l2missratio"  >> dados/likwid-exec2withheader.txt
cat dados/liwkid-exec2.txt | grep -i "1 7" | head -8  >> dados/likwid-exec2withheader.txt
#+end_src

#+RESULTS:

#+begin_src sh :results output :exports both
cat dados/likwid-exec2withheader.txt | awk ' { print $1,$25 } '
#+end_src

#+RESULTS:
: - C4l2missratio
: 1 0.0
: 1 0.0
: 1 0.090132515606177
: 1 0.086141142845288
: 1 0.071692234752277
: 1 0.051971868160873
: 1 0.066247563019462
: 1 0.055753682227135

- Agora o traço gerado está compreendido e o experimento pode ser
  realizado. 

* [23:15:57; 11.08.2016] Experimentando a ferramenta =tau=            :Gabriel:
- Agora vou testar a ferramenta =tau=, ela utiliza PAPI, da mesma
  maneira que =scorep=, vamos visualizar se para o mesmo teste no
  benchmark da multiplicação de matrizes, o problema que encontramos
  com scorep, não é encontrado quando utilizamos a ferramenta =tau=.

** Instalação do tau

- Vale lembrar que estou instalando o tau com objetivo de usar pela
  sua ferramenta de trace os hardware counters do =PAPI=, para detectar
  as regiões =memory-bound=. De acordo com o uso, a instalação dessa
  ferramenta pode mudar.

#+begin_src sh :results output :exports both
cd $HOME/Programs/
wget http://tau.uoregon.edu/tau.tgz
tar vxf tau.tgz
rm -rf tau.tgz
cd tau-2.25.1/
./configure -papi=/usr/local/bin/ -PAPIWALLCLOCK -PAPIVIRTUAL -cc=gcc -PROFILE -TRACE -openmp
sudo make install
#+end_src

** Experimento teste

#+begin_src sh :results output :exports both
export TAU_MAKEFILE=$HOME/Programs/tau-2.25.1/x86_64/lib/Makefile.tau-papi-openmp-profile-trace
/home/aulapinroot/Programs/tau-2.25.1/tools/src/tau_cc.sh hpcelo.c tiling.c -o mainTest
export TAU_METRICS=TIME:PAPI_FP_INS:PAPI_L1_DCM
export OMP_NUM_THREADS=32
./mainTest 100
#+end_src

- Foi gerado vários arquivos:

#+begin_src sh :results output :exports both
cd benchmarks/MM/
ls
#+end_src

#+RESULTS:
#+begin_example
continuos.c          tautrace.0.0.14.trc  tautrace.0.0.29.trc
continuosT.c         tautrace.0.0.15.trc  tautrace.0.0.2.trc
events.0.edf         tautrace.0.0.16.trc  tautrace.0.0.30.trc
hpcelo.c             tautrace.0.0.17.trc  tautrace.0.0.31.trc
hpcelo.h             tautrace.0.0.18.trc  tautrace.0.0.3.trc
hpcelo.o             tautrace.0.0.19.trc  tautrace.0.0.4.trc
log                  tautrace.0.0.1.trc   tautrace.0.0.5.trc
mainTest             tautrace.0.0.20.trc  tautrace.0.0.6.trc
Makefile             tautrace.0.0.21.trc  tautrace.0.0.7.trc
normal.c             tautrace.0.0.22.trc  tautrace.0.0.8.trc
normalT.c            tautrace.0.0.23.trc  tautrace.0.0.9.trc
tautrace.0.0.0.trc   tautrace.0.0.24.trc  tiling.c
tautrace.0.0.10.trc  tautrace.0.0.25.trc  tiling.o
tautrace.0.0.11.trc  tautrace.0.0.26.trc  tilingT.c
tautrace.0.0.12.trc  tautrace.0.0.27.trc
tautrace.0.0.13.trc  tautrace.0.0.28.trc
#+end_example

- Não sei como funciona esses arquivos =.trc=, será que é possível
  interpretá-los através de algum recurso parecido com o =otf2-print=,
  visto que esses arquivos são binários e não de texto. Tenho que
  descobrir como fazer...
* [22:20:30; 12.08.2016] Benchmark Rodinia           '              :Gabriel:

#+begin_src sh :results output :exports both
cd $HOME/Programs/
wget http://www.cs.virginia.edu/~kw5na/lava/Rodinia/Packages/Current/rodinia_3.1.tar.bz2
tar -xvjf rodinia_3.1.tar.bz2
rm -rf rodinia_3.1.tar.bz2
cd rodinia_3.1/
ls
#+end_src

#+RESULTS:
#+begin_example
bin
common
cuda
data
LICENSE
Makefile
opencl
openmp
others
README
#+end_example

* [01:13:21; 13.08.2016] Experimento com o benchmark Rodinia        :Gabriel:

- Defini o seguinte script para executar algumas aplicações que
  julguei interessantes no benchmark rodinia, a primeira é a aplicação
  =k_means=, um problema de mineração de dados. Outra aplicação
  escolhida foi o =BFS=, algoritmo de busca em largura em grafo. Já
  aplicação =leucocity= processa uma imagem médica para rastrear
  determinados pontos. Ambos algoritmos escolhidos possuem
  comportamentos diferentes, o que permite comparar o quanto as
  regiões paralelas são memory-bound nas diferentes abordagens.


#+begin_src sh :results output :exports both :tangle benchmarks/rod/scriptOfExecutionRod.bash
#!bin/bash

mkdir log_rodiniaExp1

benchpath=$HOME/Programs/rodinia_3.1/openmp

kmeans_command=$benchpath/kmeans/kmeans_openmp/kmeans -i ../../../data/kmeans/819200.txt -n 32
bfs_command=$benchpath/bfs/bfs 32 ../../data/bfs/graph1MW_6.txt
leukocyte_command=$benchpath/leukocyte/OpenMP/leukocyte 30 32 ../../../data/leukocyte/testfile.avi

#aqui o rastro vai ter cerca de 11 amostras 
sudo likwid-perfctr -t 1ms -f -c N:0-31 -g L2CACHE $bfs_command >> log_rodiniaExp1/saidaBfs_2.log 2>> log_rodiniaExp1/saidaBfs_1.log

#aqui o rastro vai ter cerca de 27 amostras
sudo likwid-perfctr -t 10ms -f -c N:0-31 -g L2CACHE $k_means_command >> log_rodiniaExp1/saidaKmeans_2.log 2>> log_rodiniaExp1/saidaKmeans_1.log

#aqui o rastro vai ter cerca de 24 amostras
sudo likwid-perfctr -t 50ms -f -c N:0-31 -g L2CACHE $leukocyte_command >> log_rodiniaExp1/saidaLeucocyte_2.log 2>> log_rodiniaExp1/saidaLeucocyte_1.log

#+end_src


#+RESULTS
#+begin_example
aulapinroot@beagle1:~/Doc/dissertacao_gbmoro/benchmarks/rod/log_rodiniaExp1$
total 628K                                                                   
 ls -larth                                                                  
total 628K                                                                  
drwxrwxr-x 3 aulapinroot aulapinroot 4,0K Ago 13 10:42 ..                   
-rw-rw-r-- 1 aulapinroot aulapinroot   96 Ago 13 10:42 saidaBfs_1.log       
-rw-rw-r-- 1 aulapinroot aulapinroot  401 Ago 13 10:42 saidaBfs_2.log       
-rw-rw-r-- 1 aulapinroot aulapinroot   96 Ago 13 10:42 saidaKmeans_1.log    
-rw-rw-r-- 1 aulapinroot aulapinroot  363 Ago 13 10:42 saidaKmeans_2.log    
drwxrwxr-x 2 aulapinroot aulapinroot 4,0K Ago 13 10:42 .                    
-rw-rw-r-- 1 aulapinroot aulapinroot 600K Ago 13 10:42 saidaLeucocyte_1.log 
-rw-rw-r-- 1 aulapinroot aulapinroot 1,6K Ago 13 10:42 saidaLeucocyte_2.log
-rw-rw-r-- 1 aulapinroot aulapinroot  401 Ago 13 10:42 saidaBfs_2.log       
-rw-rw-r-- 1 aulapinroot aulapinroot   96 Ago 13 10:42 saidaKmeans_1.log    
-rw-rw-r-- 1 aulapinroot aulapinroot  363 Ago 13 10:42 saidaKmeans_2.log    
drwxrwxr-x 2 aulapinroot aulapinroot 4,0K Ago 13 10:42 .                    
-rw-rw-r-- 1 aulapinroot aulapinroot 600K Ago 13 10:42 saidaLeucocyte_1.log 
-rw-rw-r-- 1 aulapinroot aulapinroot 1,6K Ago 13 10:42 saidaLeucocyte_2.log
#+end_example

- Pelo tamanho do rastro é possível visualizar que nas aplicações
  =k_means= e =bfs= a amostragem não ocorreu, por que o tempo de execução
  dessas aplicações foi muito rápido. Problema é que os benchmarks
  executam muito rápidos, rápidos demais. E não consigo configurá-los
  ao ponto de alterar suas entradas para o default (32 threads
  disponíveis na =beagle1=), o algoritmo =leukocyte= é o único que consigo alterar a entrada,
  aumentando o seu tempo de execução, mas os demais não. Como estou
  com o tempo apertado vou executar o benchmark do =NAS=, focando em
  algumas aplicações, o que o senhor acha professor?

* [12:59:49; 13.08.2016] Experimento com o benchmark NAS - L2 CACHE :Gabriel:
** Instalação do benchmark NAS

#+begin_src sh :results output :exports both
rm -rf /tmp/xxx/
mkdir -p /tmp/xxx/
cd /tmp/xxx/
wget http://www.nas.nasa.gov/assets/npb/NPB3.3.1.tar.gz
tar xf NPB3.3.1.tar.gz
cd NPB3.3.1/NPB3.3-OMP/config
cp make.def.template make.def
cp suite.def.template suit.def
pwd
#+end_src

- Após isso nos arquivos make.def deve ser definido o compilador c e
  fortran utilizado, como também a flag =openmp=. No suite.def deve ser
  definido a classe do algoritmo a ser compilado.

** Definições iniciais

- Primeiramente vou fazer um teste para ver mais ou menos o tempo de
  execução para cada algoritmo, usando =32 threads= (default openmp da
  máquina). 

|-----------+--------------+----------------+--------------|
| Aplicação | Execução (s) | TimeStamp (ms) | Amostras     |
|-----------+--------------+----------------+--------------|
| bt.B      |        37.56 | 100ms          | ~= 37        |
| cg.B      |        18.13 | 50ms           | ~= 36        |
| ep.B      |         3.52 | - Descartado   | - Descartado |
| ft.B      |         8.35 | 30ms           | ~= 27        |
| lu.B      |        34.08 | 100ms          | ~= 34        |
| mg.B      |          3.6 | - Descartado   | - Descartado |
| sp.B      |        83.85 | 225ms          | ~= 37        |
| ua.B      |        40.90 | 110ms          | ~= 37        |
|-----------+--------------+----------------+--------------|

- Na coluna =TimeStamp= e =Amostras= estou propondo uma configuração
  adequada para deixar próximo a quantidade de amostras de acordo com
  o tempo de execução de cada aplicação. O motivo de descartar algumas
  aplicações para o experimento é devido ao seu tempo de execução ser
  inferior a 4 segundos, isso porque na medida que eu defnir um
  =TimeStamp= muito pequeno para coletar as amostras, isso pode afetar
  os valores coletados. A maneira que encontro hoje de evitar isso é
  descartando essas aplicações, mas pretendo investigar como resolver
  tal problemática.

** Script do experimento

#+begin_src sh :results output :exports both :tangle scripts/scriptOfExecutionNAS.bash
#!bin/bash
rm -rf log_NASExp1
mkdir log_NASExp1

benchpath=/home/aulapinroot/Programs/NPB3.3.1/NPB3.3-OMP/bin

bt_command=$benchpath/bt.B.x
cg_command=$benchpath/cg.B.x
ft_command=$benchpath/ft.B.x
lu_command=$benchpath/lu.B.x
sp_command=$benchpath/sp.B.x
ua_command=$benchpath/ua.B.x

sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L2CACHE $bt_command >> log_NASExp1/saidaBt_2.log 2>> log_NASExp1/saidaBt_1.log 
sudo likwid-perfctr -t 50ms -f -c N:0-31 -g L2CACHE $cg_command >> log_NASExp1/saidaCg_2.log 2>> log_NASExp1/saidaCg_1.log 
sudo likwid-perfctr -t 30ms -f -c N:0-31 -g L2CACHE $ft_command >> log_NASExp1/saidaFt_2.log 2>> log_NASExp1/saidaFt_1.log 
sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L2CACHE $lu_command >> log_NASExp1/saidaLu_2.log 2>> log_NASExp1/saidaLu_1.log 
sudo likwid-perfctr -t 225ms -f -c N:0-31 -g L2CACHE $sp_command >> log_NASExp1/saidaSp_2.log 2>> log_NASExp1/saidaSp_1.log 
sudo likwid-perfctr -t 110ms -f -c N:0-31 -g L2CACHE $ua_command >> log_NASExp1/saidaUa_2.log 2>> log_NASExp1/saidaUa_1.log 

#+end_src
** Análise dos dados

- Acho que o primeiro passo é tratar os arquivos gerados pelo
  experimento que estão na extensão de =.log= para =.csv=, já formatando o
  arquivo e adicionando o cabeçalho apropriado para facilitar a
  análise utilizando R.

- Os arquivos gerados no experimento estão no diretório
  [[:benchmarks/NAS-OMP/log_NASExp1:]]. Os arquivos que possuem o =_1= são
  os rastros gerados pela ferramenta likwid, já o =_2= são as saídas que
  não fazem parte do rastro.

#+begin_src sh :results output :exports both :tangle scripts/exp1NAS_test.bash
cd benchmarks/NAS-OMP/log_NASExp1/

numberOfCores=32
count=0

tmp="timeStamp"
while [ $count -lt $numberOfCores ]
do
	tmp=$tmp",C'$count'runtime_rdstc,C'$count'runtime_unshall,C'$count'clock,C'$count'cpi,C'$count'l2reqrate,C'$count'l2missrate,C'$count'l2missratio"
	count=$(echo "$count+1" | bc)
done

echo "$tmp" >> btexp1L2CACHEg.csv

cat saidaBt_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> btexp1L2CACHEg.csv

cat btexp1L2CACHEg.csv

mv btexp1L2CACHEg.csv ../../../dados/
#+end_src

#+RESULTS:
#+begin_example
timeStamp,C'0'runtime_rdstc,C'0'runtime_unshall,C'0'clock,C'0'cpi,C'0'l2reqrate,C'0'l2missrate,C'0'l2missratio,C'1'runtime_rdstc,C'1'runtime_unshall,C'1'clock,C'1'cpi,C'1'l2reqrate,C'1'l2missrate,C'1'l2missratio,C'2'runtime_rdstc,C'2'runtime_unshall,C'2'clock,C'2'cpi,C'2'l2reqrate,C'2'l2missrate,C'2'l2missratio,C'3'runtime_rdstc,C'3'runtime_unshall,C'3'clock,C'3'cpi,C'3'l2reqrate,C'3'l2missrate,C'3'l2missratio,C'4'runtime_rdstc,C'4'runtime_unshall,C'4'clock,C'4'cpi,C'4'l2reqrate,C'4'l2missrate,C'4'l2missratio,C'5'runtime_rdstc,C'5'runtime_unshall,C'5'clock,C'5'cpi,C'5'l2reqrate,C'5'l2missrate,C'5'l2missratio,C'6'runtime_rdstc,C'6'runtime_unshall,C'6'clock,C'6'cpi,C'6'l2reqrate,C'6'l2missrate,C'6'l2missratio,C'7'runtime_rdstc,C'7'runtime_unshall,C'7'clock,C'7'cpi,C'7'l2reqrate,C'7'l2missrate,C'7'l2missratio,C'8'runtime_rdstc,C'8'runtime_unshall,C'8'clock,C'8'cpi,C'8'l2reqrate,C'8'l2missrate,C'8'l2missratio,C'9'runtime_rdstc,C'9'runtime_unshall,C'9'clock,C'9'cpi,C'9'l2reqrate,C'9'l2missrate,C'9'l2missratio,C'10'runtime_rdstc,C'10'runtime_unshall,C'10'clock,C'10'cpi,C'10'l2reqrate,C'10'l2missrate,C'10'l2missratio,C'11'runtime_rdstc,C'11'runtime_unshall,C'11'clock,C'11'cpi,C'11'l2reqrate,C'11'l2missrate,C'11'l2missratio,C'12'runtime_rdstc,C'12'runtime_unshall,C'12'clock,C'12'cpi,C'12'l2reqrate,C'12'l2missrate,C'12'l2missratio,C'13'runtime_rdstc,C'13'runtime_unshall,C'13'clock,C'13'cpi,C'13'l2reqrate,C'13'l2missrate,C'13'l2missratio,C'14'runtime_rdstc,C'14'runtime_unshall,C'14'clock,C'14'cpi,C'14'l2reqrate,C'14'l2missrate,C'14'l2missratio,C'15'runtime_rdstc,C'15'runtime_unshall,C'15'clock,C'15'cpi,C'15'l2reqrate,C'15'l2missrate,C'15'l2missratio,C'16'runtime_rdstc,C'16'runtime_unshall,C'16'clock,C'16'cpi,C'16'l2reqrate,C'16'l2missrate,C'16'l2missratio,C'17'runtime_rdstc,C'17'runtime_unshall,C'17'clock,C'17'cpi,C'17'l2reqrate,C'17'l2missrate,C'17'l2missratio,C'18'runtime_rdstc,C'18'runtime_unshall,C'18'clock,C'18'cpi,C'18'l2reqrate,C'18'l2missrate,C'18'l2missratio,C'19'runtime_rdstc,C'19'runtime_unshall,C'19'clock,C'19'cpi,C'19'l2reqrate,C'19'l2missrate,C'19'l2missratio,C'20'runtime_rdstc,C'20'runtime_unshall,C'20'clock,C'20'cpi,C'20'l2reqrate,C'20'l2missrate,C'20'l2missratio,C'21'runtime_rdstc,C'21'runtime_unshall,C'21'clock,C'21'cpi,C'21'l2reqrate,C'21'l2missrate,C'21'l2missratio,C'22'runtime_rdstc,C'22'runtime_unshall,C'22'clock,C'22'cpi,C'22'l2reqrate,C'22'l2missrate,C'22'l2missratio,C'23'runtime_rdstc,C'23'runtime_unshall,C'23'clock,C'23'cpi,C'23'l2reqrate,C'23'l2missrate,C'23'l2missratio,C'24'runtime_rdstc,C'24'runtime_unshall,C'24'clock,C'24'cpi,C'24'l2reqrate,C'24'l2missrate,C'24'l2missratio,C'25'runtime_rdstc,C'25'runtime_unshall,C'25'clock,C'25'cpi,C'25'l2reqrate,C'25'l2missrate,C'25'l2missratio,C'26'runtime_rdstc,C'26'runtime_unshall,C'26'clock,C'26'cpi,C'26'l2reqrate,C'26'l2missrate,C'26'l2missratio,C'27'runtime_rdstc,C'27'runtime_unshall,C'27'clock,C'27'cpi,C'27'l2reqrate,C'27'l2missrate,C'27'l2missratio,C'28'runtime_rdstc,C'28'runtime_unshall,C'28'clock,C'28'cpi,C'28'l2reqrate,C'28'l2missrate,C'28'l2missratio,C'29'runtime_rdstc,C'29'runtime_unshall,C'29'clock,C'29'cpi,C'29'l2reqrate,C'29'l2missrate,C'29'l2missratio,C'30'runtime_rdstc,C'30'runtime_unshall,C'30'clock,C'30'cpi,C'30'l2reqrate,C'30'l2missrate,C'30'l2missratio,C'31'runtime_rdstc,C'31'runtime_unshall,C'31'clock,C'31'cpi,C'31'l2reqrate,C'31'l2missrate,C'31'l2missratio
0.10093558788872,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.078669250968433,0.061730678505742,0.06812005584327,0.0842342805691,0.029186527697428,0.043639749416139,0.064533694611705,0.049827747707227,0.077229596561942,0.056916491942482,0.064462121917493,0.06978676036586,0.039682751178853,0.053260176521097,0.060669666626694,0.061107531314836,0.081091103040111,0.084310360275542,0.089570930050059,0.088598344910957,0.075744063030957,0.071260555864994,0.070168528901787,0.06912742907677,0.090558811730669,0.079545640346509,0.08952201191732,0.091951127008706,0.076420834867373,0.02561146449652,0.040553241040921,0.027881183155385,2406.0595569703,2399.9940707962,2406.9960856887,2405.6520813749,2400.0714850418,2399.9947525202,2407.3830192521,2399.9888877798,2399.9935808462,2399.9930448638,2399.9912165187,2400.0395373504,2399.9941831342,2399.9956505865,2399.9948326069,2399.9941749309,2405.867401282,2400.011008724,2405.3117987948,2405.3711138561,2399.9927746907,2399.9916857807,2406.7859675129,2400
...

#+end_example

- O próximo passo é fazer filtrar os demais arquivos obtidos no
  experimento com o benchmark NAS.
  
#+begin_src sh :results output :exports both :tangle scripts/exp2NAS_test_L2.bash

cd benchmarks/NAS-OMP/log_NASExp1/

numberOfCores=32

count=0

tmp="timeStamp"
while [ $count -lt $numberOfCores ]
do
	tmp=$tmp",C'$count'runtime_rdstc,C'$count'runtime_unshall,C'$count'clock,C'$count'cpi,C'$count'l2reqrate,C'$count'l2missrate,C'$count'l2missratio"
	count=$(echo "$count+1" | bc)
done

echo "$tmp" >> cgexp1L2CACHEg.csv
echo "$tmp" >> ftexp1L2CACHEg.csv
echo "$tmp" >> luexp1L2CACHEg.csv
echo "$tmp" >> spexp1L2CACHEg.csv
echo "$tmp" >> uaexp1L2CACHEg.csv

cat saidaCg_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> cgexp1L2CACHEg.csv
cat saidaFt_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> ftexp1L2CACHEg.csv
cat saidaLu_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> luexp1L2CACHEg.csv
cat saidaSp_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> spexp1L2CACHEg.csv
cat saidaUa_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> uaexp1L2CACHEg.csv


mv *.csv ../../../dados/
#+end_src

#+RESULTS:

- Todos os =.csv= do experimento foram gerados.

- Utilizando o script que o professor Lucas desenvolveu vou testar
  para as aplicações do benchmark NAS, começando pelo bt.


#+begin_src sh :results output
chmod 755 ./scripts/likwid2csv.sh
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaCg_1.log  > dados/exp1_NASandLikwid/cgB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaFt_1.log  > dados/exp1_NASandLikwid/ftB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaLu_1.log  > dados/exp1_NASandLikwid/luB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaSp_1.log  > dados/exp1_NASandLikwid/spB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaUa_1.log  > dados/exp1_NASandLikwid/uaB.csv

cd dados/exp1_NASandLikwid/
ls
#+end_src

#+RESULTS:
: cgB.csv
: extraction1
: ftB.csv
: luB.csv
: spB.csv
: uaB.csv

*** Plotando os gráficos para análise

A métrica utilizada para gerar os gráficos é a =M7=, essa métrica
apresenta a taxa de misses no segundo nível de cache L2 para cada
processador, esse valor é apresentado como porcentagem.

#+BEGIN_EXAMPLE
l2missrate = l2missrequests/totalOfInstructions
M7 = l2missrate

if M7 => min(M7_total) and M7 < mean(M7_total) then
		the region is memory-bound;
else
		the region is not memory-bound;
#+END_EXAMPLE


- No =eixo y= de cada gráfico é possível visualizar a porcentagem de
  cache misses na L2 de cada processador analisado, como a =beagle1=,
  plataforma na qual o experimento foi executado possui cerca de =32
  cores= é possível visualizar nos arquivos gerados 32 gráficos
  respectivos de cada core, apresentando o comportamento da
  aplicação. Já no =eixo x= é apresentado a frequência das amostras
  realizadas (=time stamp=).

- É possível visualizar também nos gráficos uma linha vermelha que é
  calculada pela média de cache misses total (cache
  L2). Possibilitando uma análise comparativa com as demais regiões da
  aplicação.

**** Aplicação CG

#+begin_src R :results output graphics :file "imagens/cgBNas_Analise.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp1_NASandLikwid/cgB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);
#+end_src

#+RESULTS:
[[file:imagens/cgBNas_Analise.pdf]]

- A aplicação CG tem uma característica interessante, ela é uma
  aplicação que realiza acessos irregulares a memória. No gráfico é
  possível ver que a maior porcentagem registrada de cache misses é de
  40%. Pontos que achei interessante no gráfico gerado:

	a) Para os cores 17 até 24 é possível visualizar um
           comportamento mais linear em 40% de cache misses.
    	b) Nos cores 25, 26, 27 e 28 é possível uma queda brusca na
           taxa de cache misses próximo ao =time stamp= 10
	c) A maioria dos núcleos de processamento apresentam um
           comportamento diferente no gráfico quando comparado com os
           demais, isso pode estar relacionado ao tipo de aplicação,
           pela irregularidade da sua carga. Poderíamos propor por exemplo
           neste tipo de aplicação, uma configuração de frequência
           adequada para cada núcleo de processamento.

- Um ponto que acharia interessante é separar os cores por afinidade,
  vou tentar fazer isso em R, dizendo que os cores 1,3,5,... pertencem
  a um socket e os outros a outro.

**** Aplicação FT

- A aplicação =FT= é a famosa transformada discreta de fourier, só que
  em uma versão de 3 dimensões.

#+begin_src R :results output graphics :file "imagens/ftBNas_Analise.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp1_NASandLikwid/ftB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/ftBNas_Analise.pdf]]

- Diferente da aplicação anterior, nessa aplicação visualizamos um
  comportamento mais homogêneo dos diferentes cores. Visualizamos
  também pequenos intervalos entre um pico de cache misses e um
  aumento na taxa de hit para a cache L2.

- O maior valor registrado de taxa de misses foi 30%.

**** Aplicação LU

- A aplicação =LU= define o método de Gauss-Seidel para resolver 'n'
  equações lineares com um 'x' que é desconhecido.

#+begin_src R :results output graphics :file "imagens/luBNas_Analise.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp1_NASandLikwid/luB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/luBNas_Analise.pdf]]

- A partir do gráfico gerado é possível visualizar um comportamento
  mais =memory-bound= do 17 ao 32º core, especificamente nos primeiros e
  últimos timestamps coletados (considerar que os cores não acessam a
  memória de maneira uniforme, arquitetura NUMA)

**** Aplicação SP

- Essa aplicação resolve o problema chamado =Scalar Penta-diagonal=. 

#+begin_src R :results output graphics :file "imagens/spBNas_Analise.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp1_NASandLikwid/spB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/spBNas_Analise.pdf]]

- Comparado as aplicações anteriores é possível visualizar que o maior
  índice de cache misses é inferior a taxa dos outros, o que pode não
  ser interessante usar esse gráfico no artigo.

**** Aplicação UA

- Essa aplicação define uma série de cálculos sobre uma malha
  adaptativa desistruturada, o que gera acessos irregulares a memória.


#+begin_src R :results output graphics :file "imagens/uaBNas_Analise.pdf" :exports both :session *RFib* 

library(dplyr);
df <- read.csv("dados/exp1_NASandLikwid/uaB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/uaBNas_Analise.pdf]]

- É possível visualizar um comportamento totalmente heterogêneo entre
  os núcleos de processamento, de maneira geral, a taxa de misses na
  cache L2 é baixa, mas durante a execução se altera com um intervalo
  pequeno das frequências. O interessante seria, realizar um
  refinamento maior das amostras para podermos compreender melhor o
  comportamento da taxa de misses em uma granularidade mais fina de
  amostragem.

* 2016-08-14 Attempt to correctly parse =likwid-perfcrt= log file (timeline mode) :Lucas:

See here how Gabriel obtained the timeline logs:
- [[*Script do experimento][Script do experimento]]

So, Gabriel has generated these files:
#+begin_src sh :results output
find benchmarks/NAS-OMP/log_* | grep _1
#+end_src

#+RESULTS:
: benchmarks/NAS-OMP/log_NASExp1/saidaFt_1.log
: benchmarks/NAS-OMP/log_NASExp1/saidaSp_1.log
: benchmarks/NAS-OMP/log_NASExp1/saidaBt_1.log
: benchmarks/NAS-OMP/log_NASExp1/saidaUa_1.log
: benchmarks/NAS-OMP/log_NASExp1/saidaLu_1.log
: benchmarks/NAS-OMP/log_NASExp1/saidaCg_1.log

The man page of the tool is quite nice:

#+begin_src sh :results output
man likwid-perfctr
#+end_src

#+RESULTS:
#+begin_example
LIKWID-PERFCTR(1)           General Commands Manual          LIKWID-PERFCTR(1)

NAME
       likwid-perfctr  -  configure and read out hardware performance counters
       on x86 CPUs

SYNOPSIS
       likwid-perfctr [-vhHmaief] [-c  core_list]  [-C  core_list_for_pinning]
       [-g  performance_group  or  performance_event_string] [-t timeline_fre‐
       quency] [-S monitoring_time] [-T group_switch_frequency] [-V verbosity]
       [-M access_mode] [-o output_file] [-s skip_mask] [-E search_str]

DESCRIPTION
       likwid-perfctr  is  a lightweight command line application to configure
       and read out hardware performance monitoring data on supported x86 pro‐
       cessors. It can measure either as wrapper without changing the measured
       application or with marker API functions inside the  code,  which  will
       turn  on  and  off  the  counters.  There are preconfigured performance
       groups with useful event sets and derived metrics. Additionally,  arbi‐
       trary events can be measured with custom event sets. The marker API can
       measure multiple named regions and the  results  are  accumulated  over
       multiple region calls.

OPTIONS
       -v, --version
              prints version information to standard output, then exits.

       -h, --help
              prints a help message to standard output, then exits.

       -H     prints group help message (use together with -g switch).

       -V <level>, --verbose <level>
              verbose  output  during  execution  for  debugging.  0  for only
              errors, 1 for informational output, 2 for detailed output and  3
              for developer output

       -m     run in marker API mode

       -a     print  available  performance groups for current processor, then
              exit.

       -e     print available counters and performance events of current  pro‐
              cessor.

       -o, --output <filename>
              store  all  output to a file instead of stdout. For the filename
              the following placeholders are supported: %j for  PBS_JOBID,  %r
              for MPI RANK (only Intel MPI at the moment), %h host name and %p
              for process pid.  The placeholders must be separated  by  under‐
              score  as, e.g., -o test_%h_%p. You must specify a suffix to the
              filename. For txt the output is printed as is to the file. Other
              suffixes  trigger a filter on the output.  Available filters are
              csv (comma separated values) and xml at the moment.

       -O     print  output  in  CSV  format  (conform  to   RFC   4180,   see
              https://tools.ietf.org/html/rfc4180 for details).

       -i, --info
              print  cpuid information about processor and about Intel Perfor‐
              mance Monitoring features, then exit.

       -c <cpu expression>
              specify a numerical list of processors.  The  list  may  contain
              multiple  items,  separated  by  comma,  and ranges. For example
              0,3,9-11.

       -C <cpu expression>
              specify a numerical list of processors.  The  list  may  contain
              multiple  items,  separated  by  comma,  and ranges. For example
              0,3,9-11. This variant will also pin the threads to  the  cores.
              Also logical numberings can be used.

       -g, --group <performance group> or <performance event set string>
              specify  which  performance group to measure. This can be one of
              the tags output with the -a flag.  Also a custom event  set  can
              be specified by a comma separated list of events. Each event has
              the format eventId:register with the the register being one of a
              architecture supported performance counter registers.

       -t <frequency of measurements>
              timeline mode for time resolved measurements. The time unit must
              be given on command line, e.g. 4s, 500ms or 900us.

       -S <waittime between measurements>
              End-to-end measurement using likwid-perfctr but sleep instead of
              executing an application. The time unit must be given on command
              line, e.g. 4s, 500ms or 900us.

       -T <time between group switches>
              Frequency to switch groups if multiple are given on commandline,
              default  is  2s.  Value  is  ignored  for a single event set and
              default frequency of 30s is used to catch  overflows.  The  time
              unit must be given on command line, e.g. 4s, 500ms or 900us.

       -s, --skip <mask>
              Specify  skip  mask  as  HEX number. For each set bit the corre‐
              sponding thread is skipped.

       -f, --force
              Force writing of registers even if they are in use.

       -E <search_str>
              Print  only   events   and   corresponding   counters   matching
              <search_str>

EXAMPLE
       Because  likwid-perfctr  measures on processors and not single applica‐
       tions it is necessary to ensure that processes and threads  are  pinned
       to  dedicated resources. You can either pin the application yourself or
       use the builtin pin functionality.

       1.  As wrapper with performance group:

       likwid-perfctr -C 0-2 -g TLB ./cacheBench -n 2 -l  1048576  -i  100  -t
       Stream

       The  parent  process  is pinned to processor 0, Thread 0 to processor 1
       and Thread 1 to processor 2.

       2.  As wrapper with custom event set on AMD:

       likwid-perfctr          -C          0-4           -g           INSTRUC‐
       TIONS_RETIRED_SSE:PMC0,CPU_CLOCKS_UNHALTED:PMC3 ./cacheBench

       It  is specified that the event INSTRUCTIONS_RETIRED_SSE is measured on
       counter PMC0 and the event CPU_CLOCKS_UNHALTED on counter PMC3.  It  is
       possible   calculate   the  run  time  of  all  threads  based  on  the
       CPU_CLOCKS_UNHALTED event. If you want this you have  to  include  this
       event in your custom event string as shown above.

       3.  As wrapper with custom event set on Intel:

       likwid-perfctr                  -C                 0                 -g
       INSTR_RETIRED_ANY:FIXC0,CPU_CLK_UNHALTED_CORE:FIXC1,UNC_L3_LINES_IN_ANY:UPMC0
       ./stream-icc

       On  Intel  processors  fixed events are measured on dedicated counters.
       These are INSTR_RETIRED_ANY and CPU_CLK_UNHALTED_CORE.  If you  config‐
       ure  these  fixed  counters, likwid-perfctr will calculate the run time
       and CPI metrics for your run.

       4.  Using the marker API to measure only parts of your code  (this  can
           be used both with groups or custom event sets):

       likwid-perfctr        -m        -C        0-4        -g        INSTRUC‐
       TIONS_RETIRED_SSE:PMC0,CPU_CLOCKS_UNHALTED:PMC3 ./cacheBench

       You have to link you code against liblikwid.so and use the  marker  API
       calls.   Examples  can  be  found  in  examples  folder /usr/share/lik‐
       wid/examples.  The following code snippet shows the necessary calls:

       #include <likwid.h>

       /* only one thread calls init */
       LIKWID_MARKER_INIT;

       /* Must be called by each thread the should
        * perform measurements.
        * If you place it in the same parallel
        * region as LIKWID_MARKER_START, perform a
        * barrier between the statements to avoid
        * timing problems.
        */
       LIKWID_MARKER_THREADINIT;

       /* If you run the code region only once, register
        * the region tag previously to reduce the overhead
        * of START and STOP calls. Call it once for each
        * thread in parallel environment.
        * Note: No whitespace characters are allowed in the region tags
        * This call is optional, START will do the same operations.
        */
       LIKWID_MARKER_REGISTER("name");

       /* Start measurement
        * Note: No whitespace characters are allowed in the region tags
        */
       LIKWID_MARKER_START("name");
       /*
        * Your code to be measured is here
        * You can also nest named regions
        * No whitespaces are allowed in the region names!
        */
       LIKWID_MARKER_STOP("name");

       /* If you want to measure multiple groups/event sets
        * Switches through groups in round-robin fashion
        */
       LIKWID_MARKER_SWITCH;

       /* Finally */
       LIKWID_MARKER_CLOSE;

       5.  Using likwid in timeline mode:

       likwid-perfctr -c 0-3 -g FLOPS_DP -t 300ms ./cacheBench > out.txt

       This will read out the counters every 300ms on physical cores  0-3  and
       write  the  results  to  out.txt.  The application is not pinned to the
       CPUs. The output syntax of the timeline mode is for custom event sets:

       <groupID>      <numberOfEvents>      <numberOfThreads>      <Timestamp>
       <Event1_Thread1>     <Event2_Thread1>    ...    <Event1_Thread2>    ...
       <EventN_ThreadM>

       For performance groups with metrics: <groupID> <numberOfMetrics>  <num‐
       berOfThreads> <Timestamp> <Metric1_Thread1> <Metric2_Thread1> ... <Met‐
       ric1_Thread2> ...<MetricN_ThreadM>

       For timeline mode there is a frontend application  likwid-perfscope(1),
       which  enables  live  plotting of selected events. Please be aware that
       with high frequencies (<100ms), the values differ from the real results
       but the behavior of them is valid.

       6.  Using likwid in stethoscope mode:

       likwid-perfctr -c 0-3 -g FLOPS_DP -S 2s

       This  will  start  the  counters and read them out after 2s on physical
       cores 0-3 and write the results to stdout.

       7.  Using likwid with counter options:

       likwid-perfctr -c S0:1@S1:1 -g  LLC_LOOKUPS_DATA_READ:CBOX0C0:STATE=0x9
       ./cacheBench

       This  will  program the counter CBOX0C0 (the counter 0 of the LLC cache
       box 0) to measure the event LLC_LOOKUPS_DATA_READ and filter the incre‐
       ments  by the state of a cacheline.  STATE=0x9 for this event means all
       <invalid> and <modified> cachelines.  Which  options  are  allowed  for
       which  box is listed in LIKWID's html documentation. The values for the
       options can be found in the vendors performance  monitoring  documenta‐
       tions.  Likwid  measures the first CPU of socket 0 and the first CPU of
       socket 1. See likwid-pin(1) for details regarding the cpu  expressions.
       For  more  code  examples have a look at the likwid WIKI pages and LIK‐
       WID's html documentation.

AUTHOR
       Written by Thomas Roehl <thomas.roehl@googlemail.com>.

BUGS
       Report Bugs on <https://github.com/RRZE-HPC/likwid/issues>.

SEE ALSO
       likwid-topology(1), likwid-perfscope(1), likwid-pin(1), likwid-bench(1)

likwid-4                          19.05.2016                 LIKWID-PERFCTR(1)
#+end_example

Especially this part where it talks about timeline mode:

#+BEGIN_EXAMPLE
   5.  Using likwid in timeline mode:

       likwid-perfctr -c 0-3 -g FLOPS_DP -t 300ms ./cacheBench > out.txt

       This will read out the counters every 300ms on physical cores  0-3  and
       write  the  results  to  out.txt.  The application is not pinned to the
       CPUs. The output syntax of the timeline mode is for custom event sets:

       <groupID>      <numberOfEvents>      <numberOfThreads>      <Timestamp>
       <Event1_Thread1>     <Event2_Thread1>    ...    <Event1_Thread2>    ...
       <EventN_ThreadM>

       For performance groups with metrics: <groupID> <numberOfMetrics>  <num‐
       berOfThreads> <Timestamp> <Metric1_Thread1> <Metric2_Thread1> ... <Met‐
       ric1_Thread2> ...<MetricN_ThreadM>

       For timeline mode there is a frontend application  likwid-perfscope(1),
       which  enables  live  plotting of selected events. Please be aware that
       with high frequencies (<100ms), the values differ from the real results
       but the behavior of them is valid.
#+END_EXAMPLE

Note that there are two types of output. When you use custom event
sets), the second field is numberOfEvents. When you use performance
groups with metrics (which is your case), the second field is
numberOfMetrics. That gives us a nice headstart. Notes:

- The line with CORE should be ignored
- In the last lines we have the description of each field. The problem
  is that these lines do not match the number of fields in all
  remaining measurements lines. It looks like that these three fields:
  #+BEGIN_EXAMPLE
  <groupID> <numberOfMetrics>  <numberOfThreads> 
  #+END_EXAMPLE
  are part of each measurement line but they are not part of the
  description line with the headers. So I should append to the
  description line these three field descriptions in order to have a
  correct CSV header.

Considering these notes, let's do it:

#+begin_src sh :results output
FILE=benchmarks/NAS-OMP/log_NASExp1/saidaUa_1.log
pwd
ls -hl $FILE
#preparing the header
cat $FILE | grep timeStamp | head -n1
#+end_src

#+RESULTS:
: /home/schnorr/svn/gabriel/dissertacao_gbmoro
: -rw-r--r-- 1 schnorr schnorr 1.4M Aug 14 00:51 benchmarks/NAS-OMP/log_NASExp1/saidaUa_1.log

That's weird. That particular file I took randomly do not have the
header. Where the header comes from? Let's check which files have
them:

#+begin_src sh :results output
DIR=benchmarks/NAS-OMP/log_NASExp1/
for i in $DIR/*_1*; do
  echo $i
  cat $i | grep timeStamp  | wc -l
done
#+end_src

#+RESULTS:
#+begin_example
benchmarks/NAS-OMP/log_NASExp1//saidaBt_1.log
3
benchmarks/NAS-OMP/log_NASExp1//saidaCg_1.log
0
benchmarks/NAS-OMP/log_NASExp1//saidaFt_1.log
0
benchmarks/NAS-OMP/log_NASExp1//saidaLu_1.log
0
benchmarks/NAS-OMP/log_NASExp1//saidaSp_1.log
0
benchmarks/NAS-OMP/log_NASExp1//saidaUa_1.log
0
#+end_example

Only the first BT output has those lines. That's pretty weird.

TODO: I should ask Gabriel about this.

Now I am not sure if these files represent the original likwid-perfctr output.

I just found out that it was Gabriel himself that put those lines in
the files. See [[*Análise dos dados][Análise dos dados]]. I should not rely on them since they
are not standard.

I've just found this with a description of the L2CACHE group:
- https://github.com/RRZE-HPC/likwid/blob/master/groups/broadwellD/L2CACHE.txt

Ok, I will not consider that and try to rather do a headerless CSV file

#+begin_src sh :results output
test="lucas will do everything"
while [ -n "$test" ]; do
   echo $test
   test=`echo $test | cut -d" " -f2-`
done
#+end_src

#+begin_src sh :results output
#!/bin/bash
  function usage()
  {
      echo "$0 <likwid timeline log>";
      echo "where <likwid timeline log> is a file obtained with likwid-perfctr -t (timeline mode)";
  }

  FILE=$1
  if [ -z $FILE ]; then
    echo "Error: file has not been provided.";
    usage;
    exit 1;
  fi

  echo "Time Core Metric Value"
  TEMP=`mktemp`
  cat $FILE | grep -v -e CORE -e ^$  > $TEMP
  while read -r line; do
    GROUPID=`echo $line | awk '{ print $1 }'`
    METRICS=`echo $line | awk '{ print $2 }'`
    CORES=`echo $line | awk '{ print $3 }'`
    TIMESTAMP=`echo $line | awk '{ print $4 }'`
    REST=`echo $line | cut -d" " -f5-`    

    METRIC=0
    while [ $METRIC -lt $METRICS ]; do
      CORE=0
      while [  $CORE -lt $CORES ]; do
         VAL=`echo $REST | cut -d" " -f1` #awk '{ print $1 }'`
         echo $TIMESTAMP $CORE M$METRIC $VAL
         REST=`echo $REST | cut -d" " -f2-`
         CORE=`echo "$CORE+1" | bc`
      done
      METRIC=`echo  "$METRIC+1" | bc`   
    done
  done < $TEMP
  rm $TEMP
  exit 0
#+end_src

#+RESULTS:

Tangle this file C-c C-v t

Use such as this:

#+begin_src sh :results output
chmod 755 ./scripts/likwid2csv.sh
/usr/bin/time ./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaLu_1.log  > /tmp/x
#+end_src

#+RESULTS:

The script is rather slow. I'll update it to make it faster.

#+begin_src sh :results output :tangle scripts/likwid2csv.sh
#!/bin/bash
  function usage()
  {
      echo "$0 <likwid timeline log>";
      echo "where <likwid timeline log> is a file obtained with likwid-perfctr -t (timeline mode)";
  }

  FILE=$1
  if [ -z $FILE ]; then
    echo "Error: file has not been provided.";
    usage;
    exit 1;
  fi

  echo "Time Core Metric Value"
  TEMP=`mktemp`
  cat $FILE | grep -v -e CORE -e ^$  > $TEMP
  while read -r line; do
    GROUPID=`echo $line | awk '{ print $1 }'`
    METRICS=`echo $line | awk '{ print $2 }'`
    CORES=`echo $line | awk '{ print $3 }'`
    TIMESTAMP=`echo $line | awk '{ print $4 }'`
    VALS=`mktemp`
    echo $line | cut -d" " -f5- | sed "s/ /\n/g" > $VALS
    REMS=`mktemp`
    for METRIC in `seq 1 $METRICS`; do
      for CORE in `seq 1 $CORES`; do
         echo $TIMESTAMP $CORE M$METRIC
      done
    done > $REMS
    paste -d " " $REMS $VALS
    rm $VALS
    rm $REMS
  done < $TEMP
  rm $TEMP
  exit 0
#+end_src

Let's try out (don't forget to tangle this file C-c C-v t):

#+begin_src sh :results output
chmod 755 ./scripts/likwid2csv.sh
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp1/saidaLu_1.log  > /tmp/x.csv
#+end_src

#+RESULTS:

Here's how to read that with R:

#+begin_src R :results output :session :exports both
df <- read.csv("/tmp/x.csv", sep=" ", strip.white=T);
head(df);
#+end_src

#+RESULTS:
:        Time Core Metric     Value
: 1 0.1006167    1     M1 0.1007972
: 2 0.1006167    2     M1 0.1007972
: 3 0.1006167    3     M1 0.1007972
: 4 0.1006167    4     M1 0.1007972
: 5 0.1006167    5     M1 0.1007972
: 6 0.1006167    6     M1 0.1007972

I'll let you analyze values along time.

Note that metrics names should be replaced by something else.
* [13:46:18; 18.08.2016] Experimento com o benchmark NAS - L3 CACHE                       :Gabriel:
** Definições iniciais

- Primeiramente vou fazer um teste para ver mais ou menos o tempo de
  execução para cada algoritmo, usando =32 threads= (default openmp da
  máquina). 

|-----------+--------------+----------------+--------------|
| Aplicação | Execução (s) | TimeStamp (ms) | Amostras     |
|-----------+--------------+----------------+--------------|
| bt.B      |        37.56 | 100ms          | ~= 37        |
| cg.B      |        18.13 | 50ms           | ~= 36        |
| ep.B      |         3.52 | - Descartado   | - Descartado |
| ft.B      |         8.35 | 30ms           | ~= 27        |
| lu.B      |        34.08 | 100ms          | ~= 34        |
| mg.B      |          3.6 | - Descartado   | - Descartado |
| sp.B      |        83.85 | 225ms          | ~= 37        |
| ua.B      |        40.90 | 110ms          | ~= 37        |
|-----------+--------------+----------------+--------------|

- Na coluna =TimeStamp= e =Amostras= estou propondo uma configuração
  adequada para deixar próximo a quantidade de amostras de acordo com
  o tempo de execução de cada aplicação. O motivo de descartar algumas
  aplicações para o experimento é devido ao seu tempo de execução ser
  inferior a 4 segundos, isso porque na medida que eu defnir um
  =TimeStamp= muito pequeno para coletar as amostras, isso pode afetar
  os valores coletados. A maneira que encontro hoje de evitar isso é
  descartando essas aplicações, mas pretendo investigar como resolver
  tal problemática.

** Script do experimento

#+begin_src sh :results output :exports both :tangle scripts/scriptOfExecutionNAS_expL3.bash
#!bin/bash
rm -rf log_NASExp2
mkdir log_NASExp2

benchpath=/home/aulapinroot/Programs/NPB3.3.1/NPB3.3-OMP/bin

bt_command=$benchpath/bt.B.x
cg_command=$benchpath/cg.B.x
ft_command=$benchpath/ft.B.x
lu_command=$benchpath/lu.B.x
sp_command=$benchpath/sp.B.x
ua_command=$benchpath/ua.B.x

sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L3CACHE $bt_command >> log_NASExp2/saidaBt_2.log 2>> log_NASExp2/saidaBt_1.log 
sudo likwid-perfctr -t 50ms -f -c N:0-31 -g L3CACHE $cg_command >> log_NASExp2/saidaCg_2.log 2>> log_NASExp2/saidaCg_1.log 
sudo likwid-perfctr -t 30ms -f -c N:0-31 -g L3CACHE $ft_command >> log_NASExp2/saidaFt_2.log 2>> log_NASExp2/saidaFt_1.log 
sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L3CACHE $lu_command >> log_NASExp2/saidaLu_2.log 2>> log_NASExp2/saidaLu_1.log 
sudo likwid-perfctr -t 225ms -f -c N:0-31 -g L3CACHE $sp_command >> log_NASExp2/saidaSp_2.log 2>> log_NASExp2/saidaSp_1.log 
sudo likwid-perfctr -t 110ms -f -c N:0-31 -g L3CACHE $ua_command >> log_NASExp2/saidaUa_2.log 2>> log_NASExp2/saidaUa_1.log 

#+end_src

- Execução o FT com 100ms, conforme solicitado pelo professor Lucas.

#+begin_src sh :results output :exports both :tangle scripts/scriptOfExecutionNASDoFT_expl2e3.bash

#!bin/bash
rm -rf log_NASExp2FT
mkdir log_NASExp2FT

benchpath=/home/aulapinroot/Programs/NPB3.3.1/NPB3.3-OMP/bin

ft_command=$benchpath/ft.B.x

sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L3CACHE $ft_command >> log_NASExp2/saidaFt100l3_2.log 2>> log_NASExp2/saidaFt100l3_1.log 

sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L2CACHE $ft_command >> log_NASExp2/saidaFt100l2_2.log 2>> log_NASExp2/saidaFt100l2_1.log 

#+end_src

** Análise dos dados

- Acho que o primeiro passo é tratar os arquivos gerados pelo
  experimento que estão na extensão de =.log= para =.csv=, já formatando o
  arquivo e adicionando o cabeçalho apropriado para facilitar a
  análise utilizando R.

- Os arquivos gerados no experimento estão no diretório
  [[:benchmarks/NAS-OMP/log_NASExp2:]]. Os arquivos que possuem o =_1= são
  os rastros gerados pela ferramenta likwid, já o =_2= são as saídas que
  não fazem parte do rastro.

#+begin_src sh :results output :exports both :tangle scripts/exp2NAS_test.bash
cd benchmarks/NAS-OMP/log_NASExp1/

numberOfCores=32
count=0

tmp="timeStamp"
while [ $count -lt $numberOfCores ]
do
	tmp=$tmp",C'$count'runtime_rdstc,C'$count'runtime_unshall,C'$count'clock,C'$count'cpi,C'$count'l2reqrate,C'$count'l2missrate,C'$count'l2missratio"
	count=$(echo "$count+1" | bc)
done

echo "$tmp" >> btexp2L3CACHEg.csv

cat saidaBt_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> btexp2L3CACHEg.csv

cat btexp2L3CACHEg.csv

mv btexp2L3CACHEg.csv ../dados/
#+end_src

#+RESULTS:
#+begin_example
timeStamp,C'0'runtime_rdstc,C'0'runtime_unshall,C'0'clock,C'0'cpi,C'0'l2reqrate,C'0'l2missrate,C'0'l2missratio,C'1'runtime_rdstc,C'1'runtime_unshall,C'1'clock,C'1'cpi,C'1'l2reqrate,C'1'l2missrate,C'1'l2missratio,C'2'runtime_rdstc,C'2'runtime_unshall,C'2'clock,C'2'cpi,C'2'l2reqrate,C'2'l2missrate,C'2'l2missratio,C'3'runtime_rdstc,C'3'runtime_unshall,C'3'clock,C'3'cpi,C'3'l2reqrate,C'3'l2missrate,C'3'l2missratio,C'4'runtime_rdstc,C'4'runtime_unshall,C'4'clock,C'4'cpi,C'4'l2reqrate,C'4'l2missrate,C'4'l2missratio,C'5'runtime_rdstc,C'5'runtime_unshall,C'5'clock,C'5'cpi,C'5'l2reqrate,C'5'l2missrate,C'5'l2missratio,C'6'runtime_rdstc,C'6'runtime_unshall,C'6'clock,C'6'cpi,C'6'l2reqrate,C'6'l2missrate,C'6'l2missratio,C'7'runtime_rdstc,C'7'runtime_unshall,C'7'clock,C'7'cpi,C'7'l2reqrate,C'7'l2missrate,C'7'l2missratio,C'8'runtime_rdstc,C'8'runtime_unshall,C'8'clock,C'8'cpi,C'8'l2reqrate,C'8'l2missrate,C'8'l2missratio,C'9'runtime_rdstc,C'9'runtime_unshall,C'9'clock,C'9'cpi,C'9'l2reqrate,C'9'l2missrate,C'9'l2missratio,C'10'runtime_rdstc,C'10'runtime_unshall,C'10'clock,C'10'cpi,C'10'l2reqrate,C'10'l2missrate,C'10'l2missratio,C'11'runtime_rdstc,C'11'runtime_unshall,C'11'clock,C'11'cpi,C'11'l2reqrate,C'11'l2missrate,C'11'l2missratio,C'12'runtime_rdstc,C'12'runtime_unshall,C'12'clock,C'12'cpi,C'12'l2reqrate,C'12'l2missrate,C'12'l2missratio,C'13'runtime_rdstc,C'13'runtime_unshall,C'13'clock,C'13'cpi,C'13'l2reqrate,C'13'l2missrate,C'13'l2missratio,C'14'runtime_rdstc,C'14'runtime_unshall,C'14'clock,C'14'cpi,C'14'l2reqrate,C'14'l2missrate,C'14'l2missratio,C'15'runtime_rdstc,C'15'runtime_unshall,C'15'clock,C'15'cpi,C'15'l2reqrate,C'15'l2missrate,C'15'l2missratio,C'16'runtime_rdstc,C'16'runtime_unshall,C'16'clock,C'16'cpi,C'16'l2reqrate,C'16'l2missrate,C'16'l2missratio,C'17'runtime_rdstc,C'17'runtime_unshall,C'17'clock,C'17'cpi,C'17'l2reqrate,C'17'l2missrate,C'17'l2missratio,C'18'runtime_rdstc,C'18'runtime_unshall,C'18'clock,C'18'cpi,C'18'l2reqrate,C'18'l2missrate,C'18'l2missratio,C'19'runtime_rdstc,C'19'runtime_unshall,C'19'clock,C'19'cpi,C'19'l2reqrate,C'19'l2missrate,C'19'l2missratio,C'20'runtime_rdstc,C'20'runtime_unshall,C'20'clock,C'20'cpi,C'20'l2reqrate,C'20'l2missrate,C'20'l2missratio,C'21'runtime_rdstc,C'21'runtime_unshall,C'21'clock,C'21'cpi,C'21'l2reqrate,C'21'l2missrate,C'21'l2missratio,C'22'runtime_rdstc,C'22'runtime_unshall,C'22'clock,C'22'cpi,C'22'l2reqrate,C'22'l2missrate,C'22'l2missratio,C'23'runtime_rdstc,C'23'runtime_unshall,C'23'clock,C'23'cpi,C'23'l2reqrate,C'23'l2missrate,C'23'l2missratio,C'24'runtime_rdstc,C'24'runtime_unshall,C'24'clock,C'24'cpi,C'24'l2reqrate,C'24'l2missrate,C'24'l2missratio,C'25'runtime_rdstc,C'25'runtime_unshall,C'25'clock,C'25'cpi,C'25'l2reqrate,C'25'l2missrate,C'25'l2missratio,C'26'runtime_rdstc,C'26'runtime_unshall,C'26'clock,C'26'cpi,C'26'l2reqrate,C'26'l2missrate,C'26'l2missratio,C'27'runtime_rdstc,C'27'runtime_unshall,C'27'clock,C'27'cpi,C'27'l2reqrate,C'27'l2missrate,C'27'l2missratio,C'28'runtime_rdstc,C'28'runtime_unshall,C'28'clock,C'28'cpi,C'28'l2reqrate,C'28'l2missrate,C'28'l2missratio,C'29'runtime_rdstc,C'29'runtime_unshall,C'29'clock,C'29'cpi,C'29'l2reqrate,C'29'l2missrate,C'29'l2missratio,C'30'runtime_rdstc,C'30'runtime_unshall,C'30'clock,C'30'cpi,C'30'l2reqrate,C'30'l2missrate,C'30'l2missratio,C'31'runtime_rdstc,C'31'runtime_unshall,C'31'clock,C'31'cpi,C'31'l2reqrate,C'31'l2missrate,C'31'l2missratio
0.10093558788872,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.10112607540561,0.078669250968433,0.061730678505742,0.06812005584327,0.0842342805691,0.029186527697428,0.043639749416139,0.064533694611705,0.049827747707227,0.077229596561942,0.056916491942482,0.064462121917493,0.06978676036586,0.039682751178853,0.053260176521097,0.060669666626694,0.061107531314836,0.081091103040111,0.084310360275542,0.089570930050059,0.088598344910957,0.075744063030957,0.071260555864994,0.070168528901787,0.06912742907677,0.090558811730669,0.079545640346509,0.08952201191732,0.091951127008706,0.076420834867373,0.02561146449652,0.040553241040921,0.027881183155385,2406.0595569703,2399.9940707962,2406.9960856887,2405.6520813749,2400.0714850418,2399.9947525202,2407.3830192521,2399.9888877798,2399.9935808462,2399.9930448638,2399.9912165187,2400.0395373504,2399.9941831342,2399.9956505865,2399.9948326069,2399.9941749309,2405.867401282,2400.011008724,2405.3117987948,2405.3711138561,2399.9927746907,2399.9916857807,2406.7859675129,2400
...

#+end_example

- O próximo passo é fazer filtrar os demais arquivos obtidos no
  experimento com o benchmark NAS.
  
#+begin_src sh :results output :exports both :tangle scripts/scriptOfFilterNAS_L3.bash

cd benchmarks/NAS-OMP/log_NASExp1/

numberOfCores=32

count=0

tmp="timeStamp"
while [ $count -lt $numberOfCores ]
do
	tmp=$tmp",C'$count'runtime_rdstc,C'$count'runtime_unshall,C'$count'clock,C'$count'cpi,C'$count'l2reqrate,C'$count'l2missrate,C'$count'l2missratio"
	count=$(echo "$count+1" | bc)
done

echo "$tmp" >> cgexp2L3CACHEg.csv
echo "$tmp" >> ftexp2L2CACHEg.csv
echo "$tmp" >> luexp2L3CACHEg.csv
echo "$tmp" >> spexp2L3CACHEg.csv
echo "$tmp" >> uaexp2L3CACHEg.csv

cat saidaCg_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> cgexp2L3CACHEg.csv
cat saidaFt_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> ftexp2L3CACHEg.csv
cat saidaLu_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> luexp2L3CACHEg.csv
cat saidaSp_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> spexp2L3CACHEg.csv
cat saidaUa_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> uaexp2L3CACHEg.csv


mv *.csv ../../../dados/
#+end_src

#+RESULTS:

- Todos os =.csv= do experimento foram gerados.

- Utilizando o script que o professor Lucas desenvolveu vou testar
  para as aplicações do benchmark NAS, começando pelo bt.


#+begin_src sh :results output
chmod 755 ./scripts/likwid2csv.sh
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2/saidaCg_1.log  > dados/exp2_NASandLikwid/cgB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2/saidaFt_1.log  > dados/exp2_NASandLikwid/ftB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2/saidaLu_1.log  > dados/exp2_NASandLikwid/luB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2/saidaSp_1.log  > dados/exp2_NASandLikwid/spB.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2/saidaUa_1.log  > dados/exp2_NASandLikwid/uaB.csv

cd dados/exp2_NASandLikwid/
ls
#+end_src

#+RESULTS:
: cgB.csv
: extraction1
: ftB.csv
: luB.csv
: spB.csv
: uaB.csv
*** Plotando os gráficos para análise

A métrica utilizada para gerar os gráficos é a =M7=, essa métrica
apresenta a taxa de misses no segundo nível de cache L3 para cada
processador, esse valor é apresentado como porcentagem.

#+BEGIN_EXAMPLE
l3missrate = l3missrequests/totalOfInstructions
M7 = l2missrate

if M7 => min(M7_total) and M7 < mean(M7_total) then
		the region is memory-bound;
else
		the region is not memory-bound;
#+END_EXAMPLE


- No =eixo y= de cada gráfico é possível visualizar a porcentagem de
  cache misses na L3 de cada processador analisado, como a =beagle1=,
  plataforma na qual o experimento foi executado possui cerca de =32
  cores= é possível visualizar nos arquivos gerados 32 gráficos
  respectivos de cada core, apresentando o comportamento da
  aplicação. Já no =eixo x= é apresentado a frequência das amostras
  realizadas (=time stamp=).

- É possível visualizar também nos gráficos uma linha vermelha que é
  calculada pela média de cache misses total (cache
  L3). Possibilitando uma análise comparativa com as demais regiões da
  aplicação.

**** Aplicação CG

#+begin_src R :results output graphics :file "imagens/cgBNas_Analise_exp2.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp2_NASandLikwid/cgB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);
#+end_src

#+RESULTS:
[[file:imagens/cgBNas_Analise_exp2.pdf]]

- Em todos os cores podemos visualizar picos que ocorrem em
  determinados pontos, diferentes desses picos não é encontrado
  ocorrências considerável de misses na l3, entre os intervalos de 0 e
  0.25 na taxa de cache misses.

**** Aplicação FT

- A aplicação =FT= é a famosa transformada discreta de fourier, só que
  em uma versão de 3 dimensões.

#+begin_src R :results output graphics :file "imagens/ftBNas_Analise_exp2.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp2_NASandLikwid/ftB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/ftBNas_Analise_exp2.pdf]]

- Nesse gráfico podemos visualizar mais índices de miss para o nível
  da l3, os quais ocorrem principalmente no início da execução da
  aplicação, chegando para o caso máximo próximo a 100% de misses para
  l3.


***** Execução com 100ms 

#+begin_src sh :results output :exports both 
chmod 755 ./scripts/likwid2csv.sh
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2FT/saidaFt100l2_1.log  > dados/exp3_NASandLikwid/ftl2.csv
./scripts/likwid2csv.sh ./benchmarks/NAS-OMP/log_NASExp2FT/saidaFt100l3_1.log  > dados/exp3_NASandLikwid/ftl3.csv
#+end_src

**** Aplicação LU

- A aplicação =LU= define o método de Gauss-Seidel para resolver 'n'
  equações lineares com um 'x' que é desconhecido.

#+begin_src R :results output graphics :file "imagens/luBNas_Analise_exp2.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp2_NASandLikwid/luB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/luBNas_Analise_exp2.pdf]]

- Nesse gráfico é possível visualizar que para os cores 1 ao 8, o
  comportamento de misses na l3 é maior que os demais. Outro aspecto
  interessante é o baixo índice de miss, o maior valor encontrado foi
  próximo a 20%. 

**** Aplicação SP

- Essa aplicação resolve o problema chamado =Scalar Penta-diagonal=. 

#+begin_src R :results output graphics :file "imagens/spBNas_Analise_exp2.pdf" :exports both :session *RFib* 
library(dplyr);
df <- read.csv("dados/exp2_NASandLikwid/spB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/spBNas_Analise_exp2.pdf]]

- O interessante desse gráfico é que na maior parte da execução os
  índices de misses se manteram a baixo de 25%, mas em alguns pontos
  ocorreu picos estressantes, os quais ultrapassaram na maior parte
  das vezes os 75% de misses para a l3.

**** Aplicação UA

- Essa aplicação define uma série de cálculos sobre uma malha
  adaptativa desistruturada, o que gera acessos irregulares a memória.


#+begin_src R :results output graphics :file "imagens/uaBNas_Analise_exp2.pdf" :exports both :session *RFib* 

library(dplyr);
df <- read.csv("dados/exp2_NASandLikwid/uaB.csv", sep=" ", strip.white=T);
library(dplyr);
k <-    filter(df, df$Metric=='M7') %>%
		as.data.frame();
k <- 	arrange(k,as.integer(k$Core));

middle <- mean(k$Value);

library(ggplot2);
ggplot(k, aes(x=Time, y=Value,group=Core)) +
  geom_line(color='black',size=0.02) + geom_line(y=as.numeric(middle), color='red',size=0.1) +
	facet_wrap(~Core);

#+end_src

#+RESULTS:
[[file:imagens/uaBNas_Analise_exp2.pdf]]

- Para essa aplicação o maior índice de miss que aplicação chegou foi
  a 30% de misses na l3. Na maioria das vezes o pico de execução
  ocorreu entre a coleta os primeiros 30 segundos. 

* [17:29:08; 18.08.2016] Experimento com o benchmark Graph500 - L2 CACHE e L3 CACHE :Gabriel:
** Instalação da ferramenta

#+begin_src sh :results output :exports both
cd benchmarks/
git clone https://github.com/graph500/graph500
cd graph500
cp make-incs/make.inc-gcc make.inc
sed -i "s/gcc-4.6/gcc/" make.inc
sed -i "s/BUILD_OPENMP = No/BUILD_OPENMP = Yes/" Makefile
make
#+end_src

#+RESULTS:
: gcc -flto -fwhole-program -g -std=c99 -Wall -O3 -march=native -I./generator   seq-list/seq-list.c graph500.c options.c rmat.c kronecker.c verify.c prng.c xalloc.c timer.c generator/splittable_mrg.c generator/graph_generator.c generator/make_graph.c generator/utils.c  -lm -lrt -o seq-list/seq-list
: gcc -flto -fwhole-program -g -std=c99 -Wall -O3 -march=native -I./generator   seq-csr/seq-csr.c graph500.c options.c rmat.c kronecker.c verify.c prng.c xalloc.c timer.c generator/splittable_mrg.c generator/graph_generator.c generator/make_graph.c generator/utils.c  -lm -lrt -o seq-csr/seq-csr
: gcc -flto -fwhole-program -g -std=c99 -Wall -O3 -march=native  -I./generator   make-edgelist.c options.c rmat.c kronecker.c prng.c xalloc.c timer.c generator/splittable_mrg.c generator/graph_generator.c generator/make_graph.c generator/utils.c  -lm -lrt -o make-edgelist
: gcc -flto -fwhole-program -g -std=c99 -Wall -O3 -march=native  -I./generator   omp-csr/omp-csr.c omp-csr/bitmap.h graph500.c options.c rmat.c kronecker.c verify.c prng.c xalloc.c timer.c generator/splittable_mrg.c generator/graph_generator.c generator/make_graph.c generator/utils.c  -lm -lrt -o omp-csr/omp-csr

** Script de experimento

- Executando a aplicação com o parâmetro =-s 25=, a aplicação leva cerca
  de 4 minutos e 48 segundos, o que pode ser compreendido como 5
  minutos aproximadamente. 

#+begin_src sh :results output :exports both :tangle scripts/scriptOfExecutionGraph500_exp.bash
#!bin/bash
rm -rf log_Graph500exp
mkdir log_Graph500exp

benchpath=/home/aulapinroot/Programs/graph500/omp-csr

graph500_command=$benchpath/omp-csr

sudo likwid-perfctr -t 30ms -f -c N:0-31 -g L2CACHE $graph500_command >> log_Graph500exp/saidaGraph500L2_2.log 2>> log_Graph500exp/saidaGraph500L2_1.log 
sudo likwid-perfctr -t 30ms -f -c N:0-31 -g L3CACHE $graph500_command >> log_Graph500exp/saidaGraph500L3_2.log 2>> log_Graph500exp/saidaGraph500L3_1.log 

#+end_src

** Análise dos dados

#+begin_src sh :results output :exports both :tangle scripts/expGraph500_test.bash

cd benchmarks/Graph500/log_Graph500exp/

numberOfCores=32
count=0

tmp="timeStamp"
while [ $count -lt $numberOfCores ]
do
	tmp=$tmp",C'$count'runtime_rdstc,C'$count'runtime_unshall,C'$count'clock,C'$count'cpi,C'$count'l2reqrate,C'$count'l2missrate,C'$count'l2missratio"
	count=$(echo "$count+1" | bc)
done

echo "$tmp" >> graph500L2CACHEg.csv
echo "$tmp" >> graph500L3CACHEg.csv

cat saidaGraph500L2_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >>  graph500L2CACHEg.csv

cat saidaGraph500L3_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >>  graph500L3CACHEg.csv

mv graph500L2CACHEg.csv ../../../dados/
mv graph500L3CACHEg.csv ../../../dados/

#+end_src


#+begin_src sh :results output :exports both :tangle scripts/scriptOfFilterGraph500.bash

cd benchmarks/Graph500/log_Graph500exp/

numberOfCores=32

count=0

tmp="timeStamp"
while [ $count -lt $numberOfCores ]
do
	tmp=$tmp",C'$count'runtime_rdstc,C'$count'runtime_unshall,C'$count'clock,C'$count'cpi,C'$count'l2reqrate,C'$count'l2missrate,C'$count'l2missratio"
	count=$(echo "$count+1" | bc)
done

echo "$tmp" >> graph500L2.csv
echo "$tmp" >> graph500L3.csv

cat saidaGraph500L2_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> graph500L2.csv
cat saidaGraph500L3_1.log | awk ' { for(i=4; i<=NF; i++) printf "%s",$i (i==NF?ORS:OFS) } ' | sed 's/[[:space:]]/,/g' >> graph500L3.csv

mv *.csv ../../../dados/
#+end_src


A métrica utilizada para gerar os gráficos é a =M7=, essa métrica
apresenta a taxa de misses no segundo nível de cache L2 para cada
processador, esse valor é apresentado como porcentagem.

#+BEGIN_EXAMPLE
l2missrate = l2missrequests/totalOfInstructions
M7 = l2missrate

if M7 => min(M7_total) and M7 < mean(M7_total) then
		the region is memory-bound;
else
		the region is not memory-bound;
#+END_EXAMPLE


- No =eixo y= de cada gráfico é possível visualizar a porcentagem de
  cache misses na L2 e L3 de cada processador analisado, como a =beagle1=,
  plataforma na qual o experimento foi executado possui cerca de =32
  cores= é possível visualizar nos arquivos gerados 32 gráficos
  respectivos de cada core, apresentando o comportamento da
  aplicação. Já no =eixo x= é apresentado a frequência das amostras
  realizadas (=time stamp=).

- É possível visualizar também nos gráficos uma linha vermelha que é
  calculada pela média de cache misses total (cache
  L2 e L3). Possibilitando uma análise comparativa com as demais regiões da
  aplicação.

*** Novo experimento com 100ms

#+begin_src sh :results output :exports both
./scripts/likwid2csv.sh ./benchmarks/Graph500/log_Graph500exp2/saidaGraph500L2_1.log > dados/exp2_graph500/graph500_L2.csv
./scripts/likwid2csv.sh ./benchmarks/Graph500/log_Graph500exp2/saidaGraph500L3_1.log > dados/exp2_graph500/graph500_L3.csv
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
library(dplyr);
df2 <- read.csv("dados/exp2_graph500/graph500_L2.csv", sep=" ", strip.white=T);
df2 <- df2[df2$Metric == "M7", ];
df2$Metric <- "L2";
df3 <- read.csv("dados/exp2_graph500/graph500_L3.csv", sep=" ", strip.white=T);
df3 <- df3[df3$Metric == "M7", ];
df3$Metric <- "L3";
df <- rbind (df2, df3);
df$Application <- "Graph500";
g <- df %>% group_by(Time,Metric,Application) %>% summarize (N=n(), mean=mean(Value)*100) %>% as.data.frame();
head(g);
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union
       Time Metric Application  N      mean
1 0.1005658     L3    Graph500 32 19.134607
2 0.1005688     L2    Graph500 32 21.497577
3 0.2177010     L2    Graph500 32  7.828144
4 0.2202722     L3    Graph500 32  7.829694
5 0.3471098     L2    Graph500 32  8.558492
6 0.3497140     L3    Graph500 32  8.669937
#+end_example

#+begin_src R :results output graphics :file imagens/exp2_graph500.pdf :exports both :session
library(ggplot2);
ggplot(g, aes(x=Time, y=mean,color=as.factor(Metric))) +
  	geom_line(size=0.5) + geom_point(size=1) + theme_bw() + ylim(0,50) +  
     theme(legend.position=c(0.9,0.5),
               legend.background = element_rect(fill="gray90", size=.5, linetype="dotted")) + 
     scale_color_discrete(name="Cache Level") + facet_grid(Metric~Application) +
      labs(x = "Runtime (seconds)", y= "Average Cache Misses (%)");
#+end_src

#+RESULTS:
[[file:imagens/exp2_graph500.pdf]]

* 2016-08-20 Take a look at graph500 data

Convert the data

#+begin_src sh :results output
./scripts/likwid2csv.sh ./benchmarks/Graph500/log_Graph500exp/saidaGraph500L2_1.log > dados/exp1_graph500/graph500_L2.csv
./scripts/likwid2csv.sh ./benchmarks/Graph500/log_Graph500exp/saidaGraph500L3_1.log > dados/exp1_graph500/graph500_L3.csv
#+end_src

#+RESULTS:

Read the data, aggregate

#+begin_src R :results output :session :exports both
library(dplyr);
df2 <- read.csv("dados/exp1_graph500/graph500_L2.csv", sep=" ", strip.white=T);
df2 <- df2[df2$Metric == "M7", ];
df2$Metric <- "L2";
df3 <- read.csv("dados/exp1_graph500/graph500_L3.csv", sep=" ", strip.white=T);
df3 <- df3[df3$Metric == "M7", ];
df3$Metric <- "L3";
df <- rbind (df2, df3);
df$Application <- "Graph500";
g <- df %>% group_by(Time,Metric,Application) %>% summarize (N=n(), mean=mean(Value)*100) %>% as.data.frame();
head(g);
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union
        Time Metric Application  N       mean
1 0.05056907     L3    Graph500 32  4.7365908
2 0.05057705     L2    Graph500 32  8.8282538
3 0.11702327     L2    Graph500 32 11.3548215
4 0.11772690     L3    Graph500 32  0.2876260
5 0.18278533     L2    Graph500 32 13.6554586
6 0.18569630     L3    Graph500 32  0.1767422
#+end_example

#+begin_src R :results output graphics :file imagens/exp1_graph500.pdf :exports both :session
library(ggplot2);
ggplot(g, aes(x=Time, y=mean,color=as.factor(Metric))) +
  	geom_line(size=0.5) + geom_point(size=1) + theme_bw() + ylim(0,50) +  
     theme(legend.position=c(0.9,0.5),
               legend.background = element_rect(fill="gray90", size=.5, linetype="dotted")) + 
     scale_color_discrete(name="Cache Level") + facet_grid(Metric~Application) +
      labs(x = "Runtime (seconds)", y= "Average Cache Misses (%)");
#+end_src

#+RESULTS:
[[file:imagens/exp1_graph500.pdf]]


Let's zoom in

#+begin_src R :results output graphics :file imagens/exp1_graph500zoom.pdf :exports both :session
library(ggplot2);
x = 120
ggplot(g[g$Time < x & g$Time > x-25,], aes(x=Time, y=mean,color=as.factor(Metric))) +
  	geom_line(size=0.5) + geom_point(size=1) + theme_bw() + ylim(0,50) +  
     theme(legend.position=c(0.9,0.5),
               legend.background = element_rect(fill="gray90", size=.5, linetype="dotted")) + 
     scale_color_discrete(name="Cache Level") + facet_grid(Metric~Application) +
      labs(x = "Runtime (seconds)", y= "Average Cache Misses (%)");
#+end_src

#+RESULTS:
[[file:imagens/exp1_graph500zoom.pdf]]

Looks like there is a correlation between L2 and L3 miss rates at
regular intervals. They are not completely synchronized probably
because metrics are taken in two executions. We can also consider that
executions are synchronized (same machine, similar execution time). If
so, an increase in L3 miss rate generates L2 misses just after.  

Note: Change *x* in the previous code block to see other timeslices.

* [10:22:46; 28.09.2016] Avaliando o Overhead da técnica com e sem likwid :Gabriel:
** Avaliando o Overhead do uso da ferramenta Likwid - Com vs Sem

- Projeto do Experimento:

#+begin_src R :results output :session *RpjectD* :exports both 
require(DoE.base);
  exp4NASDesign <- fac.design (
           nfactors=2,
           replications=20,
           repeat.only=FALSE,
           blocks=1,
           randomize=TRUE,
           seed=10373,
           nlevels=c(3,3),
           factor.names=list(
		      versions=c("ft.B","cg.B","lu.B"),
                threads=c(1,16,32)));                

  export.design(exp4NASDesign,
                path=".",
                filename=NULL,
                type="csv",
                replace=TRUE,
                response.names=c("timeWithoutLikwid", "timeWithLikwid"));
#+end_src

#+RESULTS:
#+begin_example
Loading required package: DoE.base
Loading required package: grid
Loading required package: conf.design

Attaching package: ‘DoE.base’

The following objects are masked from ‘package:stats’:

    aov, lm

The following object is masked from ‘package:graphics’:

    plot.design

The following object is masked from ‘package:base’:

    lengths
 creating full factorial with 9 runs ...
#+end_example

- Script de execução:

#+begin_src sh :results output :exports both :tangle scripts/exp4Script.bash
#!bin/bash

nameFile="../dados/exp4NAS_semlikwid/exp4NASDesign.csv"
pathOfApps="/home/aulapinroot/NPB3.0/NPB3.0-OMP/bin"

outputFile="../dados/exp4NAS_semlikwid/ResultExp4.csv"

ref=$(cat $nameFile)

tmp=""

i=0

for row in ${ref[@]}; do
   if [ $i -gt 0 ]; then		
	   name=$(echo "$row" | cut -d ',' -f1)
	   runId=$(echo "$row" | cut -d ',' -f2)
         runNumber=$(echo "$row" | cut -d ',' -f3)
	   runStd=$(echo "$row" | cut -d ',' -f4)
	   versions=$(echo "$row" | cut -d ',' -f5 | sed 's/"//g')
	   threads=$(echo "$row" | cut -d ',' -f6 | sed 's/"//g')

	   export OMP_NUM_THREADS=$threads

	   timeWithoutLikwid=$("$pathOfApps/$versions" | grep -i "Time in seconds" | sed 's/[[:space:]]//g' | sed 's/[a-zA-Z=]//g')
	   timeWithLikwid=$(sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L2CACHE "$pathOfApps/$versions" | grep -i "Time in seconds" | sed 's/[[:space:]]//g' | sed 's/[a-zA-Z=]//g')

	   echo "$name,$runId,$runNumber,$runStd,$versions,$threads,$timeWithoutLikwid,$timeWithLikwid" >> $outputFile
	else
		echo $row >> $outputFile
		let i=$i+1
	fi
done

#+end_src

- Análise dos dados

#+begin_src R :results output :session *R* :exports both
library(dplyr);

df <- read.csv("dados/exp4NAS_semlikwid/ResultExp4.csv");
k <- df %>% select(versions, threads, timeWithoutLikwid, timeWithLikwid) %>%
     group_by(versions, threads) %>%
     summarize(N=n(), mean_without_likwid=mean(timeWithoutLikwid), mean_with_likwid=mean(timeWithLikwid)) %>%
     as.data.frame();

k

#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union
  versions threads  N mean_without_likwid mean_with_likwid
1     cg.B       1 20            109.0950          25.8635
2     cg.B      16 20             24.1955          27.0245
3     cg.B      32 20             24.2685          26.6355
4     ft.B       1 20             70.5655           7.8795
5     ft.B      16 20              9.7140           7.8600
6     ft.B      32 20              7.6020           7.8775
7     lu.B       1 20            211.2140          39.6720
8     lu.B      16 20             35.7505          37.6735
9     lu.B      32 20             35.7120          38.1885
#+end_example

- Que estranho esses resultados, por exemplo para uma thread com
  likwid é mais rápido do que sem, não entendi. Depois com 16 threads
  e 32 threads para aplicação cg e lu faz sentido. Com 1 thread e 16
  threads para aplicação ft também ocorre esse comportamento estranho
  novamente.

- Vou analisar o overhead apenas para as aplicações lu e cg para 16 e
  32 threads, pois esses dados são os que realmente fazem sentido.

#+begin_src R :results output :session *R* :exports both

library(dplyr);

df <- read.csv("dados/exp4NAS_semlikwid/ResultExp4.csv");
k <- df %>% select(versions, threads, timeWithoutLikwid, timeWithLikwid) %>%
     group_by(versions, threads) %>%
     summarize(N=n(), mean_without_likwid=mean(timeWithoutLikwid), mean_with_likwid=mean(timeWithLikwid)) %>%
     as.data.frame();

#k <- k[k$versions!="ft.B",]
k <- k[k$threads!=1,]

k$overhead <- k$mean_without_likwid / k$mean_with_likwid
overheadMed <- mean(k$overhead)
overheadMed
#+end_src

#+RESULTS:
#+begin_example

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union
[1] 0.9819104
#+end_example

- O uso da ferramenta likwid-perfctr é de 0,98% sobre o tempo de
  execução. O que demonstra um ponto positivo, baixo overhead da
  técnica.


#+begin_src R :results output graphics :file imagens/exp_comESemLikwid.pdf :exports both :session

library(dplyr);

df <- read.csv("dados/exp4NAS_semlikwid/ResultExp4.csv");
k <- df %>% select(versions, threads, timeWithoutLikwid, timeWithLikwid) %>%
     group_by(versions, threads) %>%
     summarize(N=n(), mean_without_likwid=mean(timeWithoutLikwid), mean_with_likwid=mean(timeWithLikwid)) %>%
     as.data.frame();

#tirando a coluna de uma thread, para ficar melhor de visualizar o gráfico
k <- k[k$threads!=1,]


library(ggplot2);
ggplot(k, aes(x=as.factor(threads))) +
   theme_bw() +
   geom_point(aes(y=mean_without_likwid, group=versions), color="blue") + 
   geom_point(aes(y=mean_with_likwid, group=versions), color="red") + 
   ylab("Tempo de Execução (s)") + 
   xlab("Número de Threads") + 
   facet_wrap(~versions,ncol=1);
#+end_src

#+RESULTS:
[[file:imagens/exp_comESemLikwid.pdf]]


- No gráfico podemos ver um comportamento estranho para a aplicação
  FT, quando ela é executada com 16 threads, ocorre que o tempo de
  execução com likwid é maior do que sem a ferramenta. Isso não
  procede, porque a instrumentação gera um overhead de tempo, por mais
  pequeno que seja.

** Avaliando o Overhead de diferentes frequências 

- Vou definir o projeto do experimento a fim de verificar o problema
  que ocorreu no experimento anterior para a aplicação FT e também
  para visualizarmos como o overhead se comporta quando analisamos
  diferentes frequências, as quais classificamos como:

#+BEGIN_EXAMPLE
Frequências de amostragem em milisegundos:

-> 50: baixa
-> 100: média
-> 150: média alta
-> 200: alta


-> Quanto maior a frequência menos amostras de traço serão obtidas
-> Para mesma frequência e diferentes aplicações, diferentes 
quantidades de amostras serão obtidas.

#+END_EXAMPLE

#+begin_src R :results output :session *RpjectD* :exports both 
require(DoE.base);
  exp5NASDesign_overhead <- fac.design (
           nfactors=4,
           replications=30,
           repeat.only=FALSE,
           blocks=1,
           randomize=TRUE,
           seed=10373,
           nlevels=c(3,5,4,2),
           factor.names=list(
		      	versions=c("ft.B","cg.B","lu.B"),
			threads=c(1,8,16,24,32),
			sampling=c(50,100,150,200),
			use=c("com","sem")));                

  export.design(exp5NASDesign_overhead,
                path=".",
                filename=NULL,
                type="csv",
                replace=TRUE,
                response.names=c("tempo"));
#+end_src

#+RESULTS:
#+begin_example
Loading required package: DoE.base
Loading required package: grid
Loading required package: conf.design

Attaching package: ‘DoE.base’

The following objects are masked from ‘package:stats’:

    aov, lm

The following object is masked from ‘package:graphics’:

    plot.design

The following object is masked from ‘package:base’:

    lengths
 creating full factorial with 120 runs ...
#+end_example

- Script de execução:

#+begin_src sh :results output :exports both :tangle scripts/exp5Script_overhead.bash
#!bin/bash

nameFile="../dados/exp5NAS_overhead/exp5NASDesign_overhead.csv"
pathOfApps="/home/aulapinroot/NPB3.0/NPB3.0-OMP/bin"

outputFile="../dados/exp5NAS_overhead/ResultExp5_overhead.csv"

ref=$(cat $nameFile)

tmp=""

i=0

for row in ${ref[@]}; do
   if [ $i -gt 0 ]; then		
	   name=$(echo "$row" | cut -d ',' -f1)
	   runId=$(echo "$row" | cut -d ',' -f2)
       runNumber=$(echo "$row" | cut -d ',' -f3)
	   runStd=$(echo "$row" | cut -d ',' -f4)
	   versions=$(echo "$row" | cut -d ',' -f5 | sed 's/"//g')
	   threads=$(echo "$row" | cut -d ',' -f6 | sed 's/"//g')
	   sampling=$(echo "$row" | cut -d ',' -f7 | sed 's/"//g')
	   use=$(echo "$row" | cut -d ',' -f8 | sed 's/"//g')

	   export OMP_NUM_THREADS=$threads

	   if [ $user='com' ]; then 
		timeSeconds=$(sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L2CACHE "$pathOfApps/$versions" | grep -i "Time in seconds" | sed 's/[[:space:]]//g' | sed 's/[a-zA-Z=]//g')
	   else
		timeSeconds=$("$pathOfApps/$versions" | grep -i "Time in seconds" | sed 's/[[:space:]]//g' | sed 's/[a-zA-Z=]//g')
	   fi	   	

	   echo "$name,$runId,$runNumber,$runStd,$versions,$threads,$sampling,$use,$timeSeconds" >> $outputFile
	else
		echo $row >> $outputFile
		let i=$i+1
	fi
done

#+end_src


#+begin_src R :results output :session *R* :exports both
library(dplyr)
df <- read.csv("dados/exp5NAS_overhead/ResultExp5_overhead.csv");
k <- df %>% select(versions, threads, sampling, use, tempo) %>%
     group_by(versions, threads, use, sampling) %>%
     summarize(mean=mean(tempo), se=3*sd(tempo)/sqrt(n())) %>%
     as.data.frame();

sem <- k[k$use!='com',]
com <- k[k$use!='sem',]

k$overhead <- sem$mean / com$mean;


#max <- max(k$overhead);
#max <- as.numeric(max);
#k <- k[k$overhead==max,];

#min <- min(k$overhead);
#min <- as.numeric(min);
#k <- k[k$overhead==min,];

mean <- mean(k$overhead);
mean
#+end_src

#+RESULTS:
: [1] 0.9947122


#+begin_src R :results output graphics :file "imagens/exp5Overhead.pdf" :exports both :session *mmexp2* 
library(dplyr);
library(ggplot2);

df <- read.csv("dados/exp5NAS_overhead/ResultExp5_overhead.csv");
k <- df %>% select(versions, threads, sampling, use, tempo) %>%
     group_by(versions, threads,  use, sampling) %>%
     summarize(mean=mean(tempo), se=3*sd(tempo)/sqrt(n())) %>%
     as.data.frame();

sem <- k[k$use!='com',]
com <- k[k$use!='sem',]

k$overhead <- sem$mean / com$mean;
#k <- k[k$sampling!=150 & k$sampling!=100,]

ggplot(k, aes(x=as.factor(threads), y=overhead, 
fill=as.factor(sampling))) + 
#  labs(fill = sampling) + 
#  geom_line(aes(group=sampling)) + 
geom_bar(stat="identity", position=position_dodge(), width=0.5) + #coord_flip() +
  theme_bw() + ylab("overhead") + xlab("threads") + 
facet_wrap(~versions, ncol=1);

#+end_src

#+RESULTS:
[[file:imagens/exp5Overhead.pdf]]

* TODO [11:25:11; 29.08.2016] Novo Experimento L2Cache e L3Cache na mesma Execução :Gabriel:
- State "TODO"       from              [2016-08-31 Qua 14:01]
** Script do Experimento

- Vamos fazer um novo experimento para o benchmark do NAS, a fim de
  verificar se existe diferença entre uma execução que usa como
  parâmetro =-g L2CACHE e L3CACHE= e duas execuções para cada grupo. A
  hipótese é que alguns valores possam ser obtidos por registradores e
  não contadores de hardware.
  
#+begin_src sh :results output :exports both :tangle scripts/scriptOfExecutionNAS_expL2AndL3.bash
#!bin/bash
rm -rf log_NASExp3
mkdir log_NASExp3

benchpath=/home/aulapinroot/Programs/NPB3.3.1/NPB3.3-OMP/bin

bt_command=$benchpath/bt.B.x
cg_command=$benchpath/cg.B.x
ft_command=$benchpath/ft.B.x
lu_command=$benchpath/lu.B.x
sp_command=$benchpath/sp.B.x
ua_command=$benchpath/ua.B.x

sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L2CACHE -g L3CACHE  $bt_command >> log_NASExp3/saidaBt_2.log 2>> log_NASExp3/saidaBt_1.log 
sudo likwid-perfctr -t 50ms -f -c N:0-31 -g L2CACHE -g L3CACHE $cg_command >> log_NASExp3/saidaCg_2.log 2>> log_NASExp3/saidaCg_1.log 
sudo likwid-perfctr -t 30ms -f -c N:0-31 -g L2CACHE -g L3CACHE $ft_command >> log_NASExp3/saidaFt_2.log 2>> log_NASExp3/saidaFt_1.log 
sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L2CACHE -g L3CACHE $lu_command >> log_NASExp3/saidaLu_2.log 2>> log_NASExp3/saidaLu_1.log 
sudo likwid-perfctr -t 225ms -f -c N:0-31 -g L2CACHE -g L3CACHE $sp_command >> log_NASExp3/saidaSp_2.log 2>> log_NASExp3/saidaSp_1.log 
sudo likwid-perfctr -t 110ms -f -c N:0-31 -g L2CACHE -g L3CACHE $ua_command >> log_NASExp3/saidaUa_2.log 2>> log_NASExp3/saidaUa_1.log 

#+end_src

** Análise dos Dados

- Script para filtrar os dados de acordo com a execução de dois grupos
  de medidas.


#+begin_src sh :results output :exports both

#+end_src


#+begin_src sh :results output
mkdir dados/exp3_NASandLikwid/

chmod 755 ./scripts/likwid3csv.sh
./scripts/likwid3csv ./scripts/log_NASExp3/saidaCg_1.log  > dados/exp3_NASandLikwid/cgB.csv
./scripts/likwid3csv ./scripts/log_NASExp3/saidaFt_1.log  > dados/exp3_NASandLikwid/ftB.csv
./scripts/likwid3csv ./scripts/log_NASExp3/saidaLu_1.log  > dados/exp3_NASandLikwid/luB.csv
./scripts/likwid3csv ./scripts/log_NASExp3/saidaSp_1.log  > dados/exp3_NASandLikwid/spB.csv
./scripts/likwid3csv ./scripts/log_NASExp3/saidaUa_1.log  > dados/exp3_NASandLikwid/uaB.csv

cd dados/exp3_NASandLikwid/
ls
#+end_src

#+RESULTS:
: cgB.csv
: ftB.csv
: luB.csv
: spB.csv
: uaB.csv

* [15:14:37; 05.10.2016] Estudando Dynamic Voltage Frequency Scaling :Gabriel:
- DVFS é um framework que permite alterar a frequência do
  processador, a fim de obter ganhos de desempenho e/ou energia. O
  DVFS geralmente é utilizado com o CPU_Freq que é um framework de
  monitoração, esse framework está no kernel linux e possui papel
  fundamental ao analisar os requisitos do processador, quando é
  necessário realizar a troca de frequência por exemplo. A arquitetura
  do CPU_Freq define dois modos, o primeiro chama-se "Governor", o
  outro "Driver".

	a) Governor
		Realiza a decisão, por exemplo, de qual frequência
           utilizar. Os governors que estão disponíveis no kernel
           linux são:
		- _performance_: configura a frequência estáticamente
                  para obter o melhor desempenho, ou seja, a
                  frequência utilizada aqui é a maior disponível no
                  processador;
		- _powersave_: Configura a frequência estáticamente para
                  a mais baixa disponível, a fim de economizar
                  energia, diminuindo a temperatura do processador;
		- _userspace_: configura a frequência a partir de um
                  programa de usuário;
		- _ondemand_: o ajuste de frequência é realizado de
                  acordo com o uso do processador;
		- _conservative_: ajuste baseado na utilização do
                  processador, utilização mais conservada de
                  frequências, as quais são alteradas em determinadas
                  situações apenas, não em todas.

	b) Driver
		Realiza a ação, baseada na decisão do Governor.


** Comandos Interessantes - Executados em =morocomputer=

- Listando os governors disponíveis:

#+begin_src sh :results output :exports both
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors
#+end_src

#+RESULTS:
: conservative ondemand userspace powersave performance 

- Qual é o governor ativo?

#+begin_src sh :results output :exports both
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
#+end_src

#+RESULTS:
: ondemand

- Qual é a frequência atual do processador?

#+begin_src sh :results output :exports both
sudo cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq
#+end_src

#+RESULTS:
: 1600000

Vale salientar que, a unidade de frequência utilizada aqui é em
=MHz=. Se convertermos para =GHz=, ao invés de 1600000 MHz seria _1600
GHz_. 

- Quais são as frequências disponíveis no meu processador?

#+begin_src sh :results output :exports both
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies
#+end_src

#+RESULTS:
: 2933000 2667000 2400000 2133000 1867000 1600000 
** Organização e Estrutura de Arquivos - Executados em =morocomputer=

#+begin_src sh :results output :exports both
cd /sys/devices/system/cpu/
ls | grep -i cpu
#+end_src

#+RESULTS:
: cpu0
: cpu1
: cpufreq
: cpuidle

- Aqui podemos visualizar duas pastas, uma chamada cpu0 e outra
  chamada cpu1, como eu tenho duas cpus apenas, essas duas pastas
  definem suas configurações básicas. Vamos analisar o governor
  utilizado para a cpu0, depois para a cpu1.

#+begin_src sh :results output :exports both
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
#+end_src

#+RESULTS:
: ondemand

#+begin_src sh :results output :exports both
cat /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor
#+end_src

#+RESULTS:
: ondemand

- O mesmo governor é utilizado, =ondemand=, a fim de obter um ajuste de
  frequência de acordo com o uso do processador.
* [12:40:04; 10.10.2016] Script para instrumentar o código          :Gabriel:

- Eu criei um script em python (está a seguir), esse script tem por
  objetivo instrumentar o código, nesse exemplo fiz uma assinatura em
  cada região paralela do código.

#+begin_src python :results output :exports both
#!/usr/bin/env python3
# -*- coding; utf-8 -*-

#AUTHOR GABRIEL BRONZATTI MORO

import sys

def generateIdsByParallelRegions(fileName):
	fileName = "code.c"
	readBuffer = open(fileName,"r")
	counter = 1
	directive = "#pragma omp parallel for"
	newText=''

	for row in readBuffer:

		if directive in row:
			backup = row
			newLine = "\twarn(\"parallel region: "+ str(counter) + "\"); \n" + backup
			newText = newText + newLine
		else:
			newText = newText + row
		
		counter = counter + 1

	readBuffer.close

	readBuffer = open(fileName, "w")
	readBuffer.write(newText);
	readBuffer.close

generateIdsByParallelRegions(sys.argv[0:])
#+end_src


- Porque isso é importante?
  Após a primeira execução, que podemos chamar de
  pré-execução, as regiões memory-bound são encontradas, como vou
  saber na próxima execução quais partes do programa são mais
  memory-bound do que outras?
	A minha ideia é utilizar uma espécie de instrumentação, a fim
  de avisar ao runtime o momento em que a região memory-bound vai
  ocorrer, assim ele poderá mexer na frequência da plataforma, tudo
  tendo por base os warns que o programa vai disparar, por exemplo:
  "vai iniciar uma região memory-bound", ai o processador já baixa sua
  frequência para otimizar em tal comportamento. Não sei se é uma
  saída boa, visto que temos o atraso do tempo do "warn", mas até
  agora, acho que se conseguirmos primeiramente dessa forma, já é um
  avanço interessante.
* [09:00:04; 11.10.2016] Experimento Teste de Aplicação com Likwid e Script para instrumentação :Gabriel:

- Como já temos um script base para instrumentar o código em python, o
  objetivo desse experimento é executar uma aplicação com likwid e
  marcar no código as regiões memory-bound identificadas. A aplicação
  que vou utilizar como exemplo vai ser o mandelbrot.


#+begin_src sh :results output :exports both
cd src/exp1ComMandelbro
#sudo likwid-perfctr -t 100ms -f -c N:0-31 -g L2CACHE 
#+end_src

#+RESULTS:

* [17:14:04; 21.10.2016] Experimento com Scorep para verificar regiões e cache misses com PAPI :Gabriel:

- O objetivo desse experimento é monitorar a taxa de cache misses para
  a seguinte região de código:

#+BEGIN_EXAMPLE
#pragma omp parallel for private(i,j,k,tmp)
for(i=0; i < size; i++) {
	for(j=0; j < size; j++) {
		for(k=0; k < size; k++) {
			tmp = tmp + A[i * size + k] * B[k * size + j];
		}
		R[i * size + j] = tmp;
	}
}
#+END_EXAMPLE

- Eu realizei três execuções, ambas na beagle1, a primeira execução
  utilizei o número de threads padrão do openmp para a máquina e como
  entrada matrizes de 1000 x 1000. Mas essa execução gerou um trace de
  1.9G. A partir disso, realizei uma nova execução, mas com apenas 2
  threads e com o mesmo tamanho de matriz, mas o tamanho do trace
  ficou praticamente o mesmo. Após isso, realizei a terceira execução,
  utilizando duas threads e matrizes de 200 x 200. Nessa execução
  utilizei os seguintes comandos para tratar o arquivo gerado pelo
  otf2-print.

#+BEGIN_EXAMPLE
inicio=$(cat -n saida.txt | grep -i THREAD_FORK | awk ' { print $1 } ' | bc) #linha aonde inicia o fork
fim=$(cat -n saida.txt | grep -i THREAD_JOIN | awk ' { print $1 } ' | bc) #linha aonde as threads juntam-se
sed -n '$inicio,$fimp' saida.txt >> saidaFiltrada.txt #aqui o tamanho do trace diminuiu drasticamente
sed -i 's/\"*[a-zA-Z][[:space:]]//g' saidaFiltrada.txt
sed -i 's/[\"(),:;<>$!@]//g' saidaFiltrada.txt #removendo caracteres desnecessários
cat saidaFiltrada.txt | awk ' { print $1,$2,$3,$4,$5,$8,$11,$12,$15 } '
#+END_EXAMPLE

#+begin_src sh :results output :exports both
cd dados/traceScorep2threads_200_MM/
echo "statusApp idThread idRegiao activity idActivity Metric1 Valor Metric2 Valor"
cat saidaFiltrada.txt | awk ' { print $1,$2,$3,$4,$5,$8,$11,$12,$15 } '
#+end_src

#+RESULTS:
#+begin_example
statusApp idThread idRegiao activity idActivity Metric1 Valor Metric2 Valor
THREAD_FOR 0 2750384016603318 Model OpenMP RequesteThreads   
THREAD_TEAM_BEGI 0 2750384016916580 ThreaTeam 0    
METRI 0 2750384016935070 Metric 0 PAPI_L2_DCH 815115 PAPI_L2_TCA 2176829
ENTE 0 2750384016935070 Region omparalleMatricesMultiplication.c38    
METRI 0 2750384016944372 Metric 0 PAPI_L2_DCH 815137 PAPI_L2_TCA 2177111
ENTE 0 2750384016944372 Region omfoMatricesMultiplication.c38    
THREAD_TEAM_BEGI 4294967296 2750384017663850 ThreaTeam 0    
METRI 4294967296 2750384017932614 Metric 0 PAPI_L2_DCH 76 PAPI_L2_TCA 584
ENTE 4294967296 2750384017932614 Region omparalleMatricesMultiplication.c38    
METRI 4294967296 2750384017951112 Metric 0 PAPI_L2_DCH 89 PAPI_L2_TCA 886
ENTE 4294967296 2750384017951112 Region omfoMatricesMultiplication.c38    
METRI 0 2750384026709928 Metric 0 PAPI_L2_DCH 827363 PAPI_L2_TCA 2688701
ENTE 0 2750384026709928 Region omimplicibarrieMatricesMultiplication.c47    
METRI 4294967296 2750384027886310 Metric 0 PAPI_L2_DCH 10801 PAPI_L2_TCA 512492
ENTE 4294967296 2750384027886310 Region omimplicibarrieMatricesMultiplication.c47    
METRI 0 2750384027897118 Metric 0 PAPI_L2_DCH 827365 PAPI_L2_TCA 2689019
LEAV 0 2750384027897118 Region omimplicibarrieMatricesMultiplication.c47    
METRI 4294967296 2750384027897858 Metric 0 PAPI_L2_DCH 10804 PAPI_L2_TCA 512839
LEAV 4294967296 2750384027897858 Region omimplicibarrieMatricesMultiplication.c47    
METRI 0 2750384027901040 Metric 0 PAPI_L2_DCH 827369 PAPI_L2_TCA 2689113
LEAV 0 2750384027901040 Region omfoMatricesMultiplication.c38    
METRI 4294967296 2750384027902676 Metric 0 PAPI_L2_DCH 10809 PAPI_L2_TCA 512934
LEAV 4294967296 2750384027902676 Region omfoMatricesMultiplication.c38    
METRI 0 2750384027904196 Metric 0 PAPI_L2_DCH 827373 PAPI_L2_TCA 2689150
LEAV 0 2750384027904196 Region omparalleMatricesMultiplication.c38    
METRI 4294967296 2750384027905848 Metric 0 PAPI_L2_DCH 10811 PAPI_L2_TCA 512956
LEAV 4294967296 2750384027905848 Region omparalleMatricesMultiplication.c38    
THREAD_TEAM_EN 0 2750384027909694 ThreaTeam 0    
THREAD_TEAM_EN 4294967296 2750384027910998 ThreaTeam 0    
THREAD_JOI 0 2750384027928552 Model OpenMP    
#+end_example

- Foi possível visualizar que o scorep nos permite obter os misses em
  uma granularidade mais grossa, diferente da ferramenta likwid. Mas o
  scorep nos dá além da região do código o número da linha do código
  aonde aquela região inicia, o scorep utiliza a seguinte nomenclatura
  =região.cNumeroDeLinha=.
- Dúvidas:

	- Qual melhor formato de trace nesse tipo de situação?
	- Devo considerar o que ocorre antes|depois do fork da aplicação?
	- Como posso fazer para diminuir os traces gerados?
* [11:04:55; 25.10.2016] Como posso diminuir os traces gerados pelo scorep? :Gabriel:
- Conversando com o Guilherme Camelo, ele me mostrou um recurso do
  Scorep que permite realizar um filtro no trace.otf2. De acordo com o
  que preciso, o arquivo de filtro é da seguinte maneira:

#+BEGIN_EXAMPLE
SCOREP_REGION_NAMES_BEGIN
EXCLUDE *
INCLUDE PAPI OPENMP
INCLUDE multiplica transpose
SCOREP_REGION_NAMES_END
#+END_EXAMPLE

- O arquivo de filtro que defini inclui apenas regiões aonde a métrica
  PAPI foi utilizada e também as diretivas OpenMP, além disso, inclui
  os trechos de código que são as funções (nosso grão) do programa a
  serem analisadas.

- Para o Scorep reconhecer esse filtro é necessário utilizar além das
  configurações de variáveis de ambiente já declaradas a que aponta
  para o arquivo de filtro. Assim, as variáveis ficariam da seguinte
  maneira:

#+BEGIN_EXAMPLE
SCOREP_ENABLE_PROFILING=true \
SCOREP_ENABLE_TRACING=true \
SCOREP_TOTAL_MEMORY=3G \
SCOREP_METRIC_PAPI=PAPI_L2_TCA,PAPI_L2_DCM,PAPI_L2_ICM \
SCOREP_METRIC_RUSAGE=ru_utime,ru_stime \
SCOREP_FILTERING_FILE=/home/gabrielbmoro/src/bestSolution/filter_timestemp \
./program_exec 
#+END_EXAMPLE

* [18:36:44; 28.10.2016] Experimento de Energia com Graph500 com algumas políticas do CPUFreq :Gabriel:

- Script para gerar o design do experimento: 

#+begin_src R :results output :session *RpjectD* :exports both 
require(DoE.base);
  expGraph500Governors <- fac.design (
           nfactors=2,
           replications=20,
           repeat.only=FALSE,
           blocks=1,
           randomize=TRUE,
           seed=10373,
           nlevels=c(2,3),
           factor.names=list(
		  governors=c("powersave","performance"),
                threads=c(1,16,32)));                

  export.design(expGraph500Governors,
                path=".",
                filename=NULL,
                type="csv",
                replace=TRUE,
                response.names=c("time", "cpuenergy"));
#+end_src

#+RESULTS:
#+begin_example
Loading required package: DoE.base
Loading required package: grid
Loading required package: conf.design

Attaching package: ‘DoE.base’

The following objects are masked from ‘package:stats’:

    aov, lm

The following object is masked from ‘package:graphics’:

    plot.design

The following object is masked from ‘package:base’:

    lengths
 creating full factorial with 6 runs ...
#+end_example


#+begin_src sh :results output :exports both :tangle dados/scriptGraph500exp1ComDVFS.bash
#!bin/bash

nameFile="/home/gabrielbmoro/dissertacao_gbmoro/dados/expGraph500Governors.csv"
pathOfApps="/home/gabrielbmoro/Programs/graph500/omp-csr/omp-csr"
pcm_path="/home/gabrielbmoro/Programs/IntelPerformanceCounterMonitor-V2.11/pcm.x"
outputFile="../dados/ResultExpGraph500_diferentesGovernors.csv"
numberOfCpus=32
c=0
ref=$(cat $nameFile)

tmp=""

i=0

for row in ${ref[@]}; do
   if [ $i -gt 0 ]; then		
         name=$(echo "$row" | cut -d ',' -f1)
	   runId=$(echo "$row" | cut -d ',' -f2)
         runNumber=$(echo "$row" | cut -d ',' -f3)
	   runStd=$(echo "$row" | cut -d ',' -f4)
	   governors=$(echo "$row" | cut -d ',' -f5 | sed 's/"//g')
	   threads=$(echo "$row" | cut -d ',' -f6 | sed 's/"//g')

	   while [ $c -lt $numberOfCpus ]; do 
			sudo echo -n "$governors" > "/sys/devices/system/cpu/cpu$c/cpufreq/scaling_governor"
			let c=$c+1
	   done
	   c=0
	   
         #definindo o número de threads e pinando-as em um core específico
	   export OMP_NUM_THREADS=$threads
	   export GOMP_CPU_AFFINITY="0-$threadNumber"

	   sudo -E $pcm_path  --noJKTWA -r --external-program $pathOfApps -s 23 >> tmp.log
	   cpuEnergy=$(cat tmp.log | awk ' { print $4 } ' | tail -n 1)
		
	   timeSeconds=$($pathOfApps -s 23 | grep -i mean_time: | awk ' { print $2 } ' )
		
	   echo "$name,$runId,$runNumber,$runStd,$governors,$threads,$cpuEnergy,$timeSeconds" >> $outputFile
	else
		echo $row >> $outputFile
		let i=$i+1
	fi
done

#+end_src

* Dealing with ScoreP traces
** Fibonacci in OpenMP                                      :openmp:tracing:

#+BEGIN_SRC C :tangle fib_openmp_tasks.c
#include <stdio.h>
#include <omp.h>
int fib(int n)
{
  int i, j;
  if (n<2)
    return n;
  else
    {
       #pragma omp task shared(i) firstprivate(n)
       i=fib(n-1);

       #pragma omp task shared(j) firstprivate(n)
       j=fib(n-2);

       #pragma omp taskwait
       return i+j;
    }
}

int main(int argc, char **argv)
{
  int n = atoi(argv[1]);

  omp_set_dynamic(0);
  omp_set_num_threads(4);

  #pragma omp parallel shared(n)
  {
    #pragma omp single
    printf ("fib(%d) = %d\n", n, fib(n));
  }
}
#+END_SRC

Compiled with:
#+BEGIN_SRC sh
scorep --nocompiler --nocuda --noonline-access --nopdt --nouser  --noopencl gcc fib_openmp_tasks.c -fopenmp
#+END_SRC

Run with:
#+BEGIN_SRC sh
export SCOREP_TOTAL_MEMORY=604MB
export SCOREP_ENABLE_TRACING=True
./a.out 30
#+END_SRC

Convert to Paje with:
#+BEGIN_SRC sh
~/dev/akypuera/src/otf2-omp-print/otf2ompprint2paje.sh scorep-20160323_0805_2475054235691795/traces.otf2  > ~/traces.paje
#+END_SRC

Select a thread to analyze and clean-up with:
#+BEGIN_SRC sh
~/dev/pajeng/b/pj_dump ~/traces.paje | grep 4294967296 | grep ^State | sed -e "s/\!\$omp //" -e "s/@fib_openmp_tasks.c:.*<.*>//" -e "s/create task/create/"  > ~/traces-fib-4294967296.csv
#+END_SRC

Then, analyze:
#+begin_src R :results output :session :exports both
read_paje_trace <- function(file) {
  df <- read.csv(file, header=FALSE, strip.white=TRUE)
  names(df) <- c("Nature","ResourceId","Type","Start","End","Duration", "Depth", "Value")
  df$Origin=file
  m <- min(df$Start)
  df$Start <- df$Start - m
  df$End <- df$Start+df$Duration
  df$Origin <- NULL
  df$Nature <- NULL
  df$Type <- NULL
  df
}
df <- read_paje_trace("~/traces-fib-4294967296.csv");
head(df);
#+end_src

#+RESULTS:
:   ResourceId    Start      End Duration Depth            Value
: 1 4294967296 0.000000 9.658611 9.658611     0         parallel
: 2 4294967296 0.000911 9.658611 9.657700     1           single
: 3 4294967296 0.001295 9.658611 9.657316     2 implicit barrier
: 4 4294967296 0.002115 9.658611 9.656496     3             task
: 5 4294967296 0.003130 0.004674 0.001544     4           create
: 6 4294967296 0.005816 0.006797 0.000981     4           create

#+begin_src R :results output graphics :file img/openmp-fib-imbric-1.png :exports both :width 600 :height 120 :session
library(ggplot2);
ggplot(df[df$Depth > 26 & df$Depth < 34,]
, aes(x=Start, y=Depth, color=Value)) + theme_bw()  +
    geom_segment(aes(x=Start, xend=End, y=factor(Depth), yend=factor(Depth)), size=10) + xlim(0.049,0.069);
#+end_src

#+RESULTS:
[[file:img/openmp-fib-imbric-1.png]]

#+begin_src R :results output :session :exports both
m <- df[df$Start > 0.049 & df$End < 0.069,];
m
#+end_src

#+RESULTS:
#+begin_example
   ResourceId    Start      End Duration Depth    Value
63 4294967296 0.049811 0.068516 0.018705    27     task
64 4294967296 0.050121 0.050795 0.000674    28   create
65 4294967296 0.050983 0.051636 0.000653    28   create
66 4294967296 0.051801 0.068328 0.016527    28 taskwait
67 4294967296 0.052089 0.056226 0.004137    29     task
68 4294967296 0.052457 0.053048 0.000591    30   create
69 4294967296 0.053263 0.053754 0.000491    30   create
70 4294967296 0.053915 0.056018 0.002103    30 taskwait
71 4294967296 0.054177 0.054521 0.000344    31     task
72 4294967296 0.054976 0.055278 0.000302    31     task
73 4294967296 0.056820 0.067562 0.010742    29     task
74 4294967296 0.057129 0.057709 0.000580    30   create
75 4294967296 0.057891 0.058523 0.000632    30   create
76 4294967296 0.058685 0.067390 0.008705    30 taskwait
77 4294967296 0.058982 0.059302 0.000320    31     task
78 4294967296 0.059718 0.066682 0.006964    31     task
79 4294967296 0.060028 0.063395 0.003367    32   create
80 4294967296 0.063611 0.064189 0.000578    32   create
81 4294967296 0.064354 0.066513 0.002159    32 taskwait
82 4294967296 0.064650 0.065057 0.000407    33     task
83 4294967296 0.065567 0.065909 0.000342    33     task
#+end_example

#+begin_src R :results output :session :exports both
library(plyr);
k <- ddply(m, .(Value), summarize, sum=sum(Duration));
k
task = k[k$Value=="task",]$sum;
taskwait = k[k$Value=="taskwait",]$sum;
create = k[k$Value=="create",]$sum;
load = (task-taskwait-create)+create
slice=max(m$End)-min(m$Start);
load
slice
occupation=load/slice;
occupation
#+end_src

#+RESULTS:
:      Value      sum
: 1   create 0.007566
: 2     task 0.042263
: 3 taskwait 0.029494
: [1] 0.012769
: [1] 0.018705
: [1] 0.6826517

#+begin_src R :results output graphics :file img/openmp-fib-imbric-2.png :exports both :width 600 :height 100 :session
library(ggplot2);
ggplot(df[df$Depth > 26 & df$Depth < 34,]
, aes(x=Start, y=1, color=Value)) + theme_bw()  +
    geom_segment(aes(x=Start, xend=End, y=factor(1), yend=factor(1)), size=10) + xlim(0.049,0.069);
#+end_src

#+RESULTS:
[[file:img/openmp-fib-imbric-2.png]]

Entered on [2016-03-23 Wed 08:00]
** Testing again after second try                    :falles:openmp:tracing:


See this entry first:
- [[*Fibonacci in OpenMP][Fibonacci in OpenMP]]

Select a thread to analyze and clean-up with:

#+BEGIN_SRC sh
~/dev/pajeng/b/pj_dump --no-imbrication ~/traces.paje | grep 4294967296 | grep ^State | sed -e "s/\!\$omp //" -e "s/@fib_openmp_tasks.c:.*<.*>//" -e "s/create task/create/"  > ~/traces-fib-not_imbricated-4294967296.csv
#+END_SRC


#+begin_src R :results output :session :exports both
read_paje_trace <- function(file) {
  df <- read.csv(file, header=FALSE, strip.white=TRUE)
  names(df) <- c("Nature","ResourceId","Type","Start","End","Duration", "Depth", "Value")
  df$Origin=file
  m <- min(df$Start)
  df$Start <- df$Start - m
  df$End <- df$Start+df$Duration
  df$Origin <- NULL
  df$Nature <- NULL
  df$Type <- NULL
  df
}
df <- read_paje_trace("~/traces-fib-not_imbricated-4294967296.csv");
head(df);
#+end_src

#+RESULTS:
:   ResourceId    Start      End Duration Depth            Value
: 1 4294967296 0.000000 0.000911 0.000911     0         parallel
: 2 4294967296 0.000911 0.001295 0.000384     1           single
: 3 4294967296 0.001295 0.002115 0.000820     2 implicit barrier
: 4 4294967296 0.002115 0.003130 0.001015     3             task
: 5 4294967296 0.003130 0.004674 0.001544     4           create
: 6 4294967296 0.004674 0.005816 0.001142     3             task

#+begin_src R :results output graphics :file img/openmp-fib-NO_imbric-2.png :exports both :width 600 :height 600 :session
  library(ggplot2);
  ggplot(df, aes(x=Start, y=Depth, color=Value)) + theme_bw()  +
      geom_segment(aes(x=Start, xend=End, y=factor(Depth), yend=factor(Depth)), size=4) + xlim(0.049,0.069) +
      facet_wrap(~Value, ncol=1);
#+end_src

#+RESULTS:
[[file:img/openmp-fib-NO_imbric-2.png]]

** No imbrication for OpenMP's floorplan with dynamic :falles:openmp:tracing:

_Changes_

These are the changes committed to the Paje core simulator:

On PushState
- state on top of the stack is ended
- normal behavior

On PopState
- normal behavior
- state on top of the stack is ended
- get the value of new top of the stack
- pop again
- push a new state with the same value, new start time

_Validation_

Test file (BOTS' floorplan, dynamic on turing machine):

#+begin_src sh :results output :session :exports both
ls -lh /home/falles/raw/OpenMP/01/BOTS/floorplan/dynamic/01/traces.paje
#+end_src

#+RESULTS:
: -rw-r--r-- 1 falles falles 777M Mar 17 01:49 /home/falles/raw/OpenMP/01/BOTS/floorplan/dynamic/01/traces.paje

You need latest Paje to try this, then:

#+begin_src sh :results output :session :exports both
./pj_dump --no-imbrication /home/falles/raw/OpenMP/01/BOTS/floorplan/dynamic/01/traces.paje > raw-openmp-01-bots-floorplan-dynamic-01-not_imbricated.csv
#+end_src

Output is:

#+begin_src sh :results output :session :exports both
ls -lh ~/dev/pajeng/b/raw-openmp-01-bots-floorplan-dynamic-01-not_imbricated.csv
#+end_src

#+RESULTS:
: -rw-r--r-- 1 schnorr schnorr 1.6G Mar 24 14:36 /home/schnorr/dev/pajeng/b/raw-openmp-01-bots-floorplan-dynamic-01-not_imbricated.csv

Much larger trace file now. That's normal.

#+begin_src sh :results output :session :exports both
cat raw-openmp-01-bots-floorplan-dynamic-01-not_imbricated.csv| grep 98784247808 | grep ^State | sed -e "s/\!\$omp //" -e "s/ @floorplan.c:.*<.*>//" > raw-openmp-01-bots-floorplan-dynamic-01-not_imbricated-98784247808.csv
#+end_src

#+begin_src R :results output :session :exports both
read_paje_trace <- function(file) {
  df <- read.csv(file, header=FALSE, strip.white=TRUE)
  names(df) <- c("Nature","ResourceId","Type","Start","End","Duration", "Depth", "Value")
  df$Origin=file
  m <- min(df$Start)
  df$Start <- df$Start - m
  df$End <- df$Start+df$Duration
  df$Origin <- NULL
  df$Nature <- NULL
  df$Type <- NULL
  df
}
df <- read_paje_trace("~/dev/pajeng/b/raw-openmp-01-bots-floorplan-dynamic-01-not_imbricated-98784247808.csv");
head(df);
#+end_src

#+RESULTS:
:    ResourceId     Start       End  Duration Depth            Value
: 1 98784247808  0.000000  0.001696  0.001696     0         parallel
: 2 98784247808  0.001696  0.003661  0.001965     1           single
: 3 98784247808  0.003661  0.062116  0.058455     2 implicit barrier
: 4 98784247808  0.062116 12.940802 12.878686     3           atomic
: 5 98784247808 12.940802 14.349705  1.408903     4         taskwait
: 6 98784247808 14.349705 16.532153  2.182448     5           atomic


#+begin_src R :results output graphics :file img/openmp-floorplan-dynamic-not_imbricated_v2.png :exports both :width 600 :height 200 :session
library(ggplot2);
ggplot(df[df$Value == "atomic" | df$Value == "taskwait",], aes(x=Start, y=ResourceId, color=Value)) + theme_bw()  +
    geom_segment(aes(x=Start, xend=End, y=factor(ResourceId), yend=factor(ResourceId)), size=4) + facet_wrap(~Value, ncol=1) + xlim(1000,1200);
#+end_src

#+RESULTS:
[[file:img/openmp-floorplan-dynamic-not_imbricated_v2.png]]

Great, it works.

What is the execution time of this thread:

#+begin_src R :results output :session :exports both
execution_time = max(df$End)-min(df$Start)
execution_time
#+end_src

#+RESULTS:
: [1] 168152.2

Now let's calculate the load for this thread's full execution.

Load is considered to be _everything_ but the state *taskwait*.

#+begin_src R :results output :session :exports both
library(plyr);
k <- ddply(df, .(Value), summarize, sum=sum(Duration), ratio=sum(Duration)/execution_time*100);
k
#+end_src

#+RESULTS:
:              Value          sum        ratio
: 1           atomic 95056.684770 5.653014e+01
: 2 implicit barrier     5.212183 3.099681e-03
: 3         parallel     0.002739 1.628881e-06
: 4           single     0.002456 1.460581e-06
: 5         taskwait 73090.318241 4.346676e+01

This thread has passed ~43.4% of the time in the taskwait. So, the
load is the rest.

_Full trace_

Let's try out for all threads to see the load balancing.

#+begin_src sh :results output :session :exports both
cat raw-openmp-01-bots-floorplan-dynamic-01-not_imbricated.csv| grep ^State | sed -e "s/\!\$omp //" -e "s/ @floorplan.c:.*<.*>//" > raw-openmp-01-bots-floorplan-dynamic-01-not_imbricated-cleaned_up.csv
#+end_src

#+begin_src R :results output :session :exports both
df_full <- read_paje_trace("~/dev/pajeng/b/raw-openmp-01-bots-floorplan-dynamic-01-not_imbricated-cleaned_up.csv");
head(df_full);
#+end_src

#+RESULTS:
:   ResourceId    Start      End Duration Depth         Value
: 1       zero 0.000000 0.016431 0.016431     0      parallel
: 2       zero 0.016431 0.023661 0.007230     1        single
: 3       zero 0.023661 0.040341 0.016680     2 single sblock
: 4       zero 0.040341 0.047670 0.007329     3      taskwait
: 5       zero 0.047670 0.172861 0.125191     4        atomic
: 6       zero 0.172861 0.182818 0.009957     5      taskwait

Let's summarize all this information.

#+begin_src R :results output :session :exports both
library(plyr);
execution_time = max(df_full$End) - min(df_full$Start);
k_full <- ddply(df_full, .(ResourceId, Value), summarize, sum=sum(Duration), ratio=sum(Duration)/execution_time*100);
k_full
#+end_src

#+RESULTS:
#+begin_example
      ResourceId            Value          sum        ratio
1   103079215104           atomic 5.257568e+03 3.125931e+00
2   103079215104 implicit barrier 2.429104e+00 1.444244e-03
3   103079215104         parallel 3.012000e-03 1.790809e-06
4   103079215104           single 1.798000e-03 1.069016e-06
5   103079215104         taskwait 1.629311e+05 9.687203e+01
6   107374182400           atomic 9.506838e+04 5.652369e+01
7   107374182400 implicit barrier 5.231560e+00 3.110467e-03
8   107374182400         parallel 3.196000e-03 1.900208e-06
9   107374182400           single 1.603000e-03 9.530769e-07
10  107374182400         taskwait 7.310996e+04 4.346813e+01
11  111669149696           atomic 6.298359e+04 3.744741e+01
12  111669149696 implicit barrier 7.301773e+00 4.341329e-03
13  111669149696         parallel 3.184000e-03 1.893074e-06
14  111669149696           single 2.493000e-03 1.482234e-06
15  111669149696         taskwait 1.051696e+05 6.252948e+01
16  115964116992           atomic 9.489289e+04 5.641935e+01
17  115964116992 implicit barrier 1.156814e+01 6.877934e-03
18  115964116992         parallel 6.929000e-03 4.119694e-06
19  115964116992           single 6.760000e-03 4.019214e-06
20  115964116992         taskwait 7.326552e+04 4.356062e+01
21  120259084288           atomic 9.706492e+04 5.771075e+01
22  120259084288 implicit barrier 5.111085e+00 3.038838e-03
23  120259084288         parallel 2.583000e-03 1.535744e-06
24  120259084288           single 2.110000e-03 1.254518e-06
25  120259084288         taskwait 7.111605e+04 4.228264e+01
26  124554051584           atomic 9.364358e+04 5.567656e+01
27  124554051584 implicit barrier 5.730175e+00 3.406923e-03
28  124554051584         parallel 2.924000e-03 1.738488e-06
29  124554051584           single 1.729000e-03 1.027991e-06
30  124554051584         taskwait 7.453172e+04 4.431345e+01
31   12884901888           atomic 9.452417e+04 5.620013e+01
32   12884901888 implicit barrier 5.283357e+00 3.141264e-03
33   12884901888         parallel 2.707000e-03 1.609469e-06
34   12884901888           single 1.486000e-03 8.835136e-07
35   12884901888         taskwait 7.364873e+04 4.378846e+01
36  128849018880           atomic 9.542451e+04 5.673543e+01
37  128849018880 implicit barrier 5.614005e+00 3.337853e-03
38  128849018880         parallel 2.529000e-03 1.503638e-06
39  128849018880           single 1.463000e-03 8.698387e-07
40  128849018880         taskwait 7.273420e+04 4.324472e+01
41  133143986176           atomic 9.485870e+04 5.639903e+01
42  133143986176 implicit barrier 8.365849e+00 4.973985e-03
43  133143986176         parallel 4.789000e-03 2.847340e-06
44  133143986176           single 3.740000e-03 2.223648e-06
45  133143986176         taskwait 7.331113e+04 4.358774e+01
46  137438953472           atomic 6.365093e+01 3.784419e-02
47  137438953472 implicit barrier 1.127640e-01 6.704477e-05
48  137438953472         parallel 2.790000e-03 1.658818e-06
49  137438953472           single 1.747000e-03 1.038693e-06
50  137438953472         taskwait 1.681281e+05 9.996197e+01
51  141733920768           atomic 8.705159e+04 5.175724e+01
52  141733920768 implicit barrier 3.345680e+00 1.989202e-03
53  141733920768         parallel 2.917000e-03 1.734326e-06
54  141733920768           single 2.128000e-03 1.265220e-06
55  141733920768         taskwait 8.112779e+04 4.823520e+01
56  146028888064           atomic 9.278821e+04 5.516800e+01
57  146028888064 implicit barrier 8.522323e+00 5.067018e-03
58  146028888064         parallel 5.551000e-03 3.300393e-06
59  146028888064           single 1.763000e-03 1.048206e-06
60  146028888064         taskwait 7.536190e+04 4.480704e+01
61  150323855360           atomic 9.354745e+04 5.561941e+01
62  150323855360 implicit barrier 4.332564e+00 2.575962e-03
63  150323855360         parallel 2.526000e-03 1.501854e-06
64  150323855360           single 1.617000e-03 9.614007e-07
65  150323855360         taskwait 7.462551e+04 4.436922e+01
66  154618822656           atomic 9.371393e+04 5.571839e+01
67  154618822656 implicit barrier 5.114638e+00 3.040950e-03
68  154618822656         parallel 2.435000e-03 1.447749e-06
69  154618822656           single 1.395000e-03 8.294088e-07
70  154618822656         taskwait 7.446869e+04 4.427597e+01
71  158913789952           atomic 9.555366e+04 5.681222e+01
72  158913789952 implicit barrier 4.532980e+00 2.695121e-03
73  158913789952         parallel 3.650000e-03 2.170138e-06
74  158913789952           single 2.459000e-03 1.462019e-06
75  158913789952         taskwait 7.262195e+04 4.317798e+01
76  163208757248           atomic 6.681130e+04 3.972321e+01
77  163208757248 implicit barrier 2.621608e+00 1.558699e-03
78  163208757248         parallel 4.171000e-03 2.479903e-06
79  163208757248           single 3.065000e-03 1.822321e-06
80  163208757248         taskwait 1.013486e+05 6.025765e+01
81  167503724544           atomic 9.100315e+04 5.410667e+01
82  167503724544 implicit barrier 2.700217e+00 1.605436e-03
83  167503724544         parallel 9.255000e-03 5.502637e-06
84  167503724544           single 1.870000e-03 1.111824e-06
85  167503724544         taskwait 7.716586e+04 4.587960e+01
86   17179869184           atomic 9.762094e+04 5.804133e+01
87   17179869184 implicit barrier 3.584296e+00 2.131073e-03
88   17179869184         parallel 3.066000e-03 1.822916e-06
89   17179869184           single 1.372000e-03 8.157339e-07
90   17179869184         taskwait 7.056391e+04 4.195436e+01
91  171798691840           atomic 5.757921e+04 3.423419e+01
92  171798691840 implicit barrier 4.591601e+00 2.729974e-03
93  171798691840         parallel 2.914000e-03 1.732543e-06
94  171798691840           single 1.549000e-03 9.209708e-07
95  171798691840         taskwait 1.106056e+05 6.576149e+01
96  176093659136           atomic 9.372887e+04 5.572727e+01
97  176093659136 implicit barrier 5.641873e+00 3.354422e-03
98  176093659136         parallel 2.954000e-03 1.756325e-06
99  176093659136           single 2.387000e-03 1.419211e-06
100 176093659136         taskwait 7.444982e+04 4.426476e+01
101 180388626432           atomic 9.430199e+04 5.606803e+01
102 180388626432 implicit barrier 2.388878e+01 1.420327e-02
103 180388626432         parallel 4.801000e-03 2.854474e-06
104 180388626432           single 1.841000e-03 1.094582e-06
105 180388626432         taskwait 7.385322e+04 4.391004e+01
106 184683593728           atomic 9.514623e+04 5.656998e+01
107 184683593728 implicit barrier 6.527981e+00 3.881265e-03
108 184683593728         parallel 3.480000e-03 2.069063e-06
109 184683593728           single 1.440000e-03 8.561639e-07
110 184683593728         taskwait 7.302441e+04 4.341726e+01
111 188978561024           atomic 8.188731e+03 4.868678e+00
112 188978561024 implicit barrier 5.286582e+00 3.143181e-03
113 188978561024         parallel 3.011000e-03 1.790215e-06
114 188978561024           single 1.907000e-03 1.133823e-06
115 188978561024         taskwait 1.599971e+05 9.512760e+01
116 193273528320           atomic 9.532625e+04 5.667701e+01
117 193273528320 implicit barrier 1.440928e+01 8.567158e-03
118 193273528320         parallel 3.495000e-03 2.077981e-06
119 193273528320           single 2.733000e-03 1.624928e-06
120 193273528320         taskwait 7.284130e+04 4.330840e+01
121 197568495616           atomic 9.460927e+04 5.625072e+01
122 197568495616 implicit barrier 9.475717e+00 5.633866e-03
123 197568495616         parallel 4.216000e-03 2.506658e-06
124 197568495616           single 2.035000e-03 1.209926e-06
125 197568495616         taskwait 7.355751e+04 4.373423e+01
126 201863462912           atomic 9.287340e+04 5.521865e+01
127 201863462912 implicit barrier 9.406122e+00 5.592488e-03
128 201863462912         parallel 4.838000e-03 2.876473e-06
129 201863462912           single 2.158000e-03 1.283057e-06
130 201863462912         taskwait 7.528725e+04 4.476266e+01
131 206158430208           atomic 3.990368e+04 2.372506e+01
132 206158430208 implicit barrier 1.097700e-01 6.526466e-05
133 206158430208         parallel 2.530000e-03 1.504232e-06
134 206158430208           single 1.444000e-03 8.585421e-07
135 206158430208         taskwait 1.282857e+05 7.627330e+01
136 210453397504           atomic 9.136347e+04 5.432091e+01
137 210453397504 implicit barrier 2.972672e+00 1.767427e-03
138 210453397504         parallel 9.312000e-03 5.536527e-06
139 210453397504           single 7.709000e-03 4.583450e-06
140 210453397504         taskwait 7.680798e+04 4.566682e+01
141  21474836480           atomic 9.543556e+04 5.674200e+01
142  21474836480 implicit barrier 5.513241e+00 3.277943e-03
143  21474836480         parallel 3.108000e-03 1.847887e-06
144  21474836480           single 2.469000e-03 1.467964e-06
145  21474836480         taskwait 7.273889e+04 4.324751e+01
146 214748364800           atomic 9.508381e+04 5.653287e+01
147 214748364800 implicit barrier 6.105220e+00 3.629909e-03
148 214748364800         parallel 8.869000e-03 5.273137e-06
149 214748364800           single 8.022000e-03 4.769546e-06
150 214748364800         taskwait 7.307054e+04 4.344469e+01
151 219043332096           atomic 9.493237e+04 5.644282e+01
152 219043332096 implicit barrier 6.714173e+00 3.991967e-03
153 219043332096         parallel 8.232000e-03 4.894404e-06
154 219043332096           single 2.743000e-03 1.630873e-06
155 219043332096         taskwait 7.321500e+04 4.353058e+01
156 223338299392           atomic 9.274606e+04 5.514293e+01
157 223338299392 implicit barrier 8.841944e+00 5.257051e-03
158 223338299392         parallel 2.649000e-03 1.574985e-06
159 223338299392           single 1.874000e-03 1.114202e-06
160 223338299392         taskwait 7.543199e+04 4.484871e+01
161 227633266688           atomic 9.341270e+04 5.553930e+01
162 227633266688 implicit barrier 1.707644e+00 1.015294e-03
163 227633266688         parallel 3.145000e-03 1.869886e-06
164 227633266688           single 2.190000e-03 1.302083e-06
165 227633266688         taskwait 7.477068e+04 4.445553e+01
166 231928233984           atomic 9.512620e+04 5.655807e+01
167 231928233984 implicit barrier 8.565546e+00 5.092716e-03
168 231928233984         parallel 4.891000e-03 2.907984e-06
169 231928233984           single 1.631000e-03 9.697245e-07
170 231928233984         taskwait 7.303129e+04 4.342135e+01
171 236223201280           atomic 9.535300e+04 5.669291e+01
172 236223201280 implicit barrier 6.915178e+00 4.111476e-03
173 236223201280         parallel 1.056300e-02 6.280319e-06
174 236223201280           single 7.653000e-03 4.550154e-06
175 236223201280         taskwait 7.279234e+04 4.327928e+01
176 240518168576           atomic 3.149671e+04 1.872663e+01
177 240518168576 implicit barrier 4.942890e-01 2.938836e-04
178 240518168576         parallel 2.683000e-03 1.595200e-06
179 240518168576           single 1.481000e-03 8.805408e-07
180 240518168576         taskwait 1.366930e+05 8.127196e+01
181 244813135872           atomic 9.328208e+04 5.546163e+01
182 244813135872 implicit barrier 6.214451e+00 3.694853e-03
183 244813135872         parallel 3.917000e-03 2.328885e-06
184 244813135872           single 2.540000e-03 1.510178e-06
185 244813135872         taskwait 7.489530e+04 4.452962e+01
186 249108103168           atomic 8.891512e+04 5.286522e+01
187 249108103168 implicit barrier 1.139623e+01 6.775720e-03
188 249108103168         parallel 4.029000e-03 2.395475e-06
189 249108103168           single 2.240000e-03 1.331811e-06
190 249108103168         taskwait 7.924971e+04 4.711857e+01
191 253403070464           atomic 9.492178e+04 5.643653e+01
192 253403070464 implicit barrier 3.411526e+00 2.028351e-03
193 253403070464         parallel 3.206000e-03 1.906154e-06
194 253403070464           single 2.577000e-03 1.532177e-06
195 253403070464         taskwait 7.324763e+04 4.354998e+01
196  25769803776           atomic 8.251269e+04 4.905860e+01
197  25769803776 implicit barrier 8.358756e+00 4.969767e-03
198  25769803776         parallel 1.349800e-02 8.025347e-06
199  25769803776           single 7.242000e-03 4.305791e-06
200  25769803776         taskwait 8.564163e+04 5.091894e+01
201 257698037760           atomic 9.623549e+04 5.721761e+01
202 257698037760 implicit barrier 4.012270e+00 2.385528e-03
203 257698037760         parallel 3.086000e-03 1.834807e-06
204 257698037760           single 1.810000e-03 1.076150e-06
205 257698037760         taskwait 7.194660e+04 4.277645e+01
206 261993005056           atomic 9.493811e+04 5.644624e+01
207 261993005056 implicit barrier 3.718292e+00 2.210741e-03
208 261993005056         parallel 4.724000e-03 2.808693e-06
209 261993005056           single 2.124000e-03 1.262842e-06
210 261993005056         taskwait 7.323923e+04 4.354499e+01
211 266287972352           atomic 9.542436e+04 5.673534e+01
212 266287972352 implicit barrier 8.477932e+00 5.040625e-03
213 266287972352         parallel 8.120000e-03 4.827813e-06
214 266287972352           single 2.448000e-03 1.455479e-06
215 266287972352         taskwait 7.273152e+04 4.324313e+01
216 270582939648           atomic 9.491402e+04 5.643192e+01
217 270582939648 implicit barrier 1.055890e+01 6.277879e-03
218 270582939648         parallel 3.847000e-03 2.287266e-06
219 270582939648           single 2.918000e-03 1.734921e-06
220 270582939648         taskwait 7.322932e+04 4.353910e+01
221  30064771072           atomic 9.431902e+04 5.607815e+01
222  30064771072 implicit barrier 5.448438e+00 3.239414e-03
223  30064771072         parallel 2.747000e-03 1.633252e-06
224  30064771072           single 3.520000e-03 2.092845e-06
225  30064771072         taskwait 7.384707e+04 4.390638e+01
226  34359738368           atomic 8.505622e+04 5.057088e+01
227  34359738368 implicit barrier 3.753017e+00 2.231387e-03
228  34359738368         parallel 2.650000e-03 1.575579e-06
229  34359738368           single 1.454000e-03 8.644877e-07
230  34359738368         taskwait 8.312856e+04 4.942477e+01
231  38654705664           atomic 9.524944e+04 5.663134e+01
232  38654705664 implicit barrier 3.823535e+00 2.273314e-03
233  38654705664         parallel 3.387000e-03 2.013769e-06
234  38654705664           single 1.861000e-03 1.106473e-06
235  38654705664         taskwait 7.293109e+04 4.336178e+01
236   4294967296           atomic 9.311534e+04 5.536249e+01
237   4294967296 implicit barrier 1.124473e+01 6.685647e-03
238   4294967296         parallel 3.950000e-03 2.348505e-06
239   4294967296           single 2.208000e-03 1.312785e-06
240   4294967296         taskwait 7.505615e+04 4.462526e+01
241  42949672960           atomic 9.448855e+04 5.617895e+01
242  42949672960 implicit barrier 1.539861e+01 9.155372e-03
243  42949672960         parallel 3.114000e-03 1.851454e-06
244  42949672960           single 2.798000e-03 1.663574e-06
245  42949672960         taskwait 7.366207e+04 4.379639e+01
246  47244640256           atomic 9.517358e+04 5.658624e+01
247  47244640256 implicit barrier 1.086556e+01 6.460211e-03
248  47244640256         parallel 3.290000e-03 1.956097e-06
249  47244640256           single 6.311000e-03 3.752257e-06
250  47244640256         taskwait 7.298345e+04 4.339291e+01
251  51539607552           atomic 7.336560e+04 4.362013e+01
252  51539607552 implicit barrier 2.807430e-01 1.669181e-04
253  51539607552         parallel 3.458000e-03 2.055982e-06
254  51539607552           single 1.202000e-03 7.146590e-07
255  51539607552         taskwait 9.482182e+04 5.637710e+01
256  55834574848           atomic 9.605475e+04 5.711014e+01
257  55834574848 implicit barrier 1.511454e+01 8.986473e-03
258  55834574848         parallel 2.867000e-03 1.704599e-06
259  55834574848           single 1.504000e-03 8.942156e-07
260  55834574848         taskwait 7.211207e+04 4.287482e+01
261  60129542144           atomic 9.471805e+04 5.631540e+01
262  60129542144 implicit barrier 2.223101e+00 1.321763e-03
263  60129542144         parallel 3.353000e-03 1.993554e-06
264  60129542144           single 2.272000e-03 1.350836e-06
265  60129542144         taskwait 7.345444e+04 4.367294e+01
266  64424509440           atomic 9.469022e+04 5.629885e+01
267  64424509440 implicit barrier 5.401929e+00 3.211762e-03
268  64424509440         parallel 7.701000e-03 4.578693e-06
269  64424509440           single 2.450000e-03 1.456668e-06
270  64424509440         taskwait 7.346081e+04 4.367673e+01
271  68719476736           atomic 3.100461e+04 1.843405e+01
272  68719476736 implicit barrier 5.993857e+00 3.563697e-03
273  68719476736         parallel 3.048000e-03 1.812214e-06
274  68719476736           single 1.908000e-03 1.134417e-06
275  68719476736         taskwait 1.371796e+05 8.156126e+01
276  73014444032           atomic 9.478440e+04 5.635485e+01
277  73014444032         critical 6.927200e-02 4.118624e-05
278  73014444032  critical sblock 1.616400e-02 9.610440e-06
279  73014444032 implicit barrier 9.162490e+00 5.447634e-03
280  73014444032         parallel 3.776000e-03 2.245052e-06
281  73014444032           single 7.792000e-03 4.632798e-06
282  73014444032         taskwait 7.337939e+04 4.362832e+01
283  77309411328           atomic 9.561862e+04 5.685084e+01
284  77309411328 implicit barrier 8.130450e+00 4.834026e-03
285  77309411328         parallel 3.271000e-03 1.944800e-06
286  77309411328           single 1.962000e-03 1.166523e-06
287  77309411328         taskwait 7.253196e+04 4.312448e+01
288  81604378624           atomic 9.468575e+04 5.629619e+01
289  81604378624 implicit barrier 5.988258e+00 3.560368e-03
290  81604378624         parallel 7.220000e-03 4.292711e-06
291  81604378624           single 6.406000e-03 3.808740e-06
292  81604378624         taskwait 7.346462e+04 4.367900e+01
293   8589934592           atomic 9.037003e+04 5.373025e+01
294   8589934592 implicit barrier 9.148242e+00 5.439163e-03
295   8589934592         parallel 2.997000e-03 1.781891e-06
296   8589934592           single 1.771000e-03 1.052963e-06
297   8589934592         taskwait 7.779978e+04 4.625650e+01
298  85899345920           atomic 8.850544e+04 5.262164e+01
299  85899345920         critical 2.498700e-02 1.485623e-05
300  85899345920  critical sblock 5.033000e-03 2.992412e-06
301  85899345920 implicit barrier 2.789060e+00 1.658259e-03
302  85899345920         parallel 3.496000e-03 2.078576e-06
303  85899345920           single 2.320000e-03 1.379375e-06
304  85899345920         taskwait 7.967866e+04 4.737361e+01
305  90194313216           atomic 9.146077e+04 5.437876e+01
306  90194313216 implicit barrier 9.804743e+00 5.829491e-03
307  90194313216         parallel 5.060000e-03 3.008465e-06
308  90194313216           single 2.716000e-03 1.614820e-06
309  90194313216         taskwait 7.671460e+04 4.561130e+01
310  94489280512           atomic 9.484374e+04 5.639013e+01
311  94489280512 implicit barrier 9.518932e+00 5.659560e-03
312  94489280512         parallel 3.170000e-03 1.884750e-06
313  94489280512           single 2.580000e-03 1.533960e-06
314  94489280512         taskwait 7.331458e+04 4.358979e+01
315  98784247808           atomic 9.505668e+04 5.651674e+01
316  98784247808 implicit barrier 5.212183e+00 3.098946e-03
317  98784247808         parallel 2.739000e-03 1.628495e-06
318  98784247808           single 2.456000e-03 1.460235e-06
319  98784247808         taskwait 7.309032e+04 4.345645e+01
320         zero           atomic 1.470320e-01 8.741909e-05
321         zero implicit barrier 1.411000e-02 8.389217e-06
322         zero         parallel 1.842500e-02 1.095474e-05
323         zero           single 9.336000e-03 5.550796e-06
324         zero    single sblock 2.089600e-02 1.242389e-05
325         zero         taskwait 1.681919e+05 9.999988e+01
#+end_example

Let's look only to the taskwait to see if it is different.

#+begin_src R :results output :session :exports both
k_full[k_full$Value == "taskwait",];
#+end_src

#+RESULTS:
#+begin_example
      ResourceId    Value       sum    ratio
5   103079215104 taskwait 162931.10 96.87203
10  107374182400 taskwait  73109.96 43.46813
15  111669149696 taskwait 105169.64 62.52948
20  115964116992 taskwait  73265.52 43.56062
25  120259084288 taskwait  71116.05 42.28264
30  124554051584 taskwait  74531.72 44.31345
35   12884901888 taskwait  73648.73 43.78846
40  128849018880 taskwait  72734.20 43.24472
45  133143986176 taskwait  73311.13 43.58774
50  137438953472 taskwait 168128.12 99.96197
55  141733920768 taskwait  81127.79 48.23520
60  146028888064 taskwait  75361.90 44.80704
65  150323855360 taskwait  74625.51 44.36922
70  154618822656 taskwait  74468.69 44.27597
75  158913789952 taskwait  72621.95 43.17798
80  163208757248 taskwait 101348.60 60.25765
85  167503724544 taskwait  77165.86 45.87960
90   17179869184 taskwait  70563.91 41.95436
95  171798691840 taskwait 110605.62 65.76149
100 176093659136 taskwait  74449.82 44.26476
105 180388626432 taskwait  73853.22 43.91004
110 184683593728 taskwait  73024.41 43.41726
115 188978561024 taskwait 159997.10 95.12760
120 193273528320 taskwait  72841.30 43.30840
125 197568495616 taskwait  73557.51 43.73423
130 201863462912 taskwait  75287.25 44.76266
135 206158430208 taskwait 128285.65 76.27330
140 210453397504 taskwait  76807.98 45.66682
145  21474836480 taskwait  72738.89 43.24751
150 214748364800 taskwait  73070.54 43.44469
155 219043332096 taskwait  73215.00 43.53058
160 223338299392 taskwait  75431.99 44.84871
165 227633266688 taskwait  74770.68 44.45553
170 231928233984 taskwait  73031.29 43.42135
175 236223201280 taskwait  72792.34 43.27928
180 240518168576 taskwait 136693.01 81.27196
185 244813135872 taskwait  74895.30 44.52962
190 249108103168 taskwait  79249.71 47.11857
195 253403070464 taskwait  73247.63 43.54998
200  25769803776 taskwait  85641.63 50.91894
205 257698037760 taskwait  71946.60 42.77645
210 261993005056 taskwait  73239.23 43.54499
215 266287972352 taskwait  72731.52 43.24313
220 270582939648 taskwait  73229.32 43.53910
225  30064771072 taskwait  73847.07 43.90638
230  34359738368 taskwait  83128.56 49.42477
235  38654705664 taskwait  72931.09 43.36178
240   4294967296 taskwait  75056.15 44.62526
245  42949672960 taskwait  73662.07 43.79639
250  47244640256 taskwait  72983.45 43.39291
255  51539607552 taskwait  94821.82 56.37710
260  55834574848 taskwait  72112.07 42.87482
265  60129542144 taskwait  73454.44 43.67294
270  64424509440 taskwait  73460.81 43.67673
275  68719476736 taskwait 137179.59 81.56126
282  73014444032 taskwait  73379.39 43.62832
287  77309411328 taskwait  72531.96 43.12448
292  81604378624 taskwait  73464.62 43.67900
297   8589934592 taskwait  77799.78 46.25650
304  85899345920 taskwait  79678.66 47.37361
309  90194313216 taskwait  76714.60 45.61130
314  94489280512 taskwait  73314.58 43.58979
319  98784247808 taskwait  73090.32 43.45645
325         zero taskwait 168191.89 99.99988
#+end_example

Some threads that are not thread zero do almost nothing.

Let's create a stacked bar plot to see this.

#+begin_src R :results output graphics :file img/openmp-floorplan-dynamic-load_balance.png :exports both :width 800 :height 400 :session
ggplot(k_full,
     aes(x = as.factor(ResourceId), y = ratio, fill=as.factor(Value))) +
     geom_bar(stat='identity', width=0.8) +
     ylim(0,100) +
     theme_bw();
#+end_src

#+RESULTS:
[[file:img/openmp-floorplan-dynamic-load_balance.png]]


Some threads do not work at all.
