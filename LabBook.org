#+TITLE: LabBook
#+AUTHOR: Gabriel Bronzatti Moro and Lucas M. Schnorr
#+LATEX_HEADER: \usepackage[margin=2cm,a4paper]{geometry}
#+STARTUP: overview indent
#+TAGS: Gabriel(G) Lucas(L) noexport(n) deprecated(d) ArqOrgProcs(p) IParProg(q)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

Esse documento está em pt-br

* [00:18:39; 02.07.2016] Tarefas da Primeira Reunião com o Professor Lucas
** Principais trabalhos relacionados - Artigo do Luis Felipe
|------------+---------------------------------------+-----------------------------------------------------------+---------------------------------|
| Autores    | Título                                | Trabalho                                                  | Diferenças                      |
|------------+---------------------------------------+-----------------------------------------------------------+---------------------------------|
| Freeh      | Using multiple energy gears in mpi    | O principal objetivo desse trabalho é propor uma          | 1. Uso de Desing of Experiments |
| et al.     | programs on a power-scalable cluster  | escala de frequência para aplicações HPC, avaliando todas | 2. Uso das frequências alta e   |
|            |                                       | as possibilidades de frequências disponíveis.             | baixa                           |
|            |                                       | Esse trabalho usa a biblioteca cpufreq-utils para         |                                 |
|            |                                       | recuperar a frequência média.                             |                                 |
|------------+---------------------------------------+-----------------------------------------------------------+---------------------------------|
| Laurenzano | Reducing energy usage with memory and | A abordagem de Laurenzano et al. define a melhor          | 1. O foco é no código da        |
| et al.     | computation-aware dynamic frequency   | frequência por loop. A técnica considera diferentes       | aplicação paralela              |
|            | scaling                               | CPUs, configurações de memória para visualizar a melhor   | 2. Busca de melhor              |
|            |                                       | relação entre as configurações de frequência, processador | configuração (tempo e energia)  |
|            |                                       | e memória.                                                |                                 |
|------------+---------------------------------------+-----------------------------------------------------------+---------------------------------|
- Alguns trabalhos possíveis: 
*** Caracterização de aplicações paralelas implementadas em OpenMP
	=Motivativação=: Análise do comportamento da aplicação paralela
	via contadores de hardware. A partir disso será possível
	visualizar o perfil de execução da aplicação pelos contadores
	de hardware. A técnica pode ser usada como uma pré-execução.

	=Metodologia=: Uso da abordagem =DoE= (Desing of Experiments) para
	projetar o experimento e analisar os resultados. Freeh et
	al. possui um trabalho similar, mas o diferencial do nosso
	trabalho é a metodologia e o uso da técnica DoE.
        
*** Modelagem de energia para aplicações híbridas OpenMP/MPI
	=Motivativação=: Contabilizar a energia gasta em cada região
	paralela, mas também a energia gasta dentro do nó (intra-node)
	e a comunicação dentro do nó (se existir) e a comunicação fora
	do nó. Esse trabalho se concentraria na estimativa da energia
	total gasta pela aplicação híbrida implementada em
	OpenMP/MPI.

	=Metodologia=: A metodologia pode ser a seguinte (uma abordagem
	button-up):
        a) Estimar a energia de cada região paralela (usando
           contadores de hardware em diferentes nós);
        b) Estimar a energia da aplicação (fora do limite fork-join);
        c) Estimar a energia da aplicação na comunicação intra-nó;
        d) Estimar a energia da comunicação inter-node (fora do nó).

  =Results=: O resultado seria a estimativa de energia da aplicação
  híbrida como um todo e também a energia gasta em cada nó. Isso pode
  oferecer uma estimativa correta de energia para essas aplicações, a
  partir da informação obtida o desenvolvedor poderá otimizar alguma
  parte da sua aplicação.
* [19:10:05; 05.07.2016] Reunião Semanal com o Professor Lucas
** Definição do assunto da dissertação
	=Objetivo=: Detectar as fases da aplicação utilizando contadores
	de hardware.

    =Ferramentas a serem investigadas=: ScoreP (com PAPI), ExtraE e
    TAU. Também procurar como realizar uma medição utilizando
    contadores de hardware =along_time=.

    =Tarefas=: 
    	a) fazer os trabalhos relacionados direcionando-os na
    temática ``Parallel Application Phase Detection'';
    	b) implementar a detecção de fase usando contadores do PAPI +
           ScoreP;
       	    b.1) A parte =along_time=
		c) Definir as fases, aplicar conhecimento para reduzir energia
    
* [22:15:57; 08.07.2016] Configuração de Ambiente Scorep e PAPI
** Instalação do PAPI
#+begin_src sh :results output :exports both
cd $HOME/Downloads/
wget http://icl.cs.utk.edu/projects/papi/downloads/papi-5.4.3.tar.gz
tar -vzxf papi-5.4.3.tar.gz
cd papi-5.4.3/src/
./configure
make
#+end_src

#+begin_src sh :results output :exports both
sudo apt-get install papi-tools -y
#+end_src

- Fazendo um teste para verificar a instalação da ferramenta:

#+begin_src sh :results output :exports both
cd $HOME/Downloads/papi-5.4.3/src/
bash ./run_tests.sh -v
#+end_src

#+RESULTS:
#+begin_example
Platform:
Linux morocomputer 4.4.0-28-generic #47-Ubuntu SMP Fri Jun 24 10:09:13 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
Date:
Sáb Jul  9 11:19:29 BRT 2016

Cpuinfo:
processor	: 0
vendor_id	: GenuineIntel
cpu family	: 6
model		: 69
model name	: Intel(R) Core(TM) i5-4210U CPU @ 1.70GHz
stepping	: 1
microcode	: 0x1c
cpu MHz		: 1902.804
cache size	: 3072 KB
physical id	: 0
siblings	: 4
core id		: 0
cpu cores	: 2
apicid		: 0
initial apicid	: 0
fpu		: yes
fpu_exception	: yes
cpuid level	: 13
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf eagerfpu pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm epb tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid xsaveopt dtherm ida arat pln pts
bugs		:
bogomips	: 3392.06
clflush size	: 64
cache_alignment	: 64
address sizes	: 39 bits physical, 48 bits virtual
power management:


#+end_example

- Compilando aplicação OpenMP com Scorep

#+begin_src sh :results output :exports both
cd benchmarks/MM/
$HOME/Programs/scorep-2.0.2/bin/scorep gcc -fopenmp -O2 hpcelo.c continuos.c -o continuos_sp
ls
#+end_src

#+RESULTS:
#+begin_example
continuos.c
continuos_sp
continuosT.c
hpcelo.c
hpcelo.h
Makefile
normal.c
normalT.c
tiling.c
tilingT.c
#+end_example

- Habilitando o trace para a execução da aplicação:

#+begin_src sh :results output :exports both
cd benchmarks/MM/
export SCOREP_ENABLE_PROFILING=true
export SCOREP_ENABLE_TRACING=false
export SCOREP_TOTAL_MEMORY=2G
export SCOREP_METRIC_PAPI=
export SCOREP_METRIC_PAPI_PER_PROCESS=PAPI_L1_TCA,PAPI_L2_TCA
export SCOREP_METRIC_RUSAGE_PER_PROCESS=all
export SCOREP_MEMORY_RECORDING=true
export SCOREP_EXPERIMENT_DIRECTORY=continuosExecution 
./continuos_sp 1000
ls
#+end_src

#+RESULTS:
#+begin_example
HPCELO:1.065932
continuos.c
continuosExecution
continuos_sp
continuosT.c
hpcelo.c
hpcelo.h
Makefile
normal.c
normalT.c
tiling.c
tilingT.c
#+end_example
